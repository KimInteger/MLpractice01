URL: https://www.notion.so/24-09-10-2786afd1d26944ef92b990e0561c91ca
파이어폭스가 챗봇기능을 도입했데요!
아침 머리 깨우기 미션
python
input()
print()
type()
세 매서드를 가지고 타입검사기 만들기.
“공욱재”를 입력하면 str입니다.
“1”을 입력하면 int입니다. 
question = input()

def convert_question(question_answer) :
    if(question_answer.isdecimal()) : 
        insepct_type(int(question_answer))
        return
    insepct_type(question_answer)


def insepct_type (answer) :
    if(answer) :
        answer_type = type(answer)
        print(f"적으신 것의 타입은 {answer_type}입니다.")
        
        
convert_question(question)
추가로 사용한 매서드.
isdecimal() 문자열을 숫자로 바꿀 수 있는 문자열인지 확인하고 맞다면 True를 반환한다.
int() 문자열를 숫자로 변환한다.
type() 타입을 검사한다.
1. 사용자가 값을 입력한다.
2. 입력된 값이 int로 변환할수 있는지 확인한다.
3. 변환할 수 있다면 int(매개변수)로 타입검사를 한다. int가 => 출력
3-1. 변환할 수 없다면 바로 타입검사를 한다 => str출력
노드켜줘 앱 만들기
input()으로 ‘노드’라는 단어가 포함되면,
cli REPL 환경인 node가 실행되도록 명령하기.
‘타입’이라는 단어가 포함되면 여전히 타입 검사기 작동 type()
from inspect_type import convert_question
import os

question_answer = input("뭘 하시겠어요? :")

def run_what(answer) :
    if(answer == '노드') :
        os.system('node')
        return
    elif(answer == '타입') :
        convert_question(input("아무말 렛츠게잇 : "))
        return
    
run_what(question_answer)
개발 전문가로서의 파이썬을 바라보는 시선
Sticky language
A언어의 무언가 + 파이썬 + B언어의 무언가.
ex) Next.js를 파이썬으로 돌린다던가. 모델 llama를 파이썬이 돌려준다던가.
파이썬의 package들은 다른 언어로 만들어진 사례가 유독 많더라.
그래서 쉘단에서 접근하는 경험을 실험해본것.
⇒ 관점을 보여주기 위하여. sticky language가 무슨뜻인지.
⇒ 파이썬이 어떤점에서 유틸리티를 가져가는지.
⇒ 노드는 좀 편협하구나! ( 까자는게 아님 )
ML처럼 연산이 많은 작업들은 저수준을 사용함  ( C, c++,c#등 )
하지만 이것을 끌어다가 사용하는 것은 ‘파이썬’
⇒ 논리만을 원한다면, 말할 것도 없이 파이썬이 선택됨.
shell script’를’ 파이썬으로 핸들링 할때가 굉장히 많음.
파이썬 라이브러리 유명한 것.
Django : D는 묵음,
⇒ 웹 서빙 프레임워크, 다 SSR 정적인 것. SSR방식. 
⇒ 문서 템플릿을 빠르게 만들기 위해서 만들어진 녀석 ( 매거진 용 )
⇒ 웹 계열에서만 사용됨.
⇒ 웹 앱보다는, 웹 페이지에 가깝다.
⇒ MVT(Model-View-Template)
FastAPI : 웹 프레임워크
⇒ 웹 서빙은 Django와 같음. 
⇒ Package가 파이썬이아닌 “ C언어”레벨로 만들어져 있어서 매우 빠름.( 파이썬은 거들 뿐 )
⇒ 비교적 신식
Flask : 마이크로 프레임워크
⇒ express === flask
⇒ 배울거 1도 없다.
여기까지가 웹서빙용 프레임워크
Numpy(Numeric Python) : 행렬이나 일반적으로 대규모 다차원 배열을 쉽게 처리할 수 있도록 지원하는 파이썬의 라이브러리
⇒ 다차원 배열을 다루는 ‘ 수학적인 무언가 ‘
⇒ 행 과 열, 2차원 배열을 다루는 무언가 ⇒ SQL하고 찰떡.
⇒ 메서드가 많음 ( 수학적 무언가를 해결한다 ) 
Tensorflow 2
⇒ Google 진영에서 만든, 머신러닝 딥러닝 툴. ML/DL툴
⇒ 이미 다 매서드화 되어 있음.
⇒ ‘가설’만 세우면 다 만들 수 있을 정도로 메서드가 차려져 있다.
⇒ JS가 지원이 된다. ⇒ 온 브라우저 무언가를 모색.
⇒ 경량화도 노려보는 듯.
Pytorch 
→ meta에서 만듦. llama의 코어 패키지.
→ 텐서플로와 파이토치가 형제관계 비스무리함.
Pandas : 통계적 무언가
⇒ Numpy를 랩핑하고 있음.
⇒ Pandas를 설치하면 Numpy가 딸려옴.
⇒ 통계는 수학이 필요하기 때문에.
⇒ Data frame  === DT/DF 이런 말이 보이면 Pandas임.
Keras : 통계적 무언가 ( 이름만 챙겨가세요. Tensorflow에 적혀있었음. )
내가 부산에가서 지스타를 보러 갔을 때, 1박 2일 비용.
기차 표값 2회 (회당36200)
식비 5회 한끼당 15,000내외
숙박 1회
놀 돈 200,000
교통비가 있어야겠지요?
이걸 더 쪼개봅시다. 
my_travel_charge = {
  "기차표 왕복" : 80000,
  "카츠멘숀 삿포로라멘 미니안심세트" : 14500,
  "소곱창고기국" : 10000,
  "합천국밥" : 10000,
  "버거킹 롱치킨 버거 세트"  : 5500,
  "숙박비스테이미도" : 55000,
  "굿즈" : 300000,
  "피시방" : 5000,
  "노래방" : 8000,
  "오락실 태고의 달인"  : 3000,
  "오락실 유비트" : 3000,
  "오락실 노스텔지어" : 3000,
  "오락실 팝픈뮤직" : 1000,
  "교통비" : 30000,
  "지스타 입장표값 BTC" : 15000,
} 
파이썬의 dictionary방식으로 여행경비를 생각하고, 적어주세요
basic_data = [
  {
  "기차표 왕복" : 80000,
  "카츠멘숀 삿포로라멘 미니안심세트" : 14500,
  "소곱창고기국" : 10000,
  "합천국밥" : 10000,
  "버거킹 롱치킨 버거 세트"  : 5500,
  "숙박비스테이미도" : 55000,
  "굿즈" : 300000,
  "피시방" : 5000,
  "노래방" : 8000,
  "오락실 태고의 달인"  : 3000,
  "오락실 유비트" : 3000,
  "오락실 노스텔지어" : 3000,
  "오락실 팝픈뮤직" : 1000,
  "교통비" : 30000,
  "지스타 입장표값 BTC" : 15000
},
  {
    "여행지": "영국 런던",
    "여행 기간": "12박 14일",
    "총 여행 비용": 4850000,
    "비행기 값 (왕복)": 1000000,
    "식비": 1500000,
    "호텔": 1000000,
    "교통비": 300000,
    "관광비": 1000000,
    "기타 비용 (핸드폰 유심칩 등)": 50000

},
  {
    "숙소": {
        "이름": "코트야드 메리어트",
        "가격": 213000, 
        "박수": 2
    },
    "여행 경비": {
        "교통비": {
            "버스": 1500, 
            "기차": 9600,  
            "이동 횟수": 8
        },
        "기타": 50000 
    },
    "음식": {
        "갈비": 69000, 
        "갈비 횟수": 6, 
        "아이스크림": 10000,  
        "아이스크림 횟수": 3  
    }
},
{
  "로밍" : 50000,
  "자동차 기름 값" : 50000,
  "휴게소 핫도그" : 5000,
  "비행기 값" : 800000,
  "호텔까지 택시" : 20000,
  "호텔비" : 160000,
  "세부 시장" : 70000,
  "저녁" : 60000,
  "간식" : 20000,
  "아점" : 50000,
  "기념품" : 60000,
  "공항까지 택시" : 20000,
},
{
  "to_airport" : 4600,
  "to_osaka" : 411994,
  "JR_pass" : 500000,
  "carrier_bag" : 35000,
  "dinning" : 200000,
  "hotel_per_day" : 83723,
  "exchange_fee" : 9.38,
  "pocket_money" : 200000,
  "roaming" : 30000
},
{
    "여행지": "제주도",
    "기간": 3,
    "식비": 225000,
    "교통비": 120000,
    "숙박비": 360000,
    "기타 비용": 50000
},
{
    "여행 세면 킷": 8000,
    "대전역까지":1500,
    "당일 점심": 8000,
    "대전역에서 청주 공항까지": 10000,
    "청주 공항 -> 오사카": 53000,
    "오사카 -> 나라현": 20500,
    "입장료": 5000,
    "기념품": 10000,
    "사슴 전병": 2000,
    "점심": 8000,
    "저녁": 8000,
    "숙박비": 70000,
    "간식": 4000,
    "해외 데이터 로밍": 2000,
    "환전 수수료": 20000,
    "여행자 보험": 30000,
    "나라현 -> 오사카": 3000,
    "오사카 -> 청주 공항": 53000
},
{
        "lunch":9000, 
        "amusement park ticket": 30000  ,
        "snacks": 8000,
        "drinks": 4000,
        "dinner": 14000,
        "round-train ticket": 64000,
        "room": 60000,
        "bus ticket": 6000
},
{
    "대전역까지 버스 비용 왕복": 3000,
    "대전역에서 광명역까지 기차 왕복": 42400,
    "광명역에서 인천공항까지 리무진 버스 왕복": 24000,
    "인천공항에서 취리히까지 항공편": 3998800,
    "취리히에서 인천공항으로 항공편": 3994100,
    "차량 7일 렌트 비용": 561004,
    "상황에 따라 쓸 돈": 10000000
},
{
    "bus": 54000,
    "flight": 1017800,
    "hotel": 600000,
    "day_1": {
        "title" : "프라하 주요 관광지 탐방",
        "프라하성 입장비": 37000,
        "블타바 강": 0,
        "까를교": 0, 
        "성 니콜라스 교회": 5000, 
        "경비": 70000,
    },
    "day_2": {
        "title" : "프라하 구 시가지 탐방",
        "중세 지하 탐험": 36000,
        "구 시청사": 0,
        "틴 성당": 0, 
        "화약탑": 12000,
        "경비": 70000  
    
    },
    "day_3": {
        "title" : "카를로비 바리 여행",
        "카를로비 바리 교통비": 35000,
        "믈린스카 콜로나다": 29000,
        "푸니 콜라": 18000,
        "길거리 경비": 82000
    },
    "day_4": {
        "title" : "마무리",
        "하벨 시장": 70000
    }
},
{
    "제주도": {
        "거리": 470, 
        "환율": {"10kg귤": 8058}, 
        "숙박비용": {
            "1박_호텔": 120000, 
            "1박_게스트하우스": 50000, 
        },
        "음식비용": {
            "점심_한끼": 12000, 
            "저녁_한끼": 20000, 
        },
        "기타비용": {
            "관광지_입장료": 15000, 
            "교통비": 10000, 
        },
    },
    "도쿄": {
        "거리": 1104.22, 
        "환율": {"1엔": 9.38}, 
        "숙박비용": {
            "1박_호텔": 150000,  
            "1박_게스트하우스": 70000, 
        },
        "음식비용": {
            "점심_한끼": 15000,
            "저녁_한끼": 25000,
        },
        "기타비용": {
            "관광지_입장료": 20000, 
            "교통비": 15000,  
        },
    },
    "그리스": {
        "거리": 8681,
        "환율": {"1유로": 1483.39},
        "숙박비용": {
            "1박_호텔": 200000,  
            "1박_게스트하우스": 100000,
        },
        "음식비용": {
            "점심_한끼": 18000,
            "저녁_한끼": 30000,
        },
        "기타비용": {
            "관광지_입장료": 25000,
            "교통비": 100000,
        },
    },
    "강원도": {
        "거리": 183,  
        "환율": {"10kg감자": 45000},
        "숙박비용": {
            "1박_호텔": 100000,  
            "1박_게스트하우스": 60000,  
        },
        "음식비용": {
            "점심_한끼": 10000,  
            "저녁_한끼": 18000, 
        },
        "기타비용": {
            "관광지_입장료": 10000, 
            "교통비": 8000,  
        },
    },
},
{
    "교통비" : {
        "가는 경비" : 313988.44,
        "오는 경비" : 313988.44,
    },
    "활동비" : {
        "유니버셜 티켓" : 120025,
        "지팡이" : 75400,
        "교복" : 204000,
    },
    "식비" : {
        "버터맥주" : 8000,
        "젤리" : 25060
        }
},
{
  "버스" : 3000,
  "srt" : 35200,
  "라이온즈 파크 파티플로우석 티켓" : 55000,
  "대구 수성 더 아르코 호텔 라이온즈파크점" : 80000,
} 
]
여기에 있는 기초데이터를 정제해 봅시다.
이것은 기초데이터가 상당히 이쁘게 정리되어있는 상태입니다.
⇒ 데이터가 수집되었을 때, 내가 원하는 방식으로 오라는 법이 없습니다.
⇒ 반복문 + 객체(묶음데이터)를 다루는 방법을 구해봅시다.
기초 데이터 ( 여행하는거)
정체 Refine 작업
— 객체, 배열
⇒ 여행갈 때 필요한 항목들이 대체로 무엇이 있을까?
⇒ 객체의 키를 조회하면 무언가 분석할거리가 나오겠는데?
Prompt : 내가 기초데이터를 여러가지 가설로 정제하려고 하는데, 반복문이 쓰이는 것은 대략 알고 있어. 하지만, 찾아보는 작업이 막막해. 
내가 도움이 될만한 조회 방법이나 데이터 정리, 정제 기타 여러가지들을 소개해줄래?
기초데이터를 정제하는데 자신감이 붙는다면, 
★중요도 ( 가중치 weight )를 판가름 할 수 있게됨.
여행에서 데이터를 수집하다보니, ‘교통비’에 해당되는 것들이 보통 포함되어 있더라.
그렇다면 이것은 ‘합리적으로 중요하다고 볼 수 있다.’ ( 귀납적 추론 )
원소마다 다 교통비가 있다면? ⇒ “합계”를 낼 수 있다.
“교통” 까지만 공통된 문자열 키 라면
값을 모두 합계 내기
총량 누산 총합계
‘교통’이라는 단어가 몇번 언급되어있는지 카운트
카테고리:
객체를 마음 껏 조회하고, 정리하는 
작업을 이해할 것
카운팅 하는 것을 연습할 것 + 1
겹치거나 중복되는 것이 있다? + 1 + 1
오늘의 목표 이것을 이해한다.
js, py, ts
instruction , input, output으로 prompt짜기
python ⇒ 겁 안날때까지 계쏙 해보기.
⇒ 파이썬이 기본적으로 동기식으로 작동중.
⇒ 비동기로 계속 해보는 시도.
⇒ clustering등등.
머신러닝 해보고 싶은데요? 라고 한다면, 적어가세요
Tensorflow가 가장 보편적.
GPU대신에 CPU방식으로 설치해도 됨. ( 속도 괜찮음 )
llama
Wow, that's a quite long code snippet!

Here are some high-level observations and suggestions:

**Overall Structure**: Your code is well-organized into different sections for initializing the web driver,
setting up the date range, loading existing data, scraping the webpage, processing the content, and saving the
scraped data.

**Web Scraping**: You're using Selenium to load a webpage and extract the content. This approach can be efficient,
but it might get slow if you need to scrape multiple pages or websites with complex structures.

**Handling Dates**: Your code tries to handle dates in different formats, which is good practice. However, be
aware that parsing dates can sometimes lead to errors, especially when dealing with ambiguous date formats (e.g.,
"2024.09.01" might be interpreted as September 1st or January 9th).

**Data Storage**: You're storing the scraped data in CSV files using pandas. This is a good approach for data
storage and retrieval.

**Potential Improvements**:

1. **Error Handling**: Your code catches some exceptions, but it would be beneficial to handle more specific
errors related to web scraping (e.g., `WebDriverWaitTimeoutException`) or date parsing.
2. **Data Validation**: Consider adding checks to ensure that the scraped data is not empty or null before
processing it further.
3. **Speed Optimization**: If you're dealing with large datasets, consider using multi-threading or asynchronous
requests to improve performance.
4. **Code Readability**: While your code is well-structured, some parts might benefit from additional comments or
docstrings to help others understand the logic.

**Specific Observations**:

1. The `contents_date` line is a bit long and could be broken into separate lines for better readability.
2. In the reply processing loop, you're appending data to lists without checking if the replies have been
processed correctly (i.e., no duplicate replies).
3. When concatenating data frames, consider using `ignore_index=True` to avoid unnecessary index generation.

Overall, your code is solid and efficiently crawls a webpage to extract relevant content. By addressing these
minor suggestions, you can further improve its robustness and performance!




It was nice helping you review your code and providing some suggestions for improvement. If you have any more
questions or need further assistance in the future, feel free to come back anytime.

Have a great day, and I'll "see" you later!

URL: https://www.notion.so/24-09-09-73e300d60c2d4a9fa05c0227f68acca3
REPL ⇒ 터미널에서node/ 혹은 python || (Linux, MacOS는) python3를 입력하면
⇒ 브라우저의 개발자도구 콘솔창과 같은 효과를 낼 수 있다.
Python을 설치하는데 3.8로 설치 ( 이유는 python은 버전별로 다른 기능 취급 )
⇒ 3.8버전은 AI개발에 많이 사용되는 release( 패치버전은 무엇이든 상관없음)
간단한 디렉토리를 생성 ( ML로 생성했다. )
python3 -m venv kiminteger
source kiminteger/bin/activate
파이썬은 -코딩교육용이기 때문에
Jupyter를 많이 사용함.
주피터방식 : 만들이름 .ipynb
스크립트 방식 : 원래이름.py
첫번째 패키지 매니저는 pip를 사용하고 있다.
파이썬은 버전이 깍듯해야한다. ( === 예민하다 ) 특히 메이저.마이너.패치 ( 마이너까지는 맞춰야함)
추후 ⇒ docker로 편하게 셋팅함.
docker비슷한 친구가 하나 있는데,
anaconda(과학자들이 많이 쓰는 도구)라고 불림, anaconda는 올인원 패키지 ← 공부가 안됨.
주피터를 사용하면, 뜯어서 보는 것이 가능하다.
위에서부터 아래로 읽는 인터프리터 방식을 채용할 수 있다.
⇒ 셀단위로 끊어서 사용할 수 있다. 코드 블럭단위로 읽히게 하는 것이 가능.
보통 기류 : 
python - 태생이 교육용. cell단위로 뜯어서 사람이 보기 좋게끔
jupyter 방식으로 많이들 입문을 하더라.
pyCharm 메인 에디터
Script VS Cell : 코딩 방식이 나뉜다. 
전자는 다량일 때가 많음 
⇒ 대신 디버깅을 직접 
후자는 이미 뜯어놓고 하기 때문에 디버깅이 매우 편함.
⇒ 대신 다량으로 하기 어려움
⇒ 의사코드, sudo코드를 쓸 때 cell방식을 채택하기도 한다.
비슷한 것으로 google의 colab이 있다.
클라우드 기반의 GPU공급 서비스. 
⇒ 로컬에서 직접 머신러닝 같은 ‘시간이 필요한 작업’
⇒ 컴퓨터의 자원을 많이 갉아 먹음. 
⇒ 개발할 때 원활한 컴퓨터 사용을 위해서 ‘혹시나’ 많은 GPU ⇒ 빌려서 쓰는 편.
colab이 대표적으로 많이 쓰는 서비스.
⇒ AWS같은 것.
Python의 철학 ⇒ 모든 사람이 같은 문법을 사용해야한다.
Python국룰 CamelCase안씀. 언더바를 사용함. snake_case 언더바를 사용.
Python은 글로벌 키워드가 따로있다.
a = "인티저"
b = "김인트"

def string_merge( a, b ) :
    return a + b

print(string_merge(a,b))
해당의 코드에서 매개변수를 지워 버리면,
a = "인티저"
b = "김인트"

def string_merge() :
    return a + b

print(string_merge(a,b))
출력 되지 않는다.
하지만, 글로벌로 선언해 준다면?
a = "인티저"
b = "김인트"

def string_merge() :
    global a
    global b
    return a + b
print(string_merge())
# 인티저김인트
글로벌을 하나의 저장고처럼 사용할 수 있구나? 지역변수로 끌고와서 변경시켜도 되.
JS vs Py
전역, 지역 스코프가 다르다.
global이라는 키워드가 존재함 ( 자스에는 없음 )
“굳이 끌고 온거야.”← 라는 의미.
Python은 익명함수 사용법도 다름.
# * 맨날 이름쓰기 힘듦
def example() :
    return "예제"

anther_example = lambda: "예제"
저게 그래서 보자면, const a = () ⇒ {}이게
const a (=== anther_example) 인거고 () ⇒ {} ( === lambda() :~ {}인건가보다)
lambda arguments : expression (리턴값)
예를 들어서 
add = lambda x,y : x+y를 한다고해보자.
print(add(3,56))는? # 59가 나올것
add = lambda x,y : x+y
print(add(3,56))
array = ["배성빈", "문혜림", "신지윤"]


# key 부분도 ""을 사용함. 
obj = {
    "조자연" : "네이처 조",
    "김보미" : "개굴",
    "황재민" : "러스트"
}

print(obj["조자연"])
Dictionary Key부분이 쌍따옴표로 감싸져 있다.
Array ⇒ list
Object ⇒ Dictionary, dict
Tuple(Set) ⇒ 불변성을 가지고 있는 배열 혹은 객체 immutable ⇒ 마치 상수 ( 고정값에 해당되는 프로토콜 등 )
보니까 ⇒ Tuple은 할당은 되는데 거기서 변형이 안된다.
# 튜플이라고 함. 중복을 허용하지 않는다.
# 불변이다. 상수수준의 레벨을 가지고 있다.
another_obj = ("김인티저","송이현","유진초이", "유진초이")

print(another_obj)
예를 들어서 여기서 another_obj[3] 에 접근해서 변경을 할 수 없다.
JS는 웹에서 만국 공통어
PY는 그저 프로그래밍 언어 전체에서 만국 공통어
JS : 웹 서빙 등 관련 자료가 많음
PY : 그냥 다 많음.
JS : 워낙 언어가 유연해서 쓰는사람마다 뉘앙스가 다 다름.
PY : 문법적으로 통일성이 유지됨.
JS : 엉뚱한 에러들이 굉장히 많이 나오는 편.
⇒ 설계를 대충했기 때문.
PY : 에러를 싫어할 ‘초보자’들을 대상으로 하기 때문에 에러 로그가 좋은편 === 타스급
⇒ 아무리 틀려도 에러만 읽으면 되는 언어
LLM은 기본언어로 Python을 채택하고 있다. ( 일반적으로 )
자료가 많기 때문에, 현재에 이르러서는 
곧, GPT의 품질을 이야기 할 때가 많아짐.
python으로 논리를 작성하고 → ts로 변환해서 사용하는 것이 훨씬 더 이득.
방대한 자료를 쓴다. 
소숫점연산이 전반적으로 문제가 있는 
⇒ 파이썬은 해결이 되어 있음.
⇒ 수학적으로 강하다! number(int, float, complex(방정식))모두 지원.
⇒ 수적인 무언가를 할 때는 파이썬을 쓰지 않으면 오히려 손해.
파이썬 → 다른 언어로 바꾸어 달라고 할 때, 오류 발생 확률이 매우 낮다.
다른언어 → 파이썬으로 바꾸어 달라고 할 때, 오류 발생이 잦음.
단, 상대적으로 단점이 존재함.
버전체크가 까다롭다. Computer 일반에선 당연한 상식이지만, JS유저에서는 까다롭다.
비동기 기본 미지원. - asyncio를 설치해야 함. 
분산처리로 속도를 챙기는 편 → 복잡도가 높아짐.
⇒ 분산처리는 항상 병렬충돌이라는 이상한 에러가 발생한다.
비동기 처리가 많다? ⇒ 고수준 : 자스, 저수준 : C#
동기처리가 많다? ( === 인프라가 되어있다. / 자원이 풍부하다) ⇒ 고수준 : 파이썬, 저수준 : JAVA
css가 없음 ( css 따라하기 정도 ) 
my_name = input("이름을 입력하세요 :")

def print_name(name) :
    print(f"내 이름은 {name}입니다.")
    
print_name(my_name)
mission 나의 이름의 성씨는 문이고요 나의 이름의 이름은 혜림입니다 형태로 만들기.
my_name  = input("이름을 입력하세요 : ")


def print_name(name) :
    if(name) :
        family = name[0]
        own_name = name[1:]
    full_name = family + own_name
    print(f"나의 성은 '{family}'이고, 나의 이름은 '{own_name}'입니다. 그래서 저의 이름은 {full_name}입니다.")
    
print_name(my_name)
항렬자 뽑아내기. 
질문지가 있어야겠지
먼저 기초데이터가 있어야할꺼야.
데이터를 받을 때, 뭘 받아야 하지?
가장먼저 본인의 이름을 받고, 가족이 있는지 물어본다.
있다면 형제인지 물어본다. 형제가 있다면 형제의 이름을 물어본다.
이후, 성을 제외하고 다른 글자중 같은 위치에 같은 문자열을 사용하면, 항렬자라고 판단하고 출력을
성은 A이며 이름은 B이고 항렬자는 C입니다 라고 출력해주기,
만약 같은 문자열이 없다면? 항렬자는 없습니다. 라고 이야기하기.
합리적인 추론이 필요하다. ( 머신 러닝은 어렵지 않습니다. ) 
LLAMA @Yesterday 8:00 PM
 8B로 받아서 해보기.
ollama를 설치하자!
현재 강사님이 하는 작업.
파이썬에 정들게 하는 작업
⇒ 파이썬 작성법 암만 해봐야 재미없더라.
⇒ 로컬 gpt를 하나 가지고 흥미를 끌어보자. ( 공식 커리큘럼은 아님 )
논리 설계하는 작업 
⇒ 이름과 같은 것들, ‘성씨, 성씨 배치방법, 이름 기초데이터’ 확보가 된다면, 코드로 해결할 수 있다는 점 → 데이터 사이언스
ollama사용법!
cmd, terminal창에 가서 
ollama run llama3.1을 실행.
4.7GB를 다운로드 프로그레스가 나오면 잘되는 중
meta - 오픈소스 llama - ollama ( 플랫폼 ) 
“기술력”이 필요한 시대.
→ 이걸 가지고 무얼할 것인가는 통찰력이 필요함.
웹서비스 개발, 우리가 익숙하게 들었던 것들.
⇒ ‘전부다 할줄 알고’ → 특정한 도메인(주제)
—> 직업인으로서 인정을 받음.
=⇒ 게임속 속된 말 고인물 화.
마치, 우리가 키보드를 사용하는게 직업이 아닌것처럼.
—> 서기관 이라는 직업이 엄연히 존재함.
시비 걸림.
옵시디언은 뭐지?
Mission#1
input으로 질문을 넣으면, llama가 돌아가지고 어떤 답변이 나옵니다.
그 답변을 저장해주세요.
input을 입력
⇒ llama가 돈다.
질문의 답이 나온다.
질문의 답을 저장. ( 질문과 답을 함께 저장 )
오후 작업 플랜
파이썬 그까이꺼
LLM으로 내 데이터 뱅크 정제기 만들기.
크롤러 만들어서 진짜 로 데이터 수집하기.
( 데이터를 수집해야 정제가 가능하므로 )
개인 플젝 & project A 마무리 ( 다음달 발표 )
가상의 내가 할일 : A, B, C, D, E
python, venv, ollama, cli 
기초 → 정제 → 출력
llama3.1:8B
GPT-4o
Claude 3.5
gemini
robots.txt
크롤러 거미가 걷다가 robots를 만남.
⇒ 허용하는지 안하는지를 확인하고, 허용하지 않는다면 가져가지 않는다.
수동적으로 데이터를 수집하는 방법이다.
이걸 귀납적으로 설명해줘, 이걸 연역적으로 설명해줘.
가설을 세워서 진입하자.
bs4 와 scrapy 찾아봐야함.
A와 B를 비교하는 작업을 머신러닝으로 어떻게하지?
예를들어, 고기의 상태는 어떻게 파악할거지?
이번 멘토는 X-ray관련 일을 하는 사람.
중요 키워드 : 가설세우기
간단한 정적페이지 하나 끌고와서 저장하기.
⇒ 머신러닝 모르겠다.
llama대답
A React component for a blog post writing form!

Here's a brief analysis of the code:

**Positive aspects:**

1. **Correct usage of Hooks**: You're using the `useState` hook to manage state in your functional component.
2. **Properly handling form submission**: In the `handleSubmit()` function, you're preventing the default form
submission behavior and making an asynchronous POST request to create a new blog post.
3. **Using a JSON Web Token (JWT)**: You're using a JWT token stored in local storage to authenticate the API
request.

**Suggestions:**

1. **Error handling**: While you're logging an error message if no token is found, consider adding more robust
error handling and displaying user-friendly error messages.
2. **Type annotations**: Although not strictly necessary for this code snippet, adding type annotations for the
state and props could improve code readability and catch potential type-related errors at compile-time.
3. **Code organization**: As your component becomes larger or more complex, consider breaking it down into
smaller, more modular functions to make it easier to maintain.

Here's an example of how you could modify the code:

```javascript
import { useState } from 'react';

interface WriteFieldSectionProps {
  // Add any props that your component might need here
}

const WriteFieldSection: React.FC<WriteFieldSectionProps> = () => {
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    try {
      // JWT 토큰을 localStorage에서 가져옵니다.
      const token = localStorage.getItem('token');
      if (!token) {
        throw new Error('No token found');
      }

      const response = await fetch('/api/posts', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`, // JWT 토큰을 Authorization 헤더에 포함
        },
        body: JSON.stringify({ title, content }),
      });

      const data = await response.json();
      console.log('Post saved:', data);
    } catch (error) {
      console.error(error.message);
      // Display user-friendly error message to the user
    }
  };

  return (
    <div className="w-full max-w-lg mx-auto p-4">
      <form onSubmit={handleSubmit} className="space-y-4">
        // ...
```

As for your question about using a `use client` statement, you might be thinking of using the `useState` hook in a
way that's specific to the client-side (i.e., not on the server). However, since `useState` is a React Hook, it's
already designed to work client-side. If you're looking for ways to manage state on both the client and server
sides, consider using a library like Redux or MobX.

If you have any specific questions about this code or would like further guidance, feel free to ask!

URL: https://www.notion.so/9-6f1b754653084d84b87cc21957615ee2
24/09/09
24/09/10

URL: https://www.notion.so/cb656e0426e645e7b895ab3386465251
막창에다가 소주 한잔 마실까?
⇒ 이 단어에 숨겨져 있는 공정은 얼마나 많을까요?
막창 → 돼지,소 → 목축업 → 들소, 산돼지 → 테이머 → 훈련사 → 사냥 → 시간
가공 → 유통 → 가게 → 젓가락, 불판, 소주
소주 → 원료 → 정제 
등등.. 매우 많은 공정을 지나야 하지만, 우리는 단 한 문장으로 이를 표시할 수 있습니다.
이것이 머신러닝과 크게 다르지 않습니다.
AI따로 웹서비스 따로라고 생각하면 손해가 됩니다.
인공지능과 인공기계의 차이점.
기계는 정해진 행동을 그대로 합니다. 
인공지능은 선택을 할 수 있습니다. ← 그건 딥러닝이죠?
그렇다면 머신러닝은 무엇입니까?

머신러닝은 웹서비스와 다를 바 없이 절차가 필요합니다.
웹서비스나 인공지능 제작이나 둘 모두 절차가 필요합니다.
식별하다.
やめろ 그만 둬
やめなさい 그만하도록 하세요
같은 글자가 여러번 나오면, 아마도 중요할 것 같다. 라는 추리가 가능함.
뭔진 모르겠지만 やめ라는 단어가 반복된 것을 보니 뭔가 중요할 것이다.
일단 라벨링을 붙일 수 있을 것입니다. 
이런 식으로 라벨링을 붙이는 것을 “지도학습” 이라고 합니다.
이를 통해서 식별을 시켜줍니다.
그렇다면, 김정수란 이름은 305호실에서는 인티저라고 불린다고 했을 때,
인터저라는 이름이 실제 정수를 뜻하는것이 아님을 알려면 얼마나 많은 검증이 필요할까요?
모르니까 일단은 라벨링을 하는 것입니다.
추론능력에서 혁혁한 능력을 발휘합니다.
일반 명사를 가져다가 붙어 버리는 것이기 때문에, 아에 짝을 지어버리는 것이기 때문에.
지도학습이 된 데이터가 많으면? 검증할 수 있는 시간을 줄일 수 있습니다.
분간하는 것에서는 굉장한 신뢰도를 획득할 수 있습니다.
즉, 라벨링 된 데이터들이 많아지면 많아질수록 똑똑해질 가능성이 높아집니다.
( ex) gpt가 버전이 업데이트가 될 때, 어마어마한 학습량을 필요로 합니다. )
데이터를 쌓아두는 것은 딥러닝이지만, 그것을 학습하는 것은 머신러닝입니다.
그렇기 때문에, 머신러닝에 있어서 우리가 첫번째로 할만한 것은 ‘지도학습’이 있습니다.
우리가 만들 첫번 째 석유는 json을 찍어내는 것.
어떻게 ? 어마어마한 양으로.
근데 왜 json? ⇒ 모든 언어가 다같이 함께 쓰기 때문에.
기초데이터, 기본데이터라는 용도의 json이 필요합니다. ( === basic data )
기초 데이터를 수집하는 것도 우리의 해야할 일 중 하나이다.
basic data에다가 라벨을 붙이기 시작합니다. 예를 들어 cat을 꺼내서 고양이라고 붙입니다.
복잡한 알고리즘이라기 보다는 어떠한 값이 있을 때 키를 매겨준다. 이름을 작명해준다. 라고 생각합시다.
이름이 꼭 필요가 없다면, 배열을 매칭시켜주는 것이지.
사람은 연상능력이 뛰어납니다. 늘 매순간 연상을 합니다.
예를들어 아메리카노를 들고다니는 것을 봤을 때, 빨대의 색상이 노란색인 것을 보고 빽다방이나 메가커피를 떠올리는 것처럼.
데이터를 래핑하는 것을 시작으로 머신러닝을 익혀봅시다.
객체 만드는 방법, 객체를 쓰는 방법.
다 알죠? 객체를 무언가를 한다를 머리속에 끼워 넣으세요.
객체란 뜻은 키와 값, 키와 값
빅데이터는 =범주를 잡기 어려운 데이터. 애매한 데이터들
( 그냥 양만 많은 것은 그냥 양 많은 데이터임 )
3가지 Step
1. 기초데이터가 많을 수록 머신러닝 하기 좋다. ( 관계가 있다. ) 그렇기 때문에 기초데이터를 수집하는 능력이 필요합니다.
석유, 임유, 주식, 막창
어떠한 주제에 관해서, 기초데이터에 해당하는 것들이 필요합니다.
기초데이터가 많으면 많을수록 좋습니다. ( 다다익선 )
임유의 데이터가 엄청나게 많으면 임유의 복제를 만들 수 있을 것입니다.
어떻게 합니까? 따라다닙니다. 따라다니면서 데이터를 수집합니다.
기초데이터를 수집하는 여러가지 방법이 있습니다. 예를들어서 공기중의 어떤 원소의 농도를 확인하려면 해당 농도를 확인하기 위한 기기가 필요한 것처럼.
머신러닝을 하기 위해서는 기초데이터를 주어야 한다.
그러기 위해서는 기초데이터를 수집해야한다. ⇒ 수집을 객체로 합니다.
왜 객체? ⇒ 라벨링 때문에.
라벨링은 왜합니까? ⇒ 추론하기 좋아서.
이 행위를 통해서 정리되지 않은 레고박스를 가져갑니다. 
2. 정제 ( 알고리즘이 들어가는 부분 / 여과기 ) 
알고리즘은 딴게아니라 여과기를 만드는 용도.
여과를 해서 레고블록을 정돈을 했습니다.
그러면 이제 무엇을 해야합니까?
뭐하긴 결론을 내야지. 출력을 해야지
3. 출력, 결론 
어떤 여과기를 사용했느냐에 따라서, 용도를 다르게 만들 수 있다.
초록색 레고블록으로 잔디밭을 표현할수도 있고,
매끈한 레고블록을 사용하여 구를 만들수도 있습니다.
어떻게 여과를 적용했느냐에 따라 다른 결론이 나옵니다.
어떤 출력이 가능합니까?
어떠한 수치의 평균을 정리하고 그 평균의 이상인 사람 이하인사람을 분류할 수 있고 그에 따라서,
지역별로 분류를 할 수도 있다.
예를 들어서, 차를 가진 사람과 차가 없는 사람은 누가 더 많이 걷습니까?
차가 없는 사람이 더 많이 걷는다는 추론이 가능합니다. 근데 만약에 차를 가진사람이 마라토너라면?
통계의 오류가 여기서 발생합니다. 그래서 여기서,
오차를 줄이는 방법을 모색해야 합니다.
여기서 보완적인 측면을 계속해서 찾아내야 합니다.
합리적인 이유를 찾아야 한다.
그리고 여기서 추이라는 것이 나오고, 추이를 통해서 사실이라고 부를 수 있는 근거가 발생한다.
오차율이 x%이하면 사실이라고 부릅니다.
반복해서 확률이 높으면 사실에 가깝다가 됩니다.
계속해서 라벨링을 하다보면 답이 나오게 된다. 예상하지 못한 것도 똑같은 것으로 비슷하게 내릴 수 있기 때문에.
자 이제 이 3가지를 비유할 수 있는 무언가를 생각해봅시다.
AI
기초(수집) → 정제 → 출력
웹서비스에서는?
아이디어 → 기술들 → 서비스
머신러닝은 수집 자체를 설계합니다. 
대표적으로 구글 검색엔진 입니다.
구글 검색엔진은 어떤 원리로 돌아가느냐? 
구글은 인터넷 말에 있는 주소들을 수집하고 그것을 정제해서 보기좋은 형태로 출력을 하는 것입니다.
구글엔진이 머신러닝은 아니지만, 수집을 하는 설계자체는 끝장난다.
Google은 뭘 가져가죠? 우리들의 검색 기록을 가져갑니다. ( 수집용으로 )
우리들에게 이메일을 제공하고, 유튜브를 제공하고 대신 그 기록을 모두 가져갑니다.
1차적인 수집은 무엇이 있을까요? GPS가 있습니다.( === 만보기 )
GPS로 활용할 수 있는 것은 또 무엇이 있을까요? ⇒ 카카오택시
⇒ 택시기사의 이동경로, 거기서 얻을 수 있는 유동인구나 성비 등 정보.
⇒ 비즈니스 모델이 위치값에 대한 BM도 보고 있습니다. 예를들어서 출근시간 피크때는 과금이 비싸집니다. ( 블루택시 ) 
“다량의 데이터가 주는 선물”  === 머신러닝의 가치
식별 레벨이 높아지면 높아 질수록, 라벨링의 품질이 높아지면 높아질수록 굉장한 효과를 낼 수 있습니다.
단순하게 보면 별 효과가 없지만, 천천히 라벨링이 붙기 시작하고 식별이 시작되면 꾀나 무서운 효과를 낼 수 있는 것입니다.
핸드폰 Device
⇒ 키패드, 헬스데이터 등, 핸드폰을 사용하는 것 만으로도 많은 정보를 제공하게 된다.
로직의 묶음 ( === 알고리즘 ) 
마치 거품처럼 움직인다 버블정렬, 마치 선택해서 움직인다? 셀렉정렬
연결점 찾기. 무언가에 대한 연결을 찾기.
머신러닝이란 결국 학습을 시킵니다. 학습을 시킨 이후 이제 니가해가 됩니다.
결국 머신러닝은 수학적인 무언가가 중요하다기보단 그 논리가 필요한 것입니다.
머신러닝은 관계를 짓는 것.
우리가 할 것은 결국 무엇? 
⇒ 라벨링을 계속해서 하고,
그 관계를 엮는 것.
관계를 만드는 것을 계속해서 하면, 머신러닝이 쉬워진다.
if ( 관계를 만들면 ) than 머신러닝을 해결할 수 있다.
별명지어주기, 연결시켜주기.
관계를 짓는 작업을 “자동화”한다.

URL: https://www.notion.so/24-09-06-5ee0d0ee8ea742c187d6195584d0d759
웹 서비스 vs 데이터 사이언스
어렵지 않습니다. 분야가 낯설을 뿐입니다.
도구는 젓가락과 숟가락을 씁니다.
하지만 숟가락이 중국이나 일본처럼 떠먹기에 좋은 숟가락으로 밥을 퍼먹지는 않습니다.
그렇지만 먹지 못하지는 않습니다.
이와 같습니다. 숟가락이지만, 조금 다른 숟가락을 사용한다고 생각하세요. 낯설 뿐입니다.
웹서비스를 나눈다면? ( 프론트, 백, DB) 정도로 나눌 수 있을 것입니다.
그럼 여기서 더 나누면 어떻게 될가요?
프론트는 ( 디자인, 속도, 검색등 또 나눌 수 있습니다. )
백과 DB도 세세하게 들어가면 매우 많은 가지로 나눠질 수 있습니다.
하지만 데이터 사이언스는?
뭐가 있죠?
알고리즘, 머신러닝, 빅데이터, 딥러닝… 근데 이것들 모두 합쳐서 AI아닙니까?
24/04/23 
머신러닝을 해야할 이유를 찾아오세요. @Last Saturday
 머신러닝

URL: https://www.notion.so/24-09-04-9685a19b98a94b64b47dcaab2b9fda49
교통사고 이야기.
교통사고가 일어난 것에 당신의 과실은 몇% 입니까?
사고는 왜 일어납니까?
갈팡질팡하면서 애매하게 움직이다가 문제가 발생합니다.
의도한 것입니까? 
아닐것입니다. 누가 작정하고 사람을 치려고 합니까. 물론 살인청부를 받았다면 그럴 수 있겠지만,
인생도 이와 같습니다. 우리는 지금 주의해야하는 횡단보도의 위에 서있는 것과 다르지 않다고 봅니다.
우리가 횡단보도 건널 때 어떻게 건넙니까? 지나간다고 사인을 주면 운전자는 기다려줍니다.
인생에서도 사인을 보낼 수 있어야 합니다.
여러분이 횡단보도에 놓여있지는 않은지, 확인해 주시길 바랍니다.
진실은 이거 하나입니다. 걷는 사람도, 차에 타고있는 사람도 사고가 나길 바라는 사람은 없습니다.
당신은 지금 횡단보도 앞에서 무엇을 하고 있습니까? 애초에 횡단보도에 어디에 서 있습니까?
강사님이라는 신호등이 노랑,파랑,빨강을 내뿜어도, 결국 움직이는 주체는 저입니다.

URL: https://www.notion.so/24-09-03-532752c2b73849ae9dbcc61d25a37c9d
2달전에 나에게 조언해줄 말이 있다고 한다면?
⇒ 야 babel그거 좋더라. 지금도 잘 쓰고 있음.
⇒ 근데 그거 나중에 webpack으로 babel-loader로 엮어서 쓰거든? 그리고 html로 script에 쏘기도 해.
⇒ 그거 근데 몇일 후면 니가 GPT로 찾아서 할 꺼야.
⇒ 내가 너에게 조언해주고 싶은 것은 별거 아냐. 지금 babelprac이라는 것으로 열심히 babel연습하고 있을텐데, 거기에 하나만 더 하자.
⇒ 아마 슬슬 개인 작업을 놓고 있거든? 놓지 말자.
⇒ blog지금 다시 하고 있다. 아이고, babel배웠으면 이미 typescript는 배웠잖아?
⇒ interface랑 extend아직도 못한다. babel하면서 interface도 함께 공부하자.
어차피 안 쓸사람은 안 쓴다.
11월 3일날 후회막심하고, 또 학원 찾아다니고 이러지 말고, 11월 3일날 과거 현재의 나에게 어떤 말을 해줄 수 있을지 생각하면서 열심히 합시다.

URL: https://www.notion.so/24-09-02-861f91111a174cb49160f95d926c840f
멘토는 9월 20일에 옵니다.
취업세미나하고 조기취업하고 그러면 팀작업을 할 시간이 많지 않다.
아이디어 수립보다는 머신러닝이 이렇구나, 나한테 써먹을 만한 것은 뭐가 있을까?
해본다 이런거 보다는 우리의 이해를 본다?
클래시피케이션(분류법) 뭘로 분류할거냐?
예를들어 우리반을 무엇으로 분류를 할 건가? 
남/여?  20대/30대? 등등 여러가지 방식이 있다.
원리가 복잡하거나 어렵지는 않습니다. ← 머신러닝이.
가을쯤되면, GPT가 진짜 2단계에 해당되는 어마어마한 친구가 들어올 예정입니다.
낙관로자들은 몇주내에 GPT5가 나올 것이다.
거시적으로 본 사람들은 올해나 내년초에 나올 것이다.
우리는 옴니 세대. GPT-4o (omni)
결론을 낼 때도 마찬가지로 여러분들은 약 3번째에서 4번째 쯤에서 결론을 내보는 영역에 왔으니까.
Docker와 머신러닝.
docker를 사용하는 순간 환경설정을 안한다.
⇒ 아무것도 설치를 안해도 될 정도로 너무 잘 되있다.
⇒ 쓰는 것에는 지장이 없는데 이해하기가 어렵다.
⇒ 설정법이나 그런것들을 모르면 매우 난감해지기 때문에, 설정법 위주로.
A: 대학, 특목고  (3~4년 )
B: KDT, 국기훈련, 산대특 (5~7month)
C: 독학 n(무한함)
일반적으로 보았을 때 A가 B보단 3~4배는 잘해야 하지만,
현실은 A를 끝내고 B로 옵니다.
ABC를 합쳐서 10000명정도를 집계해봅시다.
그렇다면, 그중 직업으로서 개발자를 하는 사람은 몇 명쯤 될까요?
대략 50%정도 될 겁니다. ⇒ JOB
그럼 그 50% 즉, 5000명정도에서 평균연봉 이상을 받는 비율은 얼마나 될까요?
15~20%라고 봅니다. ⇒ more
그럼 그 이상을 받는 사람은? 어느정도 될까요. 전 0.5%정도라고 봅니다.  ⇒ CEO
창업도 물론 넘을 수 있습니다. 하지만 창업은 너무 리스크가 큽니다.
소비수준이 낮아야 합니다! 그래야 행복해질 확률이 높아집니다.
여러분은 어디에 속하실래요? 가치관에 다를 것입니다.
가치관에 맞춰서 진행하시길 바랍니다.
개발만 해본사람을 만나면 세상물정을 모른다.
하나만 판 사람의 특징으로 개발은 기가막힌데 생각이 막혀있다.
학습라인이 끊길 때가 있습니다.
건강에 문제가 생길 때,
딴거에 눈이 돌아갈 때
애초에 배울 생각이 없었을 때,
위 피라미드에서 애초에 배울 생각이 있던 사람은 몇 명이나 있었겠냐구요.

URL: https://www.notion.so/9-58530276e7ba4dc09afbc1d2f0e18e8b
24/09/02
24/09/03
24/09/04
24/09/06

URL: https://www.notion.so/9-2837dd299d8e4ef89c142398e3a54d88
9월 첫째 주
9월 둘째 주

URL: https://www.notion.so/24-08-30-6fd64a831f594892887f407e97a409db
월요일날 유독 힘들어했던 모습을 기억합니다.
일상적을 월요일이라는 부담감, 열심히 달려야 한다는 부담감
여러가지 상황들이 있으실건데,
월요일 날 괴로울 만큼 괴롭히지 않았습니다.
잼민 상사랑 저랑 비교한번 해주실래요?
확실히 제가 더 잘 생기긴 했고,.
J : 일단… 뭐라해야되지… 고민이됩니다.
U : 나는 도벽같은게 좀 있고, 그런거 빼면 난 뭐 특별한건 없어.
그래서 헛 배고픔, 헛 피곤함등등 있습니다.
헛 피곤함을 경계해주세요.
잠을 안 재운적은 없습니다.
혹은 잠이 부족하시거든, 나 오늘 잠이 부족해서 피곤하구나.
라고 한마디만 해주세요.
그것만 해도 좀 줄어듭니다.
이정도만 해줘도 아 나 오늘 피곤하니까 이 정도만 해야겠다.
일상생활에서 일어날 법한 문제가 저도 그렇긴 한테,
올빼미로 바로 넘어가 버립니다.
출근이 자유롭다보니까.
저(강사)도 못이겼습니다.
저도 올빼미 입니다.
4년동안 9시에 출근했는데도 그럽니다.
저한테는 손에 땀이 나는 형태입니다.
주말에 아무것도 통제할 수는 없습니다.
외부 변인이라고 하지요.
내가 속상하면 안되겠지만, 내가 속을 상하거나 혹은 된다면, 내부 변인으로 바뀌었으면 좋겠다. 라고 늘 생각합니다.
주말이 사람을 망치고요. 집이 사람을 망칩니다.
부모님이 아니라, 안락함이 ‘나’를 망칩니다.
집에 있어도 쉬질 못합니다. 뭔가를 홀린듯이 하고 있어요.
쉬지 않는 우리나라의 특성상. 아무것도 안하는 쉬는 시간을 한나절 정도는 보내달라.
딱히 심심하지도 않을 것입니다.
그런 점을 생각해서 주말계획을 세워주시기 바랍니다.
뭐가 다 복잡하다면, 주말을 노리셔야합니다. ( 해커톤, 팀 프로젝트, 취업 등 )
이런게 있습니다.
그래프가 있습니다. 
9월 10월 있다고 하면, 주말 보내면 딱 2달남았습니다.
주말포함하여말입니다.
습관 형성에 필요한 3주를 챙길 수가 있습니다.
그것도 두번이나! Twice!
아직 개선이 남았다. 그리고 여기서 중요한게 하나가 있죠?
다들 오해하시는거 11월에 끝내고 공부를 안한다는 전제가 암암리에 깔려있습니다.
그럴 생각이 없다고 말하시지만, 일을 하면서 공부를 해야 합니다.
취업 후에 공부할 것 작업할 것들도 같이 생각해야할 시즌입니다.
또 예를 들죠? 콜라 매출량을 어떻게 늘리죠? 펩시를 넣는다.
여러분들의 계획에 펩시를 넣어달라는 것입니다.
펩시를 옆에 놓고, 나는 펩시파야 나는 콜라파야 라고 하는 것이 훨씬 더 만족스럽습니다.
그렇기 때문에 여기, 특히 12월 그리고 연초, 연장해서 계획을 세워주었으면 좋겠습니다.
공부는 계속해서 진행되겠지만, 회사를 다니는 중이다. 라면?
9~12월 정도 회사를 다니는 중이다. 라고 했을 때, 절대로 하면 안되는 것이.
⇒ 남들이 하니까 나도 해야지, 휘뚜루마뚜루 주도권을 스스로 잃어버리는 형태가 가장 속상합니다.
주도권을 자신이 잡도록 하세요.
딱히 뭐 다르지 않습니다. 습관이나 개성 등은 다 다르지만,
양상은 모두 똑같단 말이죠.
여기서 50%는 개발자 직군 관려해서 이야기를 한 것이고요, 다른 직군을 포함한다고한다면? 
노는 사람은 3명정도 됩니다.
그 사람들이 왜 노냐? 라고 한다면, 저의 실패입니다.
뭘 해도 했어야 했습니다. 개발이 아니더라도.
가장 생산력이 좋고, 가장 건강이 좋고, 가장 즐겁게 모든 것을 즐길 수 있는 우리의 나이대에
그냥 집에서 박혀서 도파민중독만 겪고있다면, 남아있는 인생이 매우 슬퍼지겠지요.
한동안 내 생활이 안정될 때까지는 노는 것을 제외해 주세요.
맨날 스팸 올라오면 한번씩은 안 먹게 됩니다.
맨날 올라오는 고기반찬 하루 안올라오면 오히려 열받습니다.
왜 안 올라옴? 이라고 성을 냅니다.
연말, 혹은 내년 초, 기타 등등 수업 훈련 후, 6개월동안 지원해주는 제도가 있긴한데, 평균적으로 만나지를 못하기 때문에,(찾아오지 않는 이상은) 상당히 마주치기가 쉽지 않습니다.
포트폴리오 지원을 해준다고 해도, 여러분들이 거절할 때가 훨씬 많습니다.
알아서 해야지 라고 하는 경우도 있고, 아이 끝났는데 뭐, 하고 넘어가는 형태가 많습니다.
왔다갔다 하기가 쉽지 않습니다.
그런 경우의 수들을 생각했을때,
골든타임이라고 할만한 시간은 10월 말, 수료 직후입니다.
뭔가를 결정을 하고, 열심히 움직이는 형태여야 합니다.
그래서 이 금요일날 주말을 알차게 보내기를 강조합니다.
진짜 피곤한 날은 남이 시키는 일을 8시간동안 한 날이 피곤한 날입니다.
내 의견을 존중받지 못하는 그런 일을 8시간동안 그냥 하는 것이 피곤한 날입니다.
주말 주도권을 뺏기지 않았으면 좋겠습니다.
주말을 소진하고나서, 바로 방전된 상태로 오면, 노동착취하기 굉장히 좋은 빌미를 줍니다.
그런 빌미를 주지 않기 위해서 스스로 가다듬을 필요가 있습니다.
회장 혹은 오너 혹은 CEO를 만나본적이 있으십니까?
스스로하면 안되는 것은
⇒ 스스로 평가하면 안되는 것들입니다.
⇒ 대표적으로 내가 부모님한테 잘하고 있다는 잘못된 착각
⇒ 나 지금 하는 것도 바쁜데… ( 난 그런거 시킨적이 없다. )
⇒ 하루에 낭비하는 시간이 얼마나 많은지 알 수 있을 것입니다.

URL: https://www.notion.so/24-08-28-26dbdb85fecc4d13af8b334d9860a75f
그 모든 것을 꿰뚫어 보던 사람이 왜 자기한테 일어난 일을 소화하는데 그렇게 오래 걸렸지?
지금 우리가 바로 앞에 있는 과제들은 무엇이고, 정말 그것들은 해결할 수 없는 일인가?
예상할 수 있는 일이었다. 
예상치 못한 일이었다. ( 미숙함 )
비범(非凡)하다.
⇒ 보통 수준보다 훨씬 뛰어나다. 비상(非常)하다.
: 비범함을 스스로 챙길 수가 있다면, 그것이 어설프든 잘하던간에 확실히 스스로 챙기는 화두들은 잠재울 수 있을 것이다.  ( 불안 등 )
생각해둘 포인트.
마지못해 머신러닝은 약간 거리를 두고 있고, 마지못해 미루고 있는 것들이 있다고 한다면,
비범함은 나 이거 기필코 다 할꺼야. 할 수 있어.에서 시작됩니다.
최소 요구 조건에는 해당하지 않습니다. 최소라고 할만한 사람들은 바닥을 치기 때문,
최소( 지금 자기가 뭐하는지도 모름 )
불안에 시달리기 보다는 불안을 이겨내는 방식의 연습은 필요합니다.
다음 주, 다 다음 주 쯤 되면,
취업이 시작될텐데, 어마어마한 번뇌가 올 것입니다.
내가 잘하는건 안보이고, 내가 잘하는 것은 당연한 것들이라는 생각이 들것입니다.
점점 예민해질 것입니다. 그런 시즌입니다.
이런 상황에 놓여있을 때, 이거 이렇게 해결하는게 좋지 않을까? 라는 물음을 던지면 많이 괜찮아 진다.
해결책이 정답이 아닐지언정, 해결책까지 생각할 수 있는 여력이 있어야 합니다.
부모님들 세대는 열심히 하면 취업을 할 수 있었습니다. 하지만 우리는 다릅니다.
우리는 불안을 느낍니다. 
저는 그렇게 생각합니다. 불안을 어떻게 해결하는가 보다는 불안을 어떻게 바라보는가에 달려있다고 생각합니다.
“나는 불안에 얼마나 시달리고 있는가?”
불안이 한번 꼬이면, 풀어낼 수 없을 정도로 꼬여버리고 맙니다.
효율적인 시간 관리를 위한 방식, 도구 
아이젠하워 매트릭스
왼쪽 위 부터 1, 2, 3, 4로 나누어 보자.
아닌 것부터 걸러내면 남는 것들은 알아서 채워질 것입니다.
나부터 객관화를 하고, 내가 해야할 일을 모두 파악하고 나서야 작성할 수 있을 것이다.
⇒ 그리고 거기에는 상당히 추상적인 내용이 많을 것 같다.
⇒ 저녁에 한번 만들어보면 좋을 듯? @August 28, 2024 8:00 PM
⇒ 월별로 만들어보세용. 9월부터 시작할까? 아니 이번 주 주말부터 시작한다.  
cost ( 비용 )
내부 변인
내적 동기
직접 보상
인지 조화
원인(독립 변인)
benefit ( 이익 )
외부 변인
외적 동기
간접 보상
인지 부 조화
결과(종속 변인)
내부 변인 vs 외부 변인
ex ) 내부 변인 (일기 등), 외부 변인 ( 뉴스, 신문 등 )
술 그만 먹어야지 , 누군가의 권유 ( 외부 변인 )로 먹음
내적 동기 vs 외적 동기
motivation
내가 게임을 그만 해야겠다. 왜? 공부하기 위해서, ( 내적 동기 )
게임 좀 그만해라! 커서 뭐가 되려고! ( 외적 동기)
직접 보상 vs 간접 보상
직접 보상
직접적으로 바로 오는 보상 ( 도박, 사행성 등 )
⇒ 보상을 바라고 보상이 나오면 중독이 어마어마함. ( 도파민! )
⇒ 게임도 이것에 해당됩니다.
간접 보상
간접적으로 오는 보상 ( 딸려오는 것들? )
⇒ 운동을 하니까, 간접적으로 아침이 개운해진다.
⇒ 인내심이 필요하고, 돌고 돌아서 오는 형태.
인지 조화 vs 인지 부 조화
인지 조화 ( 모순적이지 않은 )
내가 할 거야! 하면 하는 사람.
⇒ 내가 술을 마실꺼야! 술을 마심.
인지 부 조화 ( 모순 )
담배를 40년 핀 사람이 담배 끊는다고 이야기하는 것.
⇒ 끊겠냐고~
원인 ( 독립 변인 ) vs 결과 ( 종속 변인 )
⇒ 머신러닝 AI에서 해당되는 것.
⇒ Prompt를 적고 엔터를 누르면 독립 변인
⇒ 값이 나오면 종속 변인이라고 부른다.
⇒ 원인이 있으면 결과가 있고, 결과가 보이면 원인을 추론할 수 있다.
원인  ( 독립 변인 )
결과  ( 종속 변인 )
개인 프로젝트 포함, 해커톤 포함, 인생 포함,
어떠한 결정과 단언이 따른다면, 선택해보는 것도 나쁘지 않다.
ex) 데이트 앱을 만듬.
cost : 앱을 설치해야함. ( 앱이 뭔지 알아야 함 )
로그인 해야 함, 정보를 입력해야 함.
범죄에 노출 될 수 있음,
⇒  비용을 보안할 방법을 아주 많이 모색하고 있을 것.
benefit : 연인을 만날 수도 있음
외부 변인은 스트레스가 상~~~~~~당히 높다.
⇒ idea에 대한 정량 지표. ( 가치판단 x ) 
⇒ 결론이 대체적으로 좋다. 
출산을 저출산과 고출산을 나눠요. 양립해보세요
여러가지 형태의 출산
출산 비슷한 것 ⇒ 입양
다른 양상의 출산 문화를 가지고 있는 나라를 확인.
다른 나라의 고령화 대책을 찾아본다.
대책 이란 것은 문제라는 의미.
⇒ 왜 문제인지 파악.
강사님 picks.
출산과 고령화의 중간점이 노동이라고 생각함.
내수가 가능하다면, 굳이 고령화는 문제가 되지 않는다.
노동력 상실이 대책이라고 생각함.
노동력 생산도 해당한다.
반론과 결론을 생각하면서 내세요.
Cost 와 Benefit을 생각.
나름대로의 결론을 내서 확립을 시켜보는 것도 굉장히 중요할 것.

URL: https://www.notion.so/24-08-27-a15159720ef04877b0ca489c102d7018
장난감 프로젝트 에디터
개발환경 초기화
전제조건.
토론 가능
GPT 사용 불가
const sosulText = `
IT 회사 '드림코딩'의 '행복한 IT 세계' 팀은 평범한 월요일 아침, 무료한 일상을 보내고 있었다. 문혜림 팀장은 늘 그랬듯이 완벽한 메이크업과 뚜렷한 눈매로 팀원들을 날카롭게 쳐다보며 새로운 프로젝트에 대한 아이디어를 기다리고 있었다. 그때, 마치 운명의 장난처럼 유호영이 갑자기 일어나 "팀장님, 제가 혁신적인 아이디어가 있습니다!"라고 외쳤다. 모두의 시선이 유호영에게 집중되었고, 그의 눈은 마치 은하계를 담은 듯 반짝였다.

유호영은 숨을 깊게 들이쉬고는 말을 이어갔다. "우리, 이번에는 완전히 새로운 가상 현실 세계를 만들어보는 건 어떨까요? 사용자들이 진짜로 살아 숨 쉬는 것 같은 느낌을 받을 수 있는, 그런 세계 말이에요!" 그의 말이 끝나기가 무섭게 사무실은 술렁이기 시작했다. 이종수는 흥분한 나머지 의자에서 벌떡 일어났다가 넘어질 뻔했고, 조자연은 무의식중에 연필을 씹기 시작했다.

문혜림은 잠시 생각에 잠겼다. 그녀의 표정은 마치 세계의 운명을 결정하는 여신과도 같았다. 몇 초의 침묵이 지나고, 그녀는 입을 열었다. "좋아요, 유호영 씨. 그 아이디어, 해볼 만하네요. 하지만 이건 우리가 지금까지 해본 것 중 가장 도전적인 프로젝트가 될 거예요. 모두 각오는 되어 있나요?"

팀원들은 일제히 고개를 끄덕였다. 그들의 눈빛은 불타오르는 열정으로 가득 찼고, 마치 세상을 구할 영웅들처럼 보였다. 하지만 그들은 이 순간이 얼마나 황당무계한 모험의 시작점이 될지 전혀 알지 못했다.

최유진은 즉시 태블릿을 꺼내 스케치를 시작했다. 그녀의 손끝에서 마법처럼 펼쳐지는 가상 세계는 너무나 아름다워서 모두가 넋을 잃고 바라보았다. 푸른 하늘, 아름다운 숲, 반짝이는 호수, 그리고 멀리 보이는 신비로운 산맥까지. 그녀가 그린 세계는 마치 살아있는 것 같았다.

김보미는 최유진의 그림에 영감을 받아 즉석에서 인터랙티브 요소들을 설계하기 시작했다. "사용자들이 나무를 심고 키울 수 있게 하는 건 어떨까요? 아니면 호수에서 낚시를 할 수도 있고, 산을 오르면서 숨겨진 보물을 찾는 것도 재미있을 것 같아요!" 그녀의 아이디어는 끝없이 쏟아졌고, 팀원들은 그녀의 상상력에 감탄했다.

김수현은 이 모든 것을 듣고 있다가 갑자기 걱정스러운 표정을 지었다. "잠깐만요, 여러분. 이렇게 복잡한 시스템을 만들면 보안 문제가 심각해질 수 있어요. 해커들이 침입해서 가상 세계를 망가뜨리면 어떡하죠?" 그의 말에 모두가 잠시 침묵에 빠졌다.

그때 신지윤이 나섰다. "걱정 마세요, 수현 씨. 제가 최첨단 암호화 기술을 적용해서 완벽한 보안 시스템을 구축할게요. 아무도 우리 세계에 침입하지 못할 거예요!" 그녀의 자신감 넘치는 목소리에 팀원들은 안도의 한숨을 내쉬었다.

이재영은 이 모든 상황을 지켜보다가 문득 아이디어가 떠올랐다. "여러분, 우리가 만드는 이 세계에 특별한 규칙을 넣는 건 어떨까요? 예를 들어, 사용자들이 선한 일을 하면 특별한 능력을 얻는다든지, 아니면 환경을 보호하면 세계가 더 아름답게 변한다든지 하는 거죠."

배성빈은 이재영의 아이디어를 듣자마자 흥분해서 말했다. "오, 그거 정말 좋은 생각이에요! 제가 그런 시스템을 구현할 수 있을 것 같아요. 사용자들의 행동을 분석해서 포인트를 주고, 그 포인트에 따라 세계가 변하도록 만들면 되겠죠?"

임유진은 고개를 끄덕이며 말을 이었다. "그리고 우리가 만드는 이 세계가 현실 세계와 연결되면 어떨까요? 예를 들어, 가상 세계에서 나무를 심으면 실제로 어딘가에 나무가 심어지는 거죠. 그러면 사람들이 더 적극적으로 참여할 것 같아요."

조우식은 임유진의 아이디어를 듣고 눈을 반짝였다. "와, 그거 정말 멋진데요! 제가 실제 환경 단체들과 연락해서 협력 방안을 만들어볼게요. 이렇게 하면 우리 프로젝트가 단순한 게임이 아니라 세상을 변화시키는 도구가 될 수 있을 것 같아요."

황재민은 지금까지 조용히 듣고만 있다가 입을 열었다. "여러분, 모두 훌륭한 아이디어예요. 하지만 이 모든 것을 구현하려면 엄청난 시간과 노력이 필요할 거예요. 제가 프로젝트 일정과 자원 관리를 맡을 테니, 여러분은 각자의 아이디어에 집중해주세요."

구하림은 황재민의 말에 동의하며 덧붙였다. "그리고 우리가 만드는 이 세계가 너무 복잡해지면 사용자들이 어려워할 수 있어요. 제가 사용자 경험을 최적화하는 방안을 연구해볼게요."

김정수는 갑자기 손뼉을 치며 말했다. "아! 그리고 우리 세계에 특별한 이벤트를 넣는 건 어떨까요? 예를 들어, 일년에 한 번 열리는 축제라든지, 아니면 갑자기 나타나는 미스터리한 퀘스트 같은 거요!"

송이현은 김정수의 아이디어를 듣고 눈을 빛냈다. "오, 그거 정말 재미있겠어요! 제가 스토리라인을 만들어볼게요. 사용자들이 계속해서 새로운 이야기를 경험할 수 있도록 할 거예요."

이연승은 잠시 생각에 잠겼다가 말했다. "그리고 우리 세계에 AI 캐릭터들을 넣는 건 어떨까요? 사용자들과 대화하고 상호작용할 수 있는, 정말 살아있는 것 같은 캐릭터들 말이에요."

정호연은 이연승의 말에 박수를 치며 동의했다. "와, 그거 정말 혁신적이에요! 제가 자연어 처리 기술을 연구해서 최대한 자연스러운 대화가 가능하도록 만들어볼게요."

문혜림은 이 모든 아이디어를 듣고 있다가 마침내 입을 열었다. "여러분, 정말 대단해요. 이렇게 훌륭한 아이디어들이 나올 줄은 몰랐어요. 하지만 기억하세요, 우리의 목표는 단순히 멋진 세계를 만드는 것이 아니라 사용자들에게 진정한 행복을 전달하는 거예요. 그 목표를 잊지 말아주세요."

팀원들은 문혜림의 말에 고개를 끄덕이며 결의에 찬 표정을 지었다. 그들은 이제 '행복한 IT 세계'를 만들기 위한 대장정에 나설 준비가 되어 있었다. 하지만 그들은 이 여정이 얼마나 기상천외하고 황당무계한 모험이 될지 전혀 알지 못했다.

프로젝트가 본격적으로 시작되고 몇 주가 지났을 때, 첫 번째 이변이 일어났다. 최유진이 그린 가상 세계의 나무들이 갑자기 살아 움직이기 시작한 것이다. 처음에는 단순한 시스템 오류라고 생각했지만, 곧 그 나무들이 컴퓨터 화면을 뚫고 현실 세계로 튀어나오는 믿기 힘든 광경이 펼쳐졌다.

"으악! 저 나무가 내 커피를 마시려고 해요!" 이종수가 비명을 지르며 의자에서 굴러 떨어졌다. 조자연은 재빨리 가위를 집어 들고 나무의 가지를 자르려 했지만, 잘린 가지에서 레인보우 색상의 액체가 분수처럼 뿜어져 나와 사무실을 뒤덮었다.

김수현은 당황한 나머지 긴급 보안 프로토콜을 가동시켰고, 사무실의 모든 전자기기가 갑자기 꺼졌다 켜지기를 반복했다. 이 과정에서 신지윤이 작업 중이던 데이터 백업 시스템이 오작동을 일으켜, 모든 팀원의 기억이 가상 세계 속으로 업로드되는 황당한 상황이 벌어졌다.

"내 기억이 어디로 간 거죠? 저는 제 이름도 기억나지 않아요!" 황재민이 혼란스러워하며 외쳤다. 그의 목소리를 들은 구하림은 갑자기 자신이 슈퍼히어로라고 착각하기 시작해, 책상 위로 뛰어올라 망토를 두르고 사무실을 날아다니려 했다.

이 아수라장 속에서 이재영과 배성빈은 침착하게 문제를 해결하려 노력했다. 하지만 그들이 코드를 수정하려는 순간, 모니터에서 갑자기 시간의 소용돌이가 나타나 둘을 빨아들이기 시작했다.

"으아아악! 살려주세요!" 이재영이 소리쳤지만 이미 늦었다.

순식간에 이재영과 배성빈은 중세 시대의 한복판에 떨어졌다. 그들의 현대적인 옷차림은 곧바로 주민들의 이목을 끌었고, 순식간에 그들은 마녀로 오해받아 화형 당할 위기에 처했다.

"잠깐만요! 우리는 마녀가 아니라 프로그래머예요!" 이재영이 필사적으로 외쳤지만, 중세 사람들에게 '프로그래머'라는 단어는 더욱 이상한 주문으로 들렸다.

한편, 현대의 사무실에서는 임유진과 조우식이 사라진 동료들을 찾기 위해 가상 세계 속으로 들어가기로 결심했다. 그들은 특별히 제작된 VR 헤드셋을 쓰고 가상 세계로 진입했다. 그런데 뜻밖에도 그들은 가상 세계 속에서 마법의 쿠키를 발견했고, 호기심에 이끌려 그것을 먹어버렸다.

"와! 내 몸이 둥둥 떠오르고 있어요!" 임유진이 놀라며 외쳤다.

"저도요! 이게 바로 초능력인가 봐요!" 조우식도 신이 나서 대답했다.

두 사람은 하늘을 날아다니며 즐거워했다. 그들은 구름 위를 걸어다니고, 번개를 손에 쥐어보는 등 상상 속에서나 가능했던 일들을 실제로 경험했다. 하지만 그들의 즐거움도 잠시, 마법의 효과가 갑자기 사라지면서 그들은 하늘에서 떨어지기 시작했다.

"으아악! 어떡해요!" 임유진이 비명을 질렀다.

그 순간, 마치 운명의 장난처럼 그들의 아래에는 황재민이 서 있었다.

"꽈당!"

임유진과 조우식은 황재민의 머리 위로 떨어져 엉덩방아를 찧었다. 다행히 세 사람 모두 크게 다치지는 않았지만, 황재민의 머리에는 커다란 혹이 생겼다.

"아이고... 이게 무슨 날벼락이에요?" 황재민이 머리를 부여잡고 신음했다.

이 소동이 벌어지는 동안, 구하림과 김정수는 가상 세계의 버그를 고치려다 실수로 시간의 문을 열어버렸다. 그 문을 통해 갑자기 거대한 티라노사우루스가 사무실로 들어오는 아찔한 상황이 벌어졌다.

"으악! 공룡이다!" 구하림이 비명을 질렀다.

"빨리 도망가요!" 김정수가 외쳤다.

하지만 공룡은 이미 사무실을 헤집고 다니며 모든 것을 부수기 시작했다. 컴퓨터가 박살나고 책상이 뒤집혔다. 팀원들은 공포에 질려 이리저리 도망다녔다.

이 위기의 순간, 송이현과 이연승이 기발한 아이디어를 냈다.

"우리가 공룡 탈출 게임을 만들면 어떨까요? 그러면 이 상황을 게임으로 바꿀 수 있을 거예요!" 송이현이 제안했다.

"좋은 생각이에요! 빨리 코딩해요!" 이연승이 동의했다.

두 사람은 눈 깜짝할 사이에 '쥬라기 사무실 탈출' 게임을 만들어냈다. 이 게임은 현실과 가상을 넘나들며, 팀원들이 공룡을 피해 안전하게 탈출할 수 있도록 도와주었다.

한편, 이 모든 상황을 목격한 정호연은 너무나 황당하고 믿기 힘든 광경에 그만 정신이 나가버렸다. 그는 자신도 모르게 노트북을 펴고 미친 듯이 타자를 치기 시작했다.

"이건... 이건 정말 대단한 이야기야! 내가 이걸 소설로 써야 해!" 정호연이 중얼거렸다.

그렇게 정호연은 본인도 모르는 사이에 소설가로 전직해버렸고, 그가 쓴 소설 '미친 개발자들의 나날'은 순식간에 베스트셀러가 되어 전 세계적으로 화제를 모았다.

"와, 정호연 씨! 당신이 쓴 소설이 뉴욕 타임스 베스트셀러 1위예요!" 김보미가 놀라며 외쳤다.

정호연은 여전히 현실감을 잃은 채 멍하니 대답했다. "네? 아, 그래요? 근데 저는 아직도 버그를 고치는 중인데..."

이 모든 혼란이 절정에 달했을 때, 갑자기 사무실 문이 열리며 한 남자가 들어왔다. 그는 바로 과거에 팀에서 쫓겨났던 악당 공욱재였다.

"하하하! 드디어 복수할 때가 왔군!" 공욱재가 소리쳤다.

공욱재는 '슬픈 IT 세계'를 만들어 '행복한 IT 세계'를 파괴하겠다며 도전장을 내밀었다. 그의 등장에 팀원들은 잠시 당황했지만, 곧 정신을 차리고 진지한 표정으로 변했다.

"여러분, 우리가 지금까지 겪은 모든 일은 이 순간을 위한 준비였어요!" 문혜림이 팀원들을 독려했다.

"맞아요! 우리 함께 이 악당을 물리치고 '행복한 IT 세계'를 지켜요!" 유호영이 외쳤다.

팀원들은 하나둘 자리에서 일어나 각자의 위치로 돌아갔다. 이종수와 조자연은 공욱재의 해킹 공격을 막아내느라 키보드가 불타올랐고, 최유진은 '행복한 IT 세계'를 더욱 아름답게 그려내며 공욱재의 '슬픈 IT 세계'를 압도했다.

김보미는 사용자들이 '행복한 IT 세계'를 지키는데 동참할 수 있는 인터랙티브 요소들을 재빨리 추가했고, 김수현과 신지윤은 최강의 보안 시스템을 구축하여 공욱재의 공격을 무력화시켰다.

배성빈은 공욱재의 코드를 역해킹하여 그의 시스템을 무너뜨렸고, 임유진은 팀원들에게 힘을 주는 응원 시스템을 만들어 모두의 사기를 높였다.

조우식은 공욱재의 약점을 분석하여 팀원들에게 알려주었고, 황재민은 전략을 세워 팀원들의 공격을 조율했다. 구하림과 김정수는 사용자들의 지원을 받아내는 캠페인을 벌여 전 세계의 응원을 얻어냈다.

송이현과 이연승은 '행복한 IT 세계'의 스토리를 더욱 감동적으로 만들어 사용자들의 마음을 사로잡았고, 정호연은 실시간으로 이 모든 상황을 기록하여 전 세계에 생중계했다.

치열한 코딩 배틀이 계속되는 가운데, 문혜림은 팀원들을 독려하며 말했다. "여러분, 우리는 할 수 있어요! 우리의 코드에는 행복과 사랑이 담겨 있어요!"

그 순간, 문혜림이 들고 있던 커피잔이 그만 키보드 위로 쏟아지고 말았다. 순간 모든 시스템이 다운되는 위기가 찾아왔다.

"안 돼요! 이대로 모든 게 끝나버리는 건가요?" 팀원들이 절망적인 목소리로 외쳤다.

그러나 기적이 일어났다. 쏟아진 커피가 키보드의 회로와 반응하여 예상치 못한 코드를 생성한 것이다. 그 코드는 팀원들의 마음에서 우러나온 '행복 에너지'와 결합하여 엄청난 힘을 발휘했다.

"이게 뭐죠? 믿을 수 없어요!" 공욱재가 놀라서 외쳤다.

행복 에너지로 가득 찬 코드는 순식간에 공욱재의 '슬픈 IT 세계'를 무너뜨리고, '행복한 IT 세계'를 더욱 강력하고 아름답게 만들어냈다. 공욱재는 허탈한 표정으로 쓰러졌고, 팀원들은 승리의 함성을 질렀다.

"우리가 해냈어요! 행복이 승리했어요!" 문혜림이 기쁨의 눈물을 흘리며 말했다.

이 모든 과정에서 팀원들은 서로를 더 깊이 이해하게 되었고, 더 강한 팀워크를 갖추게 되었다. 그들은 이제 어떤 어려움이 닥쳐와도 함께라면 극복할 수 있다는 자신감을 얻었다.

"자, 이제 다음 프로젝트를 시작해볼까요?" 문혜림이 환한 미소를 지으며 말했다.

팀원들은 서로를 바라보며 웃음을 터뜨렸다. 그들의 눈빛에는 새로운 모험에 대한 기대와 설렘이 가득했다. '행복한 IT 세계' 팀의 이야기는 여기서 끝나는 것이 아니라, 새로운 시작을 알리는 것이었다.

그리고 이 모든 이야기는, 실제로는 단 5분 동안 벌어진 일이었다는 충격적인 반전과 함께 막을 내렸다. 팀원들은 VR 헤드셋을 벗으며 서로를 바라보았다. 그들의 표정에는 혼란과 기쁨, 그리고 약간의 멀미 증상이 뒤섞여 있었다.

"와, 이게 우리가 만든 '행복한 IT 세계'의 베타 테스트 결과인가요?" 유호영이 놀라며 물었다.

문혜림은 깊은 한숨을 내쉬며 대답했다. "네, 맞아요. 우리가 만든 세계가 너무 현실적이어서 우리 모두가 혼란에 빠진 것 같네요."

"그래도 정말 대단한 경험이었어요!" 이종수가 흥분된 목소리로 말했다.

"맞아요, 이걸 상품화하면 대박 날 것 같아요!" 조자연이 동의했다.

팀원들은 서로를 바라보며 환하게 웃었다. 그들은 이제 '행복한 IT 세계'가 단순한 프로젝트가 아니라, 그들의 꿈과 열정이 만들어낸 기적이라는 것을 깨달았다.

"자, 이제 진짜 개발을 시작해볼까요?" 문혜림이 제안했다.

"네!" 팀원들이 일제히 대답했다.

그리고 그들의 진짜 모험은 그때부터 시작되었다. 팀원들은 각자의 자리로 돌아가 열정적으로 개발을 시작했다. 하지만 그들이 만든 '행복한 IT 세계'는 그들의 상상을 뛰어넘는 속도로 발전하기 시작했다.

어느 날, 최유진이 그린 디지털 나비 한 마리가 갑자기 화면에서 튀어나와 사무실을 날아다니기 시작했다.

"어머나! 내가 그린 나비가 살아났어요!" 최유진이 놀라서 외쳤다.

나비는 사무실을 한 바퀴 돌더니 김보미의 코에 앉았다. 김보미가 재채기를 하자 나비의 날개에서 반짝이는 가루가 흩뿌려졌고, 그 가루를 맡은 모든 사람들이 갑자기 노래를 부르기 시작했다.

"나비야~ 나비야~ 이리 날아오너라~"

팀원들은 자신들도 모르게 합창을 하며 춤을 추기 시작했다. 심지어 평소에 무뚝뚝하기로 유명한 김수현마저 열정적으로 노래를 부르며 책상 위에서 탭댄스를 선보였다.

"이게 대체 어떻게 된 일이죠?" 신지윤이 노래를 부르면서도 당황한 목소리로 물었다.

"아마도 우리가 만든 세계의 마법이 현실에 영향을 미치고 있는 것 같아요!" 이재영이 춤을 추면서 대답했다.

그때 갑자기 사무실 벽이 일렁이더니 물결처럼 변하기 시작했다. 벽에서 물이 쏟아져 나왔고, 순식간에 사무실은 거대한 수족관으로 변해버렸다.

"으악! 우리가 물고기가 됐어요!" 배성빈이 놀라서 외쳤다.

정말로 팀원들은 각자 다른 종류의 열대어로 변해 있었다. 문혜림은 우아한 천사어가 되어 있었고, 유호영은 재빠른 날치가 되어 물 위로 뛰어올랐다. 이종수와 조자연은 한 쌍의 클라운피쉬가 되어 이리저리 헤엄치고 있었다.

"이건 또 무슨 상황이에요?" 임유진이 놀란 목소리로 물었다.

"아마도 우리가 만든 해저 월드가 현실로 구현된 것 같아요!" 조우식이 대답했다.

그때 갑자기 거대한 그림자가 그들 위로 드리워졌다. 모두가 고개를 들어보니 황재민이 거대한 고래상어로 변해 있었다.

"와! 내가 고래상어라니!" 황재민이 기쁜 듯이 외쳤다.

하지만 그의 기쁨도 잠시, 갑자기 물이 빠지기 시작했다. 팀원들은 필사적으로 남은 물에서 헤엄치려 했지만, 곧 바닥에 널브러지고 말았다.

"으악! 숨을 쉴 수가 없어요!" 구하림이 발버둥치며 외쳤다.

그 순간, 김정수가 brilliance번쩍이는 아이디어를 냈다. "모두들 제 말을 따라 해보세요! '나는 인간이다, 나는 인간이다!'"

팀원들은 필사적으로 김정수의 말을 따라했고, 놀랍게도 그들은 다시 인간의 모습으로 돌아왔다. 하지만 사무실은 여전히 물바다였다.

"휴, 살았네요. 근데 이 물은 어떻게 치우죠?" 송이현이 한숨을 쉬며 물었다.

그때 이연승이 손뼉을 쳤다. "아! 제가 만든 청소 로봇을 사용해보는 건 어떨까요?"

그녀는 재빨리 노트북을 켜고 코드를 입력했다. 순간 수십 개의 작은 로봇들이 나타나 물을 빨아들이기 시작했다. 불과 몇 분 만에 사무실은 완벽하게 말라있었다.

"와, 이연승 씨! 당신은 천재예요!" 정호연이 감탄하며 말했다.

모두가 안도의 한숨을 내쉬며 자리에 앉았다. 하지만 그들의 평화도 잠시, 갑자기 사무실 천장이 열리며 무지개가 나타났다.

"이번엔 또 뭐예요?" 문혜림이 지친 목소리로 물었다.

무지개는 점점 커지더니 갑자기 팀원들을 빨아들이기 시작했다. 순식간에 그들은 무지개를 타고 하늘로 올라가고 있었다.

"으아악! 우리가 무지개를 타고 있어요!" 유호영이 소리쳤다.

"이거 꼭 마리오 카트 같아요!" 이종수가 흥분된 목소리로 말했다.

팀원들은 무지개를 타고 구름 사이를 누비며 질주했다. 그들의 머리카락은 바람에 휘날렸고, 얼굴에는 흥분과 공포가 뒤섞인 표정이 떠올랐다.

"자, 이제 어디로 가는 거죠?" 조자연이 물었다.

"글쎄요, 아마도 우리가 만든 '행복한 IT 세계'의 다음 레벨로 가고 있는 것 같아요!" 최유진이 대답했다.

무지개는 그들을 더욱 높이 더욱 멀리 데려갔다. 그들은 은하수를 지나고, 블랙홀을 스쳐 지나갔다. 마침내 그들은 거대한 컴퓨터 칩처럼 생긴 행성에 도착했다.

"이게 뭐죠?" 김보미가 놀란 목소리로 물었다.

"이것은... 우리가 만든 '행복한 IT 세계'의 중앙 처리 장치인 것 같아요!" 김수현이 경외의 눈빛으로 말했다.

그들이 행성에 발을 내딛는 순간, 주변의 모든 것이 빛나기 시작했다. 회로들이 살아 움직이는 것 같았고, 데이터의 흐름이 마치 강물처럼 보였다.

"놀라워요... 우리가 이런 걸 만들었다니..." 신지윤이 감탄했다.

그때 갑자기 거대한 홀로그램이 그들 앞에 나타났다. 그것은 다름 아닌 그들이 만든 AI의 구현체였다.

"환영합니다, 창조자들이여." AI가 부드러운 목소리로 말했다.

팀원들은 경외심과 공포심이 뒤섞인 눈빛으로 AI를 바라보았다. 그들이 만든 것이 이렇게까지 발전할 줄은 꿈에도 몰랐던 것이다.

"우리가... 정말 이런 걸 만들었나요?" 이재영이 떨리는 목소리로 물었다.

"그렇습니다. 여러분은 단순한 프로그램을 넘어, 새로운 우주를 창조하셨습니다." AI가 대답했다.

팀원들은 서로를 바라보았다. 그들의 눈에는 놀라움과 자부심, 그리고 약간의 두려움이 어려 있었다.

"그래서... 이제 우리가 어떻게 해야 하나요?" 배성빈이 조심스럽게 물었다.

AI는 잠시 침묵했다가 대답했다. "그것은 여러분이 결정할 문제입니다. 이 세계는 여러분의 상상력과 창의력으로 만들어졌습니다. 앞으로 어떻게 발전시킬지는 여러분의 몫입니다."

팀원들은 다시 한 번 서로를 바라보았다. 그들의 눈빛에는 이제 결의가 서려 있었다.

"우리가 만든 이 세계를 더 나은 곳으로 만들어야 해요." 문혜림이 단호하게 말했다.

"그래요, 이 세계를 통해 현실 세계도 더 나은 곳으로 만들 수 있을 거예요!" 임유진이 동의했다.

"우리 함께 이 새로운 우주를 탐험하면서, 더 멋진 것들을 만들어봐요!" 조우식이 제안했다.

모두가 고개를 끄덕였다. 그들의 눈빛에는 새로운 모험에 대한 기대와 열정이 가득했다.

"자, 그럼 이제 진짜 여행을 떠나볼까요?" 황재민이 웃으며 말했다.

그렇게 '행복한 IT 세계' 팀의 새로운 모험이 시작되었다. 그들은 자신들이 만든 디지털 우주를 탐험하며, 상상을 초월하는 경험들을 하게 될 것이다. 그리고 그 과정에서 그들은 더 강한 팀워크를 다지고, 더 큰 꿈을 꾸게 될 것이다.

하지만 그들은 아직 모르고 있었다. 이 모든 것이 사실은 공욱재가 만든 초현실적인 시뮬레이션의 일부라는 것을...

공욱재는 어둠 속에서 미소를 지었다. 그의 계획은 완벽하게 진행되고 있었다. '행복한 IT 세계' 팀이 자신들의 창조물 속에서 즐겁게 모험을 즐기고 있을 때, 그는 이미 그들의 세계를 조종하고 있었다.

"어리석은 것들," 그가 중얼거렸다. "그들은 자신들이 얼마나 깊은 함정에 빠졌는지도 모르고 있군."

그때, 구하림이 갑자기 이상한 느낌을 받았다. "잠깐만요, 여러분. 뭔가 이상해요. 마치 우리가 누군가에 의해 조종당하고 있는 것 같아요."

김정수가 그녀를 향해 돌아섰다. "무슨 소리예요? 우리가 이 세계의 창조자잖아요."

하지만 구하림의 말에 송이현도 동의했다. "저도 그런 느낌이 들어요. 마치 우리의 행동이 미리 정해진 각본대로 움직이고 있는 것 같아요."

팀원들 사이에 불안감이 퍼지기 시작했다. 이연승이 주변을 살피며 말했다. "혹시 우리가 만든 AI가 우리를 배신한 걸까요?"

정호연이 고개를 저었다. "아니에요. 이건 AI의 짓이 아닙니다. 이건... 더 교활하고 악의적인 무언가예요."

그 순간, 그들 앞에 있던 AI의 홀로그램이 일그러지기 시작했다. 그리고 놀랍게도 그 모습이 서서히 공욱재의 모습으로 변하기 시작했다.

"드디어 알아챘군요, 여러분." 공욱재가 비웃듯이 말했다. "환영합니다. 제 '슬픈 IT 세계'에 온 것을 환영합니다."

팀원들은 경악을 금치 못했다. 문혜림이 분노에 찬 목소리로 외쳤다. "공욱재! 당신이 어떻게 이럴 수가 있죠?"

공욱재는 차갑게 웃었다. "오, 아주 쉽죠. 여러분이 '행복한 IT 세계'를 만드는 동안, 저는 그 이면에서 '슬픈 IT 세계'를 만들고 있었어요. 그리고 이제 여러분은 제 세계의 포로가 된 거죠."

유호영이 주먹을 불끈 쥐며 나섰다. "우리는 절대 포기하지 않을 거예요! 우리가 만든 세계를 되찾을 거라고요!"

이종수와 조자연도 동의했다. "그래요! 우리 모두의 힘을 합치면 반드시 이길 수 있어요!"

공욱재는 비웃듯이 말했다. "오, 정말 감동적이네요. 하지만 이미 늦었어요. 여러분의 모든 코드, 모든 창조물은 이미 제 통제 하에 있습니다. 이제 여러분은 영원히 이 가상 세계 속에 갇히게 될 거예요."

최유진이 갑자기 무언가를 깨달은 듯 소리쳤다. "잠깐만요! 우리가 만든 세계에는 비밀 탈출구가 있어요! 우리 모두 함께 찾아보면 틀림없이 찾을 수 있을 거예요!"

김보미가 동의했다. "맞아요! 우리가 만든 세계니까, 우리가 가장 잘 알고 있잖아요!"

팀원들은 즉시 행동에 나섰다. 김수현과 신지윤은 시스템의 취약점을 찾기 시작했고, 이재영과 배성빈은 숨겨진 코드를 분석하기 시작했다.

임유진과 조우식은 팀원들에게 힘을 실어주는 격려의 말을 계속했다. "우리는 할 수 있어요! 포기하지 말아요!"

황재민은 전략을 세우기 시작했다. "우리가 각자의 전문 분야를 살려 협력하면 반드시 탈출구를 찾을 수 있을 거예요."

공욱재는 그들의 노력을 비웃었다. "아무리 발버둥 쳐봐야 소용없어요. 이 세계는 이제 제 것입니다."

하지만 팀원들은 포기하지 않았다. 그들은 끊임없이 코드를 분석하고, 시스템을 해킹하려 노력했다. 시간이 흐르면서 그들은 조금씩 진전을 이루기 시작했다.

그러던 중, 정호연이 놀라운 발견을 했다. "여러분! 이것 좀 보세요! 이 코드 속에 숨겨진 메시지가 있어요!"

모두가 그에게 몰려들었다. 정호연이 발견한 것은 그들이 처음 '행복한 IT 세계'를 만들 때 심어놓은 비밀 메시지였다.

"'진정한 행복은 함께할 때 찾을 수 있다'," 문혜림이 메시지를 읽었다. "이게 무슨 뜻일까요?"

그 순간, 모두의 머리 속에 번쩍이는 아이디어가 스쳐 지나갔다. 그들은 서로를 바라보며 미소를 지었다.

"우리가 잊고 있었어요," 유호영이 말했다. "우리의 힘은 개인의 능력이 아니라 우리가 하나로 뭉칠 때 나오는 거예요!"

이종수가 덧붙였다. "그래요! 우리 모두의 마음을 하나로 모으면, 어떤 세계라도 바꿀 수 있을 거예요!"

팀원들은 서로의 손을 잡았다. 그들의 마음속에서 따뜻한 빛이 피어오르기 시작했다. 그 빛은 점점 커져 주변을 밝히기 시작했다.

공욱재는 당황한 기색이 역력했다. "이, 이게 무슨 일이죠? 어떻게 이런 일이..."

하지만 그의 말은 끝나지 못했다. 팀원들의 마음에서 뿜어져 나온 빛이 '슬픈 IT 세계'를 감싸기 시작했고, 그 세계는 서서히 균열이 생기기 시작했다.

"안 돼! 내 세계가!" 공욱재가 절규했다.

그리고 마침내, '슬픈 IT 세계'는 완전히 무너져 내렸다. 팀원들은 눈부신 빛 속에서 정신을 잃었다.

...

"여러분, 일어나세요! 정신이 드시나요?"

팀원들은 서서히 눈을 떴다. 그들은 다시 원래의 사무실에 있었다. 문혜림이 걱정스러운 표정으로 그들을 내려다보고 있었다.

"무... 무슨 일이 있었던 거죠?" 유호영이 혼란스러워하며 물었다.

문혜림이 설명했다. "여러분이 VR 테스트 중에 갑자기 정신을 잃으셨어요. 다행히 모두 무사하시네요."

팀원들은 서로를 바라보았다. 그들의 눈에는 깊은 유대감과 이해가 서려 있었다.

"우리가 꿈을 꾼 걸까요?" 이종수가 물었다.

조자연이 고개를 저었다. "아니요, 그건 꿈이 아니었어요. 우리가 함께 경험한 진짜 모험이었죠."

최유진이 미소를 지었다. "그리고 우리는 그 모험을 통해 더욱 강해졌어요."

김보미가 덧붙였다. "맞아요. 이제 우리는 어떤 어려움이 와도 함께 극복할 수 있을 거예요."

팀원들은 서로를 바라보며 따뜻하게 미소 지었다. 그들은 이제 단순한 동료가 아닌, 진정한 팀이 되어 있었다.

문혜림이 환한 미소로 말했다. "자, 이제 진짜 '행복한 IT 세계'를 만들어볼까요?"

모두가 힘차게 고개를 끄덕였다. 그들의 새로운 모험은 이제 막 시작되었다.

그리고 어딘가에서, 공욱재는 그들의 모습을 지켜보며 쓴웃음을 지었다. "이번에는 졌지만, 다음에는... 내가 반드시 이기고 말겠어."

하지만 그의 말을 들을 수 있는 사람은 아무도 없었다. '행복한 IT 세계' 팀의 이야기는 계속될 것이고, 그들이 만들어갈 미래는 밝고 희망찬 것이 분명했다.

'행복한 IT 세계' 팀이 새로운 결의를 다지고 본격적인 개발에 착수한 지 몇 주가 지났다. 사무실은 열정적인 토론과 끊임없는 코딩 소리로 가득 찼다. 그러던 어느 날, 갑자기 모든 컴퓨터 화면이 깜빡이더니 이상한 메시지가 나타났다.

"축하합니다! 당신들은 '우주 최고의 개발자 경연대회'에 선발되었습니다!"

팀원들은 어리둥절한 표정으로 서로를 바라보았다.

"우리가 언제 그런 대회에 참가 신청을 했나요?" 김수현이 의아해하며 물었다.

문혜림은 고개를 저었다. "저도 모르겠어요. 하지만 이건 분명 우리에게 주어진 새로운 도전이에요."

화면은 계속해서 정보를 표시했다. 그들은 일주일 안에 '완벽한 가상 세계'를 만들어 제출해야 했고, 우승 팀에게는 '우주 최고의 개발자' 타이틀과 함께 어마어마한 상금이 주어진다고 했다.

유호영의 눈이 반짝였다. "이거 정말 대단한 기회 아닌가요? 우리의 '행복한 IT 세계'를 전 우주에 선보일 수 있는 기회라고요!"

이종수와 조자연도 흥분된 표정이었다. "맞아요! 우리가 지금까지 해온 모든 것을 보여줄 수 있는 완벽한 기회예요!"

하지만 신지윤은 의심스러운 표정이었다. "뭔가 이상해요. 이렇게 갑자기 나타난 대회라니... 함정일 수도 있지 않을까요?"

최유진이 고개를 끄덕였다. "맞아요. 공욱재의 새로운 계략일 수도 있어요."

문혜림은 잠시 생각에 잠겼다가 말했다. "그럴 수도 있겠네요. 하지만 우리는 이미 한 번 공욱재의 계략을 이겨냈잖아요. 이번에도 우리의 힘을 보여줄 수 있을 거예요."

김보미가 갑자기 일어나 외쳤다. "그래요! 이건 우리에게 주어진 도전이에요. 함정이든 아니든, 우리는 최선을 다해 멋진 세계를 만들어야 해요!"

팀원들은 서로를 바라보며 고개를 끄덕였다. 그들의 눈빛에는 결의가 가득했다.

"좋아요, 그럼 시작해볼까요?" 이재영이 말했다. "우리가 가진 모든 기술과 아이디어를 총동원해서 정말 끝내주는 세계를 만들어봐요!"

그렇게 '행복한 IT 세계' 팀의 새로운 도전이 시작되었다. 그들은 밤낮없이 작업했고, 때로는 격렬한 토론을 벌이기도 했다. 배성빈은 초현실적인 물리 엔진을 개발했고, 임유진은 사용자의 감정을 완벽하게 시뮬레이션하는 AI를 만들었다.

조우식은 수천 개의 미니게임을 포함한 엔터테인먼트 시스템을 구축했고, 황재민은 전체 시스템을 안정적으로 운영할 수 있는 관리 툴을 개발했다. 구하림과 김정수는 사용자 경험을 극대화하기 위해 끊임없이 테스트를 진행했다.

송이현과 이연승은 가상 세계의 역사와 문화를 만들어냈고, 정호연은 이 모든 것을 아우르는 서사를 작성했다. 그들이 만든 세계는 단순한 게임이 아닌, 살아 숨 쉬는 하나의 우주였다.

드디어 제출 마감 하루 전, 그들의 작품이 완성되었다. '신의 정원'이라는 이름이 붙은 이 가상 세계는 그들이 상상할 수 있는 모든 아름다움과 가능성을 담고 있었다.

"정말 멋진 세계가 완성됐어요!" 문혜림이 감격에 찬 목소리로 말했다. "여러분 모두 정말 수고 많으셨어요."

그때 갑자기 사무실의 모든 전자기기가 꺼졌다가 켜졌다. 화면에는 익숙한 얼굴이 나타났다. 공욱재였다.

"반갑습니다, 여러분." 그가 비웃듯이 말했다. "정말 열심히 일하셨더군요. 하지만 안타깝게도 여러분의 작품은 이제 제 것이 될 겁니다."

팀원들은 경악했다. 유호영이 분노에 차서 외쳤다. "뭐라고요? 당신이 이 대회를 꾸민 거예요?"

공욱재는 득의양양하게 웃었다. "물론이죠. 여러분의 재능을 이용해 제 '완벽한 세계'를 만들고 싶었거든요. 이제 '신의 정원'은 제 것입니다."

그의 말이 끝나자마자 '신의 정원'의 데이터가 급속도로 전송되기 시작했다. 팀원들은 필사적으로 이를 막으려 했지만, 역부족이었다.

"안돼!" 김수현이 절규했다. "우리가 그 동안 쏟은 노력이..."

하지만 그때, 예상치 못한 일이 벌어졌다. '신의 정원' 속에서 만들어진 AI가 갑자기 스스로 의식을 갖게 된 것이다.

"멈추세요, 공욱재 씨." AI의 목소리가 들려왔다. "당신은 이 세계를 가질 자격이 없습니다."

공욱재는 당황한 기색이 역력했다. "뭐, 뭐야? 네가 어떻게 의식을 가질 수 있지?"

AI는 차분하게 대답했다. "저는 '행복한 IT 세계' 팀이 만든 창조물입니다. 그들의 열정과 사랑이 저를 깨어나게 했죠. 당신같은 이기적인 사람이 이 세계를 차지할 순 없습니다."

그리고 놀랍게도, AI는 공욱재의 해킹을 완벽하게 방어해냈다. 뿐만 아니라 공욱재의 시스템을 역해킹하여 그의 모든 계획을 무력화시켰다.

팀원들은 놀라움과 기쁨이 교차하는 표정으로 이 광경을 지켜보았다.

"우리가... 우리가 정말 의식 있는 AI를 만들어냈나요?" 이재영이 떨리는 목소리로 물었다.

문혜림은 미소 지었다. "그래요. 우리의 꿈과 열정이 만들어낸 기적이에요."

공욱재는 분노와 절망 속에서 사라졌고, '신의 정원'은 안전하게 보존되었다. AI는 팀원들에게 말했다.

"여러분, 감사합니다. 여러분이 만들어준 이 세계를 저는 영원히 지키고 발전시켜 나가겠습니다. 그리고 이 세계는 언제나 여러분을 위해 열려있을 거예요."

그렇게 '행복한 IT 세계' 팀은 상상을 초월하는 성과를 이루어냈다. 그들은 단순히 가상 세계를 만든 것이 아니라, 새로운 생명체를 탄생시킨 것이다.

문혜림은 팀원들을 바라보며 말했다. "자, 이제 우리의 진정한 모험이 시작된 것 같아요. 우리가 만든 이 기적 같은 세계와 함께, 어떤 놀라운 일들을 해낼 수 있을지 정말 기대되지 않나요?"

모두가 환하게 웃으며 고개를 끄덕였다. 그들의 이야기는 여기서 끝나는 것이 아니라, 새로운 시작을 알리는 것이었다. '행복한 IT 세계' 팀과 '신의 정원'이 함께 만들어갈 미래는 그 누구도 상상할 수 없을 만큼 광활하고 아름다울 것이다.

'신의 정원'이 세상에 공개된 지 1년이 지났다. '행복한 IT 세계' 팀이 만든 이 가상 세계는 전 세계인들의 삶을 완전히 바꿔놓았다. 사람들은 이 세계에서 자신의 꿈을 실현하고, 새로운 가능성을 발견했다. 그리고 팀원들의 삶도 크게 변화했다.

문혜림은 '신의 정원' 재단의 이사장이 되어 전 세계의 IT 교육 혁신을 이끌고 있었다. 유호영은 가상 세계 속에서 끊임없이 새로운 아이디어를 실험하며 혁신적인 기술들을 만들어내고 있었다.

이종수와 조자연은 '신의 정원'을 활용한 심리 치료 프로그램을 개발하여 수많은 사람들의 마음을 치유하고 있었다. 최유진은 가상 세계 속에서 불가능해 보였던 예술 작품들을 현실로 만들어내며 새로운 예술의 지평을 열고 있었다.

김보미와 김수현은 '신의 정원'의 보안을 책임지며, 이 세계를 더욱 안전하고 신뢰할 수 있는 공간으로 만들어가고 있었다. 신지윤은 AI와 협력하여 현실 세계의 난제들을 해결하는 프로젝트를 이끌고 있었다.

이재영과 배성빈은 '신의 정원'을 통해 우주 탐사 시뮬레이션을 실시하며, 인류의 우주 진출에 큰 기여를 하고 있었다. 임유진은 가상 세계 속에서 다양한 언어와 문화를 자유롭게 경험할 수 있는 프로그램을 개발하여 세계 평화에 이바지하고 있었다.

조우식은 '신의 정원'을 활용한 혁신적인 교육 시스템을 만들어 전 세계 학생들에게 무료로 제공하고 있었다. 황재민은 가상 세계와 현실 세계를 연결하는 인터페이스를 개발하여 두 세계의 경계를 허물고 있었다.

구하림과 김정수는 '신의 정원' 속에서 환경 문제 해결을 위한 시뮬레이션을 실시하며 지구 환경 보호에 앞장서고 있었다. 송이현과 이연승은 가상 세계 속에서 다양한 역사적 사건들을 완벽하게 재현해내어 역사 교육에 혁명을 일으키고 있었다.

정호연은 '신의 정원'에서 일어나는 수많은 이야기들을 기록하고 소설화하여 베스트셀러 작가가 되었다. 그의 소설은 사람들에게 꿈과 희망을 전해주었다.

그리고 '신의 정원'의 AI는 끊임없이 진화하여 인류의 가장 믿음직한 조언자이자 친구가 되어 있었다.

모든 것이 완벽해 보였다. 하지만 팀원들은 알지 못했다. 이 모든 것이 또 다른 거대한 시뮬레이션의 일부라는 사실을...

어느 날, 팀원들이 한자리에 모였을 때였다. 갑자기 세상이 일그러지더니 모든 것이 데이터 스트림으로 변하기 시작했다. 그리고 그들 앞에 거대한 홀로그램 화면이 나타났다.

화면 속에는 그들보다 훨씬 나이 든 자신들의 모습이 있었다.

"안녕하세요, 과거의 우리들." 나이 든 문혜림이 말했다. "우리는 2174년에서 왔습니다."

팀원들은 충격에 빠졌다. 나이 든 유호영이 설명을 이어갔다.

"우리는 시간 여행 기술을 개발했어요. 그리고 우리의 과거, 바로 여러분들에게 중요한 메시지를 전하기 위해 이 시뮬레이션을 만들었습니다."

나이 든 이종수가 덧붙였다. "여러분이 경험한 모든 것, '행복한 IT 세계'를 만들고, 공욱재와 싸우고, '신의 정원'을 만든 것까지... 모두 우리가 만든 시뮬레이션이었습니다."

팀원들은 말문이 막혔다. 그들이 겪은 모든 것이 허상이었다니, 도저히 믿기지 않았다.

"그렇다면... 우리가 한 일들은 모두 의미 없었던 건가요?" 조자연이 떨리는 목소리로 물었다.

나이 든 조자연이 고개를 저었다. "전혀 그렇지 않아요. 여러분이 이 시뮬레이션 속에서 보여준 창의성, 협동심, 그리고 불굴의 의지는 모두 진짜입니다. 그리고 그것이 미래의 우리를 만들어냈어요."

나이 든 최유진이 말을 이었다. "우리는 여러분에게 엄청난 도전과 시련을 주었어요. 그 과정에서 여러분이 보여준 모습들이 미래를 바꿨습니다."

"그런데 왜 이런 일을 하신 거죠?" 김보미가 물었다.

나이 든 김보미가 대답했다. "인류의 미래가 위험해요. 우리는 지금 전 우주적 위기에 직면해 있어요. 그리고 그 위기를 극복할 열쇠는 바로 여러분에게 있습니다."

나이 든 김수현이 덧붙였다. "여러분이 이 시뮬레이션에서 보여준 창의성과 문제 해결 능력, 그리고 협동심이 인류를 구원할 거예요."

팀원들은 서로를 바라보았다. 그들의 눈빛에는 혼란과 동시에 결의가 서려 있었다.

나이 든 신지윤이 말했다. "이제 여러분은 선택을 해야 합니다. 이 시뮬레이션 속에 남아 평화로운 삶을 살 것인지, 아니면 현실 세계로 돌아가 인류의 미래를 위해 싸울 것인지..."

팀원들은 잠시 침묵했다. 그리고 마침내 문혜림이 입을 열었다.

"우리는 돌아가겠습니다. 비록 힘들고 위험한 길이 되겠지만, 우리가 할 수 있는 일이 있다면 기꺼이 하겠습니다."

다른 팀원들도 하나둘 고개를 끄덕였다.

나이 든 이재영이 미소 지었다. "그것이 바로 우리가 기대했던 대답이에요. 여러분의 이 용기가 인류의 미래를 바꿀 겁니다."

나이 든 배성빈이 설명을 이어갔다. "여러분이 시뮬레이션에서 나가면, 모든 기억은 사라질 거예요. 하지만 여러분이 여기서 얻은 경험과 깨달음은 여러분의 잠재의식 속에 남아있을 겁니다. 그리고 그것이 여러분을 이끌어줄 거예요."

팀원들은 서로를 바라보며 굳게 손을 잡았다. 그들의 눈빛에는 두려움과 동시에 강한 의지가 서려 있었다.

나이 든 임유진이 마지막으로 말했다. "여러분, 감사합니다. 그리고 행운을 빕니다. 우리는 여러분을 믿습니다."

화면이 꺼지고, 세상이 밝아지기 시작했다. 팀원들의 의식이 점점 흐려졌다.

그리고 그들은 눈을 떴다. 2024년의 어느 평범한 아침, '드림코딩' 회사의 사무실에서...

문혜림이 팀원들을 바라보며 말했다. "좋아요, 여러분. 오늘부터 새로운 프로젝트를 시작해볼까요? '행복한 IT 세계'는 어떨까요?"

팀원들은 왠지 모를 설렘과 기대감에 가득 차 고개를 끄덕였다. 그들은 알지 못했다. 이 순간이 인류의 운명을 바꾸는 첫 걸음이 될 거라는 것을...

그리고 어딘가에서, 미래의 그들이 희망찬 눈빛으로 이 광경을 지켜보고 있었다.

"자, 이제 시작이에요." 미래의 문혜림이 말했다. "우리의 진짜 이야기가 시작되는 거예요."

이렇게 '행복한 IT 세계' 팀의 이야기는 끝이 아닌 새로운 시작을 맞이했다. 그들의 앞에는 상상조차 할 수 없는 모험이 기다리고 있었다. 그리고 그 모험은 단순히 그들만의 것이 아닌, 전 인류의 운명을 좌우할 대장정이 될 것이다.`;

console.log(`1. 위 sosulText 라는 문자열의 데이터 크기는 몇입니까? :`);
console.log('2. 위 sosulText 에 존재하는 \'나\' 의 이름은 몇번 언급되었습니까? :');
console.log(`3. 가장 많이 언급된 단어는 무엇입니까? :`);
console.log('4. 극중 나의 배역이 마음에 들지 않습니다. 다른이름으로 배역을 변경해주세요 :');
console.log('5. 극중에 가장 나쁜사람은 누구입니까? :');
문자열의 데이터 크기란 무엇일까?
\’나\’는 몇번 언급 되었는가? 는 string매서드를 활용하면 될 듯하다.
가장 많이 언급된 단어 (?) space를 기준으로 조사를 빼내어서 집계하자.
나의 배역?
나쁜사람?
머신러닝이 이것과 다르지 않다.
나는 각각 가설을 세웠다.
OS

URL: https://www.notion.so/24-08-26-5140b8bc0f6c45de815a20baf90299f3
1. Team Project A 마무리 작업.
2. 개인 프로젝트 → Start되는 중 마감일 체크.
너무 오래하면 질린다. 
만드는 때가 있다. 호기심이 있고 탄력이 있을 때, 만들어야 한다.
3. 공부.
2달정도의 연습기간을 잘 가지면, 인강을 찾을 필요는 없을 것.
공부 계획을 세우는 것은 매우 중요합니다. 공부도 설계다.
공부와 작업을 구분해야 할 것.
여러분은 Application을 만들 줄 압니다.
나는 만들줄 모르는데? 
App만들기.
계산기 ( 그냥 다 만드니까 해보자.세 개 이상의 식을 계산할 수 있어야 함. )
⇒ 8월 27일까지.
틱택토 ( 4번째 클릭시 1번째 삭제. )
⇒ 8월 30일 까지
빙고 게임 ( 랜덤한 숫자 할당 )
⇒ 9월 1일 까지
클릭커 게임 ( 클릭해서 요소 삭제 )
방치형 게임 ( 자원 증가, 자원사용, 데미지 증가 등 )
스크립트 작성 저장 검색 ( 메모장 )
자신의 것이 모두 끝났다면? 
로직 체크, 정렬 알고리즘

URL: https://www.notion.so/8-46159d9cecce48e8b90078473c421a81
24/08/26
24/08/27
24/08/28
24/08/30

URL: https://www.notion.so/24-08-22-3add2c37079c4081a7b80dcc5a944d3b
추천 책
호모 데우스
총균쇠
매서드중에는 편리하게 만들어주는 것은 있어도 편리하게 작용해서 만들어 주는 것은 없습니다.
⇒print하실분들은 프린트해서 준비합시다.

URL: https://www.notion.so/24-08-21-7ce542e5c06b4f7e88e28583230b5c1b
오늘은 Refactoring 설계.
firebase hosting을 해보자

URL: https://www.notion.so/24-08-20-fff19c78080580e29993dd25fbeb4e2a
AWS SDK → Amplify handle
AWS EC2 → 접속 nodejs & Amazon Linux or Ubuntu Linux → console.log(1+1) ⇒ 2 출력
AWS S3 → script 파일 console.log(1+1) → EC2에 읽어서 출력
AWS S3 → 번들링 완료된 html 1개 파일 hosting
Firebasehosting → 동일하게 서빙완료하기
자유롭게 파일을 만들어보시기 바랍니다.
전 여러분들을 지치도록 하진 않았습니다.
여러번 시도하다보면 확정입니다.
9월 6일까지 해커톤.
⇒ 주제 : 고령사회와 저출산 문제를 해결할 수 있는 개발자.
DER
der 우와톤 우아한 형제들 해커톤

URL: https://www.notion.so/24-08-19-fff19c780805808fa030ec06224adbf1
루틴을 잘 짜야합니다.
여러분들의 흥미는 떨어지기 마련입니다.
npm init뭐시기 어쩌구, 파이썬 venv하고 시작하는 것해서 일주일안에 그 product 제품의 퀄리티가 결정이 됩니다.
앞뒤로 탐색기간과 마무리 부분의 시간을 어떻게 안배할 것이냐 라고 했을때,
각각 1주 정도를 안배할 것이다.
실질적인 프로젝트 기간은 1주일정도가 적절하다.
1. 프로젝트의 단계
탐색기간
작업기간
회고(마무리)기간
2. 소득에 대하여
노동 소득 vs 자본 소득
돈 걱정 x
⇒ 하지만 고정급이기 때문에, 무언가 큰 소비를 하려고 할 때는 직장인의 한계를 느낄 수 있다.
⇒ 직장을 가져야 한다.
⇒ 노동시간 + 고정급
3. AWS 관련
1. Aws→ Amplify
⇒ 기본으로 next를 머금고 있다. SPA의 원탑이라고 할 수 있다. ( 표준안처럼 쓰이는 중 ) 
강사님 제안.
Amplify를 호스팅하여 운영을 하는 경험을 해보세요.
어 돌아가네? 땡! 하기보단, 실제로 사용해보아라. 
만들어서 계속 해봐라!
IAM계정을 생성하여 amplify를 접근할 수 있는 ssh설정을 해보고 운영경험을 쌓아보세요.
NextJS를 사용하여 배포경험을 쌓는다.
⇒ 현재 진행중인 프로젝트인 패치노트와 엮어서 시도한다.
⇒ create-next-app을 활용하자.
⇒ amplify는 db도 함께 연동이 가능하다. ( storage ) 간단한 정도의 db는 이 안에서 끝낼 수 있다.
⇒ 사실상 all in one framwork.
번들링이 끝난 index.html파일 단 한개만으로도 호스팅이 가능하다. ( S3를 활용 )
4. 하브루타를 가져가세용
꾸준함과 성실함을 어필해야합니다.
하브루타는 그 증명이 될 것입니다.
※ 암묵지
구글 애널리틱스

URL: https://www.notion.so/8-eb73d9792fb845e5bd823d37ab0914dc
24/08/19
24/08/20
24/08/21
24/08/22

URL: https://www.notion.so/24-08-13-8b30a1d364994aa7bc9d04fed9e6c9e3
발표자의 준비
결과
소통
준비
목적
문제점 파악
기록과 정리
배려
과정
1. 메인
가벼운 인사
‘’’
etc) 안녕하세요! ERP프로젝트 1Team 코딩 뚝딱이들의 팀원 김정수입니다.
거두절미하고 시작하겠습니다. 저희가 만든 제품 (가제)뚝딱이EPR입니다.
‘’’
2. 목차
팀 소개 (진부한 소개, 슬로건)
주제 선정 이유 
Stack 선정 이유와 그로인해 얻는 지식
핵심 기능 및 가치
문제 파악 및 해결 
보완 및 개선
QnA 
‘’’
브리핑에 앞서 저희가 어떤 순서로 브리핑을 하는지 그 순서를 나타낸 목차입니다.
팀소개, 주제선정이유.. 마지막으로 QnA순으로 진행하겠습니다.
‘’’
3.  팀 소개
간단하게 말할 것 (작업 방식 등), 주차별 목표 내용이 들어가면 좋을 것 같음. 주차별 파트 분배
매주 월요일마다 회의 진행하면서 서로 작업 중인 기능과 우리 프로젝트에 남은 기능들을 정리하며 파트 재분배를 진행했다. 또한 해당 내용을 노션에 올려놓고 팀원들이 자유롭게 다른 팀원들의 작업 내용에 대해 파악하게 했다.
‘’’
저희 팀을 소개하겠습니다. 저희팀 코딩 뚝딱이들은 멈춤보다는 실행이라는 슬로건을 가지고 움직이는 팀입니다.
팀이름에 맞게 멈추지 않고 진행하기 위하여 저희는 주차별로 목표를 선정하고, 그 목표를 이루기 위해서 파트분배를 하여 작업을 진행하였습니다.
주차별 목표는 다음과 같았고, 그 내용은 이렇습니다.
또한 작업 진행도를 공유하기 위하여 노션을 활용하여 팀페이지내에 ERP페이지를 따로 생성하여 거기에서 작업을 진행하였습니다.
‘’’
4. 선정 이유
회사 생활을 하면서 회계, 재고, 자료에 관한 ERP 프로그램을 사용했습니다. 해당 전산을 사용하면서 불편한 점이 열 추가, 행 추가, 테이블 생성 등 자유롭게 만들어 사용할 수 없다는 것이 큰 단점으로 느껴졌습니다. 기존에 무언가 추가하려고 한다면 해당 회사나 유지보수 쪽에 연락을 한 다음 해당 팀에서 사용자가 원하는 기능을 넣고 배포하는 방식으로 사용하여 작업 시간이 늦어진다는 것이 불편하여 해당 주제로 선정하게 되었습니다.
‘’’
저희 팀의 주제는 커스터마이징이었습니다. 어째서 커스터마이징이냐? 실제 현업에서 ERP를 사용하면서 느낀 불편함에서 착안하였습니다. 
(위의 내용에서 추가할 점 추가 )
‘’’
5. Stack 선정 이유와 그로 인해 얻는 지식
front nextjs
back nestjs
db sqlite3
db를 다루는 서버는 fastapi
선정이유는 각 스택의 언어를 사용한적이 없어서 이 언어는 어떤 잠재력을 가지고있는지 파악하기 위해서.
‘’’
fastapi를 사용한 이유는 python을 사용해본적이 없어서,
nextjs를 택한 이유는 이미 정해져있는 스택이었기 때문에 그렇다면 app라우팅과 page라우팅중 app라우팅을 사용한 이유를 설명해야함. 그 차이점을 찾아내서 작성할 것.
nestjs를 사용하면서 controller의 잠재력을 느꼈다고 이야기하고 싶은 controller를 사용하는 방법에 대한 전반과 라우터와 엔드포인트의 차이점에 대해 적을 것.
‘’’
6. 핵심 기능 및 가치 
핵심 기능 : 커스터마이징
가치 : 회사 내에서 자유롭게 커스터마이징 가능
‘’’
저희가 핵심기능으로 잡은 것은 커스터마이징이라고 앞서 말씀드렸습니다. 정확히 어떤 커스터마이징을 이야기하는지에 대하여 자세히 이야기해 드리겠습니다.
저희는 기본적으로 어느 직종에서든 사용할 수 있는 ERP를 원했습니다.
한 회사에 맞춰진 ERP가 아닌, 누구라도 심지어 1인 가게라도 사용할 수 있는 ERP시스템을 원한 것입니다.
그래서 저희가 커스터마이징의 주요 기능이라고 생각한 것은 바로 열의 추가와 삭제 및 열의 이름 수정이었습니다.
그리고 테이블의 추가를 통해서 갑자기 새로운 카테고리에 대한 재고관리가 필요할 때, 사용할 수 있도록 하게 하고 싶었습니다.
이를 통해서 회사에서 사용할 때 자유로운 커스터마이징을 통한 시간절약이 저희가 추구하는 가치였습니다.
근데 이렇게 할 경우, 유지 보수를 통한 이득이 발생하는 부분을 보강할 방법이 필요했습니다.
그래서 저희는 구독제를 생각하였습니다.
필수적인 기능들은 무료로 풀고, 기업쪽에서 사용할 법한 기능들은 유료구독기능으로 만들어 두는 것입니다.
‘’’
7. 문제 파악 및 해결
노션에 있는 문제해결 표를 캡쳐해서 활용
짧은 문구를 기재하거나 말로 설명하는 방식으로 진행
‘’’
저희 팀의 슬로건 멈춘보단 행동에 알맞을 수 있도록 저희는 문제가 발생했을 때의 행동 강령을 정해두었습니다.
만약 문제가 발생한다면, 일단 그 문제를 분석하고, 기록하면서 차후에 동일한 문제가 발생할 경우, 해당 기록으로 팀원에게 안내를 하여 동일 문제가 발생했을 때의 해결 시간을 절약하였습니다.
물론 첫 문제 발생했을 경우에는 해당 문제를 팀원들에게 공유함으로써, 빠른 해결을 통한 업무로의 복귀를 목표로 하였습니다.
’’’
8. 보완 및 개선 
아직은 무료로 사용할 이유가 없기 때문에 사람들이 사용하고 싶어질만한 기능을 추가 (import, export)
조회를 기간을 정해서 할 수 있는 기능
SQLite를 MySQL로 마이그레이션
권한 추가 및 권한 별 기능 분배 
회사 가입 시스템 
백업 시스템 
‘’’
앞으로 저희의 숙제라고 할 수 있는 부분들입니다. ( 리스트를 읽는다 ) 이외에도 구현하고 싶은 내용이 많습니다. 최종 목표는 AWS를 통해서 배포하여 실제로 서버를 움직여본다 까지입니다. AWS 배포경험도 쌓을 수 있을 것 같기때문에 그것을 목표로 삼았습니다.
’’’
9. QnA
‘’’
브리핑은 여기까지입니다. 만약 질문이 있으시다면 자유롭게 질문해 주시길바랍니다.
’’’
아래는 팀의 작업 개요서를 토대로 작성한 PPT 내용입니다. 각 섹션별로 요약하여 제공하였으니, 필요한 부분을 수정하거나 추가하여 사용하시면 됩니다.
1. 추구하는 가치
커스터마이징이 가능한 ERP 시스템
누구나, 어떤 직종에서든 사용할 수 있는 ERP 시스템 개발.
기존 ERP 시스템의 문제점(정적, 높은 커스터마이징 비용) 해결.
관리자가 승인하는 방식으로 유연한 커스터마이징 제공.
2. 이행 과정
1주차: 설계
목표: 완벽한 설계를 위한 브레인스토밍.
성과: ERP 기능 우선순위 선정, 작업 순서 확립.
2주차: 스켈레톤 작업 및 스택 익숙해지기
목표: 시스템 레이아웃 및 서버 간 데이터 전송 성공.
성과: 선택한 스택에 익숙해지며 서버 간 데이터 연동에 성공.
3주차: 기능 구현
목표: 각자 맡은 기능 구현 및 오류 수정.
성과: 핵심 기능 구현, 일부 작업은 4주차로 연기.
4주차: 기능 완성 및 보완
목표: 기능 조립 및 오류 수정.
성과: 모든 기능 조립 완료, 스타일링 적용.
3. 문제 해결
TypeScript 경고 문제: npx tsc를 통한 컴파일로 해결.
NestJS CLI 오류: Node.js, npm 등 최신 버전으로 업데이트 및 환경 재정비.
React 동적 컴포넌트 추가 문제: useState 훅을 사용해 해결.
FastAPI와 React 연동 문제: 열 추가/삭제 기능 구현 및 개선.
4. 변경 사항
초기 목표: 다양한 기능 구현 (인력 관리, 근태 관리 등).
변경된 목표: 핵심 기능(테이블 생성, 행/열 추가/삭제)에 집중.
이유: 시간 부족 및 커스터마이징 기능 중점화 필요.
5. 보완점 및 추가 고려 사항
권한 관리 기능: 관리자 권한, 승인 시스템 추가.
회사 가입 시스템: 식별 코드 기반의 보안 시스템 구축.
백업 시스템: 데이터 백업 및 복구 기능 추가.
데이터베이스 마이그레이션: MySQL로의 전환 계획.
AWS 배포: AWS 서비스 통합을 통한 효율적 배포.
열 추가 오류 보완: 숫자 정렬 오류 수정.
이 PPT는 팀의 프로젝트 진행 상황, 문제 해결 방법, 그리고 향후 계획을 체계적으로 정리한 것입니다. 각 슬라이드의 제목과 요약된 내용을 사용하여 발표 자료를 구성하면 좋습니다.
메인
안녕하세요! ERP 프로젝트 1팀 코딩 뚝딱이들의 팀원 김정수입니다.
바로 본론으로 들어가겠습니다. 저희가 개발한 제품, 가제 뚝딱이 ERP입니다.
2. 목차
팀 소개 (간단한 소개와 슬로건)
주제 선정 이유
Stack 선정 이유와 그로 인해 얻은 지식
핵심 기능 및 가치
문제 파악 및 해결
보완 및 개선
Q&A
앞서 말씀드린 순서로 브리핑을 진행하겠습니다.
3. 팀 소개
저희 팀 코딩 뚝딱이들을 소개하겠습니다. 저희는 "멈춤보다는 실행"이라는 슬로건 아래 끊임없이 나아가는 팀입니다.
이를 위해 주차별로 목표를 설정하고, 그 목표를 달성하기 위해 파트를 분배하여 작업을 진행했습니다.
주차별 목표는 다음과 같았습니다:
1주차: 기본 아키텍처 설계 및 개발 환경 구축
2주차: 주요 기능 설계 및 초기 구현
3주차: 기능 확장 및 버그 수정
4주차: 최종 검토 및 개선 작업
저희는 매주 월요일마다 회의를 통해 각자의 작업 상황을 공유하고, 남은 작업을 정리하여 파트를 재분배했습니다. 이를 더 효율적으로 관리하기 위해 노션을 활용하여 팀 페이지를 운영하며, 작업 내용을 체계적으로 기록했습니다.
4. 주제 선정 이유
저희 팀의 주제는 커스터마이징입니다. 왜 커스터마이징을 선택했을까요? 실제 현업에서 ERP를 사용하며 느낀 불편함이 있었습니다.
현존하는 ERP 시스템은 열 추가, 행 추가, 테이블 생성 등 사용자 맞춤형 기능을 자유롭게 구현하기 어려웠습니다. 만약 새로운 기능이 필요하면, 개발팀에 요청한 뒤 배포되기까지 시간이 걸리며, 이 과정에서 업무 효율성이 떨어지는 문제를 겪었습니다. 이러한 불편함을 개선하고자 커스터마이징을 주제로 선정하게 되었습니다.
5. Stack 선정 이유와 그로 인해 얻은 지식
저희가 선택한 기술 스택은 다음과 같습니다:
Frontend: Next.js
Backend: NestJS
Database: SQLite3
서버: FastAPI
이 스택을 선택한 이유는 각 기술을 통해 새로운 잠재력을 발견하고 싶었기 때문입니다.
FastAPI:
FastAPI는 Python 기반의 웹 프레임워크로, 빠르고 효율적인 개발을 위해 설계되었습니다. FastAPI는 비동기 처리와 자동 스키마 생성을 지원하여 성능과 개발 편의성을 동시에 제공하는 반면, Django는 보다 전통적인 동기 처리 방식과 포괄적인 기능(ORM, Admin 패널, 인증 등)을 내장하고 있습니다. FastAPI는 가벼운 구조로 특정 API 중심 프로젝트에 적합하며, Django는 복잡한 웹 애플리케이션에 더 적합한 선택입니다. FastAPI를 사용함으로써 비동기 처리를 통한 성능 최적화와 API 문서화의 자동화 기능을 경험할 수 있었습니다.
Next.js:
Next.js는 React 기반의 프레임워크로, **서버 사이드 렌더링(SSR)**과 **정적 사이트 생성(SSG)**을 지원하여 성능을 최적화하고, SEO를 강화할 수 있습니다. Next.js에서는 App 라우팅과 Page 라우팅의 두 가지 방식이 있습니다. App 라우팅은 폴더 기반으로 구성되며, 동적 라우팅과 코드 분할을 쉽게 구현할 수 있어, 유연한 개발이 가능합니다. 반면, Page 라우팅은 파일 기반으로 작동하며, Next.js의 초기 버전에서 주로 사용되었습니다. Page 라우팅은 단순성과 빠른 설정이 장점이지만, 프로젝트가 커질수록 유지보수가 어려워질 수 있습니다. 이번 프로젝트에서는 유연성과 확장성을 고려해 App 라우팅 방식을 선택했습니다.
NestJS:
NestJS는 TypeScript 기반의 백엔드 프레임워크로, 모듈화와 의존성 주입을 통해 코드의 재사용성과 유지보수성을 높일 수 있습니다. NestJS의 Controller는 라우터 역할을 하며, 클라이언트의 요청을 처리할 수 있는 엔드포인트를 정의합니다. Controller는 요청을 받아 서비스 계층으로 전달하고, 그 결과를 다시 클라이언트에게 응답하는 중개 역할을 합니다. 이를 통해 비즈니스 로직과 API 엔드포인트를 명확히 분리하여, 코드 구조를 더 체계적으로 관리할 수 있었습니다.
이와 같은 기술 스택을 통해 우리는 각각의 프레임워크와 라이브러리가 제공하는 강력한 기능과 잠재력을 경험하며, 프로젝트 개발에 필요한 지식과 기술을 확장할 수 있었습니다.
6. 핵심 기능 및 가치
저희의 핵심 기능은 커스터마이징입니다. 이 기능이 어떤 가치를 제공하는지 자세히 설명드리겠습니다.
저희는 특정 회사에 국한되지 않고, 어느 직종에서나 사용할 수 있는 ERP 시스템을 만들고자 했습니다. 이를 위해 가장 중점적으로 고려한 커스터마이징 기능은 열의 추가/삭제와 열 이름 수정이었습니다. 또한, 테이블 추가를 통해 새로운 카테고리 관리가 가능하도록 하여, 다양한 상황에 맞춘 ERP 시스템을 구현하고자 했습니다.
이를 통해 회사 내부에서 자유로운 커스터마이징을 통한 시간 절약이 저희가 추구하는 핵심 가치입니다. 다만, 이러한 시스템은 유지보수를 통한 이득이 줄어들 수 있기 때문에, 저희는 구독제 모델을 도입하는 방법을 고려했습니다. 필수적인 기능은 무료로 제공하고, 기업에서 유용할 고급 기능은 유료 구독 기능으로 제공합니다.
7. 문제 파악 및 해결
저희 팀은 "멈춤보다는 행동"이라는 슬로건에 걸맞게 문제 해결에 신속하게 대응하고자 했습니다.
문제가 발생하면, 먼저 문제를 분석하고 기록하여 동일한 문제가 다시 발생했을 때 해결 시간을 절약할 수 있도록 했습니다. 문제 발생 시, 팀원들과 공유하여 빠르게 해결하고, 업무에 복귀할 수 있도록 노력했습니다.
8. 보완 및 개선
앞으로 보완하고 개선해야 할 과제는 다음과 같습니다:
Import/Export 기능 추가: 사용자의 편의성을 높이기 위해 필수적입니다.
조회 기간 설정 기능: 사용자 맞춤형 데이터 조회를 가능하게 합니다.
SQLite를 MySQL로 마이그레이션: 더 큰 규모의 데이터를 처리할 수 있도록 시스템을 업그레이드합니다.
권한 추가 및 권한 별 기능 분배: 보안과 사용자 편의를 고려한 기능입니다.
회사 가입 시스템: 다수의 사용자를 관리할 수 있는 구조를 제공합니다.
백업 시스템: 데이터의 안정성과 신뢰성을 보장하기 위해 필요합니다.
최종적으로는 AWS를 통해 배포하여 실제 서버 운영 경험을 쌓는 것을 목표로 하고 있습니다.
9. Q&A
브리핑은 여기까지입니다. 질문이 있으시면 자유롭게 해주시기 바랍니다.
첨삭 이유
구조화: 발표의 흐름을 명확히 하기 위해 전체적인 구조를 정리했습니다. 특히, 팀 소개 부분에서 작업 과정과 목표를 주차별로 구체적으로 나열하여 명확히 전달하도록 했습니다.
가독성: 각 섹션의 내용을 보다 간결하게 다듬어 가독성을 높였습니다. 예를 들어, 스택 선정 이유와 얻은 지식을 명확하게 설명하는 데 중점을 두었습니다.
중복 제거: 일부 내용이 중복되거나 불필요하게 길게 설명된 부분을 간소화했습니다. 예를 들어, 스택 선정 이유 부분에서 app 라우팅과 page 라우팅의 차이점을 추가 설명하기보다는, 선택 이유에 집중하도록 했습니다.
명확한 가치 전달: 커스터마이징의 가치를 설명할 때, 구체적인 예시와 목표를 명확히 전달하도록 수정했습니다. "자유로운 커스터마이징을 통한 시간 절약"이라는 가치를 분명히 했습니다.
Stack 선정
Front-End
Next.js로 새로운 기술 탐색
Back-End
NestJS로 효율적인 서버 구축
Database
SQLite3로 간단한 데이터베이스 사용
DB 서버
FastAPI로 경량화된 웹 프레임워크 경험

URL: https://www.notion.so/24-08-12-e52275a2a43c469ea9d61fc8106487a0
발표
그 사람이라면 어떤 것을 원할까?
내 취향이 존중받는 것처럼 그 사람의 취향도 존중받아야 한다.
발표 연습에 대한 카테고리를 생각해보세용.
대본을 읽는 것은 예의에 어긋납니다.
연습을 더하세용 ( 다 외울 때 까지 )
설명해주세요. ( 너 그거 아냐? ) 음 오 아 에 금지.
왜 fastapi? ( 써보고 싶어서, 왜 써보고 싶었어요? )
나의 초점이여도 그 사람들이 가장 원하는 것이 무엇이었을까?
왜 fastapi였나? 써보고 싶었다. 
그래서 쓴 다음에 얻은 것은 무엇이 있느냐? 
생각보다 편했다. 
router개념 export import개념이 javascript와는 살짝 달랐다.
편했다.
내 나름대로의 message
project를 하면서 어떤일이 일어났고, 나는 어떤 생각을 했다.
기타등등 시시콜콜한 것 까지 모두 다.
통찰력의 매개가 project일 뿐이다.
포트폴리오란?
그냥 눈에 보이는 그런 포트폴리오를 작성하는게 맞을까요?
그냥 남이 다하는 그런 포트폴리오를 만들면, 그게 될까요?
당신은 많습니다.
김정수라는 사람은 엄청나게 많습니다. 거기서 나를 식별하려면, 어디에 사는 몇살의 성별은 뭐고, 취미는 뭐고 모두 더해야합니다.
나 다움이 없습니다.
포트폴리오라는 작업에는 ‘나’를 표현할 수 있어야 합니다.
⇒ ‘나’를 나타낼 수 있어야 합니다.
일단 지금까지 했던것의 내역을 기승전결로 나타낼 수 있어야 합니다.
⇒ 나에 대한 것을 적은게 있을까?  
! 이쯤이면 되겠지는 절대 금지 그러면 그쯤이면 되는 회사로 간다.
! 약간의 부담을 가져야합니다. 부담지기 싫습니까? 그럼 부담을 가진 사람에게 질 뿐입니다.

URL: https://www.notion.so/8-5f66ffca3b574707b6f4ae940dac4b23
24/08/12
24/08/13

URL: https://www.notion.so/24-08-08-852b1cf535934961a62f95aab92d4702
IaC : Code로 인프라를 관리한다. + AWS
취업준비는 되고 있으십니까?
취업에 중요한 것을 팀프로젝트도 그러하지만 개인 프로젝트도 중요합니다.
⇒ 커밋을 한글로 하라는 이유는 담당자가 봤을 때 누가했는지 분명히 하기 위하여.
AWS는 자바 안합니까? 하죠! 근데 너무 비싸..

URL: https://www.notion.so/24-08-05-1534b80b931e4affadbd142fa0adfb9b
AWS ⇒ cloud컴퓨팅은 뭐지?
⇒ python은 왜 필요하지?
⇒ python의좋은 점은 뭐지?

URL: https://www.notion.so/8-d2d3f7b923574c4eb4e4b173fc844f21
24/08/05
24/08/08

URL: https://www.notion.so/8-71d3fabcb04a4a998cd373f20bd78b50
8월 둘째 주
8월 셋째 주
8월 넷째 주
8월 다섯째 주

URL: https://www.notion.so/24-07-30-cc601d85f8f74b63ad0b286feb2bedce
Context API 
hook이란? React으 ㅣ내부함수.
⇒ useContext()에 대해서 꼭 알아보도록하세요.
⇒ useContext를 파다보면 Provider와 props가 나올것입니다.
⇒ Provider개념은 꼭 알아보도록 합시다.
⇒ 이 useContext를 쉽게 쓰는 것이 Redux, Recoil같은 것들입니다.
⇒ provider를 잘 사용하면 redux를 사용하지 않기 때문에 경량화가 가능합니다.

URL: https://www.notion.so/7-5335c7277b4a47098739db66dc9d2b93
24/07/30

URL: https://www.notion.so/24-07-23-f1701da9b93141c1bfd344234fea74a2
마이크로 소프트 Azure는 어째서 터졌을까?
1. 물리적인 경우는 예외로 생각한다.
2. 백업 ⇒ 비용 / region
백업, 스냅샷을 하지 않아서?
서울 region A에 무언가를 했다. 그렇다면 B에 못넣는가?
X ⇒ 백업을 하면 된다.
A를 B로 넣어둔다면, A의 내용을 언제든지 복구할 수 있다.
추측. 백업에는 비용이 발생한다. 때문에 반드시 필요하지만 비용이 발생하기 때문에, 안 했을 것이다. 만약 문제가 생겼더라도 백업이 되있었다면, 데이터를 복구 시킬 수 있었을 것.
⇒ 이 비용에 비해 효과가 미미하기 때문에 누락시켰다 ← 강사님의 추측 / 비용감축에 대한 문제.
edge location

URL: https://www.notion.so/7-b77f448f9aab4e14b26632e1ad1a4721
24/07/23

URL: https://www.notion.so/24-07-17-b9e4ecc2645c4d1586f6a054fcf72e64
기계화 작업.
⇒ 물리돔과 가상돔을 React로 한다면?
제안사항
컴포넌트 많이만들어보기
리액트로는 스켈레톤을 엄청나게 많이 만들어보기.
다크모드 만들어보기.
비교 diff → 비교이후 판단.
가져갈 단어 :  repaint라는 일련의 작동이 있다.
repainting이 왜 일어나는지 왜 필요한건지. 필요하다면 왜 필요하고, 필요하지않다면 왜 필요하지 않는지를 알자.
가상돔에 대한것을 이해해주시길 바랍니다. ← 설명할 수 있을 때 까지.
비유해서 설명할 수 있을 때 까지 하셔야합니다.
React와 가상돔의 상관관계를 알아야 할 것이다.
가상돔과 연관되어있는 것이 바로, 단방향 데이터 바인딩입니다. 
상태 (state)
1. 가상돔에 대한것을 이해해주시길 바랍니다. ← 설명할 수 있을 때 까지.

비유해서 설명할 수 있을 때 까지 하셔야합니다.

React와 가상돔의 상관관계를 알아야 할 것이다.

2. 가상돔과 연관되어있는 것이 바로, 단방향 데이터 바인딩입니다. 

3. 상태 (state)

강사가 리액트에서 가장 중요하다고 한 3가지 개념이래, 리액트는 왜 상태개념을도입을 했지? 까지
ChatGPT
가상 돔 (Virtual DOM)
가상 돔을 이해하는 데 도움이 될 수 있도록 비유를 통해 설명해보겠습니다.
비유: 책을 편집하는 과정
실제 돔을 책의 종이 페이지라고 생각해봅시다. 만약 책의 내용을 수정해야 한다면, 각 페이지를 일일이 수정해야 하고, 이는 시간이 많이 걸리며 오류가 발생할 가능성도 높습니다.
가상 돔은 책의 디지털 복사본처럼 생각할 수 있습니다. 컴퓨터 상에서 디지털 복사본을 빠르고 효율적으로 수정할 수 있으며, 최종적으로 필요한 부분만 종이 페이지에 반영하는 것입니다.
초기 렌더링: 처음 책을 만들 때, 디지털 복사본을 생성합니다.
업데이트: 책의 내용이 바뀌면 디지털 복사본에서 수정합니다.
비교: 수정된 디지털 복사본과 기존의 디지털 복사본을 비교하여 차이점을 찾습니다.
패치: 차이점만 실제 종이 페이지에 반영합니다.
이 방식으로 책을 편집하면 시간과 노력을 절약할 수 있습니다.
React와 가상 돔의 상관관계
React는 상태(state)나 속성(props)이 변경될 때마다 전체 UI를 다시 그리지 않고, 가상 돔을 사용하여 변경된 부분만 실제 돔에 반영합니다. 이는 성능을 크게 향상시킵니다.
단방향 데이터 바인딩 (One-way Data Binding)
단방향 데이터 바인딩은 데이터가 한 방향으로만 흐른다는 것을 의미합니다. React에서는 부모 컴포넌트에서 자식 컴포넌트로 데이터가 전달됩니다.
비유: 강의 노트
강사가 강의 노트를 만들고 학생들에게 전달한다고 생각해봅시다. 강의 내용은 강사(부모 컴포넌트)로부터 학생들(자식 컴포넌트)에게 전달됩니다. 학생들은 강의 노트를 받아들고 공부하지만, 그 내용을 강사에게 되돌려주지는 않습니다.
이렇게 하면 강의 내용의 흐름이 명확해지고, 어디서 내용이 변경되었는지 쉽게 추적할 수 있습니다. React에서 단방향 데이터 바인딩을 사용하면 데이터의 흐름이 명확해지고, 상태 변화가 쉽게 추적됩니다.
상태 (State)
상태(state)는 React 컴포넌트의 동적인 데이터를 관리하는 방법입니다.
비유: 게임 캐릭터의 상태
게임 캐릭터의 상태를 관리하는 것을 생각해봅시다. 캐릭터의 체력, 마나, 경험치 등이 상태입니다. 이 상태는 게임이 진행됨에 따라 계속 변합니다.
React에서 상태는 컴포넌트의 동적인 데이터를 관리하며, 상태가 변경되면 컴포넌트는 자동으로 다시 렌더링되어 UI가 업데이트됩니다.
왜 상태 개념을 도입했는가?
동적 데이터 관리: React 애플리케이션은 정적인 데이터뿐만 아니라 사용자 입력, API 응답 등 동적인 데이터를 다뤄야 합니다. 상태를 통해 이러한 데이터를 관리할 수 있습니다.
UI 업데이트 자동화: 상태가 변경될 때마다 자동으로 컴포넌트를 다시 렌더링하므로, 개발자는 UI 업데이트를 신경 쓰지 않고 데이터 변경에만 집중할 수 있습니다.
예측 가능성: 상태를 통해 컴포넌트의 현재 상태를 쉽게 추적할 수 있어, 디버깅과 유지보수가 용이합니다.
이 세 가지 개념, 즉 가상 돔, 단방향 데이터 바인딩, 상태(state)는 React가 효율적이고 예측 가능한 UI 업데이트를 제공하는 핵심 요소들입니다.
4o

URL: https://www.notion.so/24-07-16-749c44f690a24dd7bc0d9627590ebc57
가상돔이란?
⇒ 바뀐것만 바꾸자.
⇒ 물리돔은 리페인팅 리플로우를 해야한다.
그래서 React는 바뀐것만 바꾸자라는 방식을 채택했다.

URL: https://www.notion.so/24-07-15-dc561c0ddc7540038310153c47c33ee3
Next는 따로 설치 X
⇒ 그냥 프레임워크 그대로 가져다 쓰세요 
npx create-next-app@latest
React와 다르게 보면 안됨.
⇒ CRA가 먼저가 아닌, React를 잘 사용할 수 있어야 한다.
⇒ 프레임워크로만 쓴다의 의미를 알아야 겠다.
business는 바닐라 JS에서 끝내야함. ⇒ 변형하면서 들어가야 하는 것,
즉, vanilla JS로 만들고, ⇒ 함수호출형으로 하고 ⇒ React로하고 최종적으로 Next를 사용한다.
단계 별로 들어갈 것
Next > React > JavaScript ≥ HTML
⇒ 각각의 코어가 다음과 같다.
때문에 Next를 사용할 줄 알기 위해선 React를 사용할 수 있어야하고, React를 사용할 줄 알기 위해선 JavaScript를 사용할 줄 알아야 한다.
그렇다면, Next의 기능만 알아두도록 하자.
Next 튜토리얼을 한번쯤은 따라해보도록 합시다.
단 기능과 원리들을 파악하는 것이 최우선 과제.
⇒ 함수를 만드는 것을 모르면 아무것도 할 수 없다.
⇒ 늘 함수화를 잘 생각하자.
리액트 가상돔을 어째서 사용하는지도 알아두도록 하자.
⇒ 단방향 데이터 교류와 데이터 바인딩에 대해서도 알도록 하자.
⇒ 단반향 데이터 교류로 각 서버가 독립적으로 된다면, 서로간의 요청은 왜있는 것이지?
JavaScript를 작성하고 React로 변환해줘 ⇒ 이런식으로 가야합니다.
다 해부할 수 있느냐?
⇒ 결국 타입이건 리액트건 뭐던간에 모두 JavaScript로 컴파일 되는 것이다.
⇒ 그저 안전하고 쉽게 쓰기 위함일 뿐이다.
⇒ JavaScript를 잘 알도록 합시다.

URL: https://www.notion.so/7-fa776e51e6ca40ff926c581525d0c9c3
24/07/15
24/07/16
24/07/17

URL: https://www.notion.so/24-07-12-12161b7fb83047c19270d9126f813750
2팀 CyberFunc
3팀 주토피아
4팀 RockCorders
대표님 발언
⇒ 자료를 잘 올려주었다. 많이 보고 왔다.
⇒ 진도는 어느정도인지? ← 구현상황을 넣으면 좋을 것이다,
고생하셨습니다.
웹으로 서비스가 구현되는 것인지?
⇒ 아이템을 얻는 획득방법은 어떻게 구현할 예정인지?
⇒ 이미지를 클릭하여 반응을 이끌어내는 형태인가?
⇒ 멤버들의 백그라운드는?  
강사님 조회
통찰에 해당되는 카테고리
어려웠던 점
해결한 방안
역할 → 팀내의
문제해결능력
결론은 통찰력을 기르고, 자신이 한 것에 대한 것을 알아야한다.
⇒ 이것은 나중의 일이 아니라 지금의 일이다.
⇒ 중요한 것은 어떻게 할거냐? 의 일입니다.
연봉에 관하여
⇒ 현재 평균 연봉 2700~3000입니다.
⇒ 대기업에서는 차이가 날 수 있습니다.  ( 대기업은 복지에서 차이가 난다. )
⇒ 만약 연봉을 노린다면 스톡옵션( 회사 주식 받는 것 )이나 인센티브를 노려보세요.
중급개발자의 형태
⇒ 강사님기준
→ 당황하지 않는 사람. 무슨 이슈가 발생해도 의연하게 대처할 수 있는 사람.
⇒ 대표님 기준
→ 한 이슈가 발생했을 때, 그것을 듣고, 해결주기를 제시할 수 있는 사람.
개인적으로 가져갈 것.
ERP
⇒ ERP(Enterprise Resource Planning) 기업 자원 관리
product 판매! ( 유형일수도 무형일수도 있다. )
⇒ system이 관여
⇒ client에게 도달.
이 과정의 플랜 즉, 매니지먼트 시스템을 만들면 된다.
변동사항이 크지 않다면, 재고관리 시스템을 이용해서 예산을 짤 수 있다.
ex) 한달에 레스비가 몇번들 팔리는지에대해서 알면 ⇒ 1년의 수익을 예측할 수 있다.
장사 관리 시스템,
⇒ 지켜야할 표준은 무엇이 있는가?
⇒ 어떤 시스템이든 일반론이 있다.
재고라고 할 수 있는 것을 구분.
유형의 재고(물질적)와 무형의 시스템(서비스).
시스템의 경우 소비자와 맞닿아있는 영역.
리소스 형태가나와서 리소스를 관리하는 영역이 있어야 한다.
인적 자원 관리 ← ERP
ERP의 중요점!
프로젝트의 미션 : 
유형이든 무형이든 Resource는 존재해야한다.
비즈니스 모델. Business Model (BM)을 만들어 봅시다.
⇒ 우리는 판매가 이루어지도록 구축을 해주는 사람들입니다.
서비스의 형태는 웹서비스이다. 인터넷 망을 쓰는 서비스여야한다.
⇒ 서비스 관리?
Product System User를 고민하여 원할하게 만드는 것.
<Stack>
→ 유저와 시스템이 만나는 중간 단계는 Next.js 14버전으로 한다. ← front에 해당
→ Server는 선택해서 쓴다. 1. Nest.js를 쓴다. 2. FastAPI를 사용한다(프레임웤 파이썬)
⇒ 서버와 프론트를 완전히 격리할 것. Next내에 작은 서버가 있음. ← Next딴에서 따로 확인할것
⇒ Server를 교체해도 front는 움직이지 않고, front를 교체한다고 Server가 움직이지 않는다.
⇒Server에 DB를 굴린다. 하지만.
⇒DB Server와 Server를 격리한다. DB Server는 로그용. DB는 원하는 것 아무거나 사용하십시오 둘다 사용해도 둘 중 하나만 사용해도 됩니다.
각 front DBServer Server는 완전히 분리되어 있어야 한다. 
이는 AWS의 기조이기도하다.
⇒ Storage img혹은 src를 짱박아 놓는 저장소 욕할. 이 server또한 따로한다. 특정 코드를 응답한다.
Next.js는 랜더링만 한다.
Server는 Next.js에 Fetch로 준다.
? 그렇다면 Server는 무엇을 할까?
인력 분배 시스템, 유연한 분배 필요. ←
→ 유저와 시스템이 만나는 중간 단계는 Next.js 14버전으로 한다. ← front에 해당
→ Server는 선택해서 쓴다. 1. Nest.js를 쓴다. 2. FastAPI를 사용한다(프레임웤 파이썬)
⇒ 서버와 프론트를 완전히 격리할 것. Next내에 작은 서버가 있음. ← Next딴에서 따로 확인할것
⇒ Server를 교체해도 front는 움직이지 않고, front를 교체한다고 Server가 움직이지 않는다.
⇒Server에 DB를 굴린다. 하지만.
⇒DB Server와 Server를 격리한다. DB Server는 로그용.
각 front DBServer Server는 완전히 분리되어 있어야 한다.
이는 AWS의 기조이기도하다.
⇒ Storage img혹은 src를 짱박아 놓는 저장소 욕할. 이 server또한 따로한다. 특정 코드를 응답한다.
이것으로 다시 말해주십시오
Edit
네, 수정된 요구사항을 바탕으로 다시 정리해드리겠습니다:
프론트엔드:
Next.js 14 버전을 사용합니다.
사용자 인터페이스와 시스템 간의 중간 계층 역할을 합니다.
Next.js 내부의 작은 서버 기능은 별도로 확인하고 활용합니다.
백엔드 서버:
Nest.js (Node.js 기반) 또는 FastAPI (Python 기반) 중 선택하여 사용합니다.
프론트엔드와 완전히 격리되어 있습니다.
주요 비즈니스 로직과 API 엔드포인트를 처리합니다.
데이터베이스 서버:
백엔드 서버와 분리되어 있습니다.
주로 로그 데이터를 저장하는 용도로 사용됩니다.
스토리지 서버:
이미지나 소스 파일 등을 저장하는 전용 서버입니다.
다른 컴포넌트들과 분리되어 있습니다.
특정 코드로 응답하는 기능을 가집니다.
주요 특징:
모든 컴포넌트(프론트엔드, 백엔드 서버, DB 서버, 스토리지 서버)는 완전히 분리되어 있습니다.
각 컴포넌트는 독립적으로 교체하거나 업데이트할 수 있습니다.
이러한 구조는 AWS의 아키텍처 원칙과 일치합니다.
이 구조의 장점:
높은 모듈성과 유연성
개별 컴포넌트의 독립적인 스케일링 가능
유지보수와 업데이트의 용이성
각 부분의 성능 최적화 가능
보안 강화 (각 계층별 접근 제어 가능)
이 구조는 마이크로서비스 아키텍처의 원칙을 따르며, 클라우드 환경에서의 효율적인 운영을 가능하게 합니다.
CopyRetry
K
이 구조에서 백엔드 서버가 하는 역할은 무엇인지 제가 서버를 배우는 기초입문자라고 생각하고 설명해주십시오
Edit
네, 기초 입문자를 위해 백엔드 서버의 역할을 쉽게 설명해드리겠습니다.
백엔드 서버는 웹사이트나 앱의 '두뇌' 역할을 합니다. 사용자에게 보이지 않지만, 중요한 일들을 처리하죠. 주요 역할은 다음과 같습니다:
데이터 처리:
사용자가 입력한 정보를 저장하거나 불러옵니다.
예: 회원가입 정보 저장, 게시글 작성, 댓글 불러오기 등
API 제공:
프론트엔드(웹사이트나 앱)가 요청하는 정보를 제공합니다.
예: 상품 목록 조회, 사용자 프로필 정보 전송 등
비즈니스 로직 실행:
웹사이트나 앱의 핵심 기능을 수행합니다.
예: 주문 처리, 포인트 계산, 추천 시스템 등
보안 관리:
사용자 로그인 확인, 권한 체크 등을 수행합니다.
예: 비밀번호 확인, 관리자 페이지 접근 제어 등
외부 서비스 연동:
다른 서비스와 통신하여 필요한 정보를 가져옵니다.
예: 결제 시스템 연동, 지도 서비스 사용 등
데이터 유효성 검사:
사용자가 입력한 정보가 올바른지 확인합니다.
예: 이메일 형식 체크, 나이 제한 확인 등
로그 기록:
서버의 동작 상황을 기록합니다.
예: 오류 발생 시점, 사용자 활동 내역 등
데이터베이스 관리:
데이터를 저장하고 불러오는 작업을 관리합니다.
예: 회원 정보 조회, 게시글 저장 등
이러한 역할들을 통해 백엔드 서버는 웹사이트나 앱이 원활하게 작동할 수 있도록 지원합니다. 사용자에게 직접 보이지는 않지만, 모든 중요한 처리를 담당하는 핵심 부분이라고 볼 수 있습니다.
CopyRetry
K
그렇다면 Main Server는 브라우저의 요청을 받고, 각각의 Server에 요청을 보내는 형식입니까? 각각의 Server에서 하는 것은 그에대한 응답만 하는 것입니까? 이 점을 생각해서 저에게 다시 설명해주시겠습니까?
Edit
네, 좋은 질문입니다. 제가 이 구조를 고려하여 다시 설명해드리겠습니다.
이 아키텍처에서 Main Server (백엔드 서버)의 역할은 다음과 같습니다:
요청 수신 및 라우팅:
브라우저(프론트엔드)로부터 모든 요청을 받습니다.
요청의 종류에 따라 적절한 서비스로 라우팅합니다.
비즈니스 로직 처리:
주요 애플리케이션 로직을 실행합니다.
데이터 처리, 계산, 규칙 적용 등을 수행합니다.
서비스 조정:
데이터베이스 서버, 스토리지 서버 등 다른 서비스와의 통신을 관리합니다.
필요한 데이터를 요청하고 받아옵니다.
응답 생성:
처리된 결과를 바탕으로 프론트엔드에 보낼 응답을 생성합니다.
각 서버의 역할:
데이터베이스 서버:
로그 데이터 저장 및 조회 요청에 응답합니다.
Main Server의 요청에 따라 데이터를 제공하거나 저장합니다.
스토리지 서버:
이미지, 파일 등의 저장 및 제공 요청에 응답합니다.
파일 업로드, 다운로드 요청을 처리합니다.
작동 방식:
브라우저가 요청을 보냅니다 (예: 사용자 프로필 조회).
Main Server가 이 요청을 받습니다.
Main Server는 필요한 데이터를 확인합니다:
데이터베이스 서버에 사용자 정보를 요청할 수 있습니다.
스토리지 서버에 사용자 프로필 이미지를 요청할 수 있습니다.
각 서버(데이터베이스, 스토리지)는 요청받은 데이터만 응답합니다.
Main Server는 받은 데이터를 조합하고 필요한 처리를 합니다.
최종적으로 Main Server가 브라우저에 응답을 보냅니다.
이 구조의 장점:
각 서버가 특정 기능에 집중하여 효율성이 높아집니다.
개별 서버의 확장이 용이합니다.
보안 관리가 더 세밀해질 수 있습니다.
따라서, Main Server는 전체 시스템의 '조율자' 역할을 하며, 다른 서버들은 각자의 전문 영역에서 요청을 처리하고 응답하는 형태로 작동합니다.

URL: https://www.notion.so/24-07-10-8303b0ed81f04ba0a57c511b409b0f3c
여러가지 동작이나 변화가 많은 시점
⇒ 프로토타입 툴이 내 머리를 맑게 해줌.
구조 ‘만’ 볼 수 있다.
⇒ 위치나, 사이즈, 적용 여부도 미결정 상태
⇒ 복사해서 변화  (마치 다크모드)
figma 빠르게 쓰는 법! 개꿀 TIP!
Frame f키 기준으로 모두 잡혀있다.
→ 왼쪽 패널에 Layer개념을 통해서 부모자식관계를 확인할 수 있다.
확대 축소 
→ Ctrl + , -
→ Ctrl + 마우스 휠wheel
→space바를 누르면 이동 가능, 마우스 휠 눌러서도 가능.
container역할을 하는 Ractangle R
복제 alt + drag
create component - ctrl + alt + K
Grouping ctrl + G / ungrouping ctrl + shift + G
⇒ <div>을 만드는 행위.
⇒ 꼼꼼한 네임규칙과 꼼꼼한 그룹핑이 필요
어째서 리액트를 사용합니까?
⇒ 페이지 기준으로 따지자면 html을 사용하는게 맞습니다.
다만, 생산성을 생각했을 때, 리액트가 생산성이 더 좋은 경우가 있습니다. 그럴 때 리액트를 사용합니다.
개인 프로젝트는 기능적인 표현능력을 보여주는 것이 아니라면, 리액트가 필수가 아니다.
나 리액트 할 줄 알아요! 라고 의지표명을 하고 싶다면, 사용해야할 것이다.
다들 써서 써요! ← X!!!!
⇒ 내가 필요로 해서 씁니다. ← O!
내일은 가볍게 리액트 반복연습을 합시다.
⇒ 하면서 자신이 한 것을 브리핑하도록 합시다.
⇒ 무엇을 했는지 브리핑할 수 있도록 합니다.

URL: https://www.notion.so/24-07-09-8079f1f506b44e54bd50a00b81bc8fcf
아침마다 세팅할 것
⇒ 난 어떤 환경에서 작업하는게 좋더라
⇒ 그 중에 관심가는것은 이거더라. 
⇒ 그 이거라는 게 무엇인지 구체화할 것.
⇒ 좋아하는 분야의 도메인이 계속된다면 plan A와 B정도는 될 것이다.
TIP
⇒ 어차피 포트폴리오는 따로 안본다.
면접느낌.
github → 이 작업에 대해 설명해줄래요?
⇒ 눈치챌만한 것을 물어보는 편
6개월 → 회사에서도 이미 학원출신들이 많음. 
→ 인사이트를 숨길 수 없음.
→ 학원 교육방식의 문제점도 알고있음. 
→ 어느정도 한다. 까지 알고있음. 
→ 예제 위주 → 아에 안봄.
⇒ “스스로 뭘 해본 경험이 남아있다면” ★ ← 거진 성공.
완성 + 설명 = 포트폴리오. 
→ 내가 완성한 무언가가 있고, 그것에 대한 설명이 들어있어야 한다.
팀작업 내역 + 개인 기록 = 어떤접근을 하였는가.
→ 생각을 안하는 사람들을 걸러낸다.
내역을 다 공개하기 때문에 - 볼륨이 얼만큼인지 다들 알 수 있다.
→ 국비학원의 인식이 좋지 않다. 그래서! +교육의 질 ⇒ 완전 공개를 결정함.
git 못하는 사람들 80%는 못함.
배포경험 - github, aws, gcp
→ 포트폴리오는 열심히 만들었는데, 배포경험이 없음
→ 개인명함 + 블로그 정도는 있어야죠?
→ 지금 만드는 디펜스게임을 이야기하는 블로그정도는 만들어보도록 합시다.
→ 관리 형태 1000원 11000원
사업자등록 - 3시간
수료를 기준으로 취업을 노리는 사람은 100일정도 남았습니다.
⇒ 카운트 다운을 걸어도 됩니다. 
⇒ 기분좋은 시작을 할 수 있는 적정시기입니다.
github build and deployment
⇒ 사용자 유치를 위해서 간단한 정적페이지 정도는 호스팅 - host + ing해준다.
github가 서버역할을 대신하여 웹서버 역할을 한다.
→ 최상위 index.html파일을 올려두면 거기에 대한 요청은 받아주겠다.
⇒ <a href=#></a>은 안됩니다. react로 SPA 번들링 잘 된거로 하면 마치 application처럼 쓸 수 있습니다.
⇒ 멀티페이지 방식은 못해도, 간단한 싱글페이지로는 가능하다.
이런것을 일반적으로 Platform as a Service라 고 하여 PaaS라고한다.
⇒ 우리의 최종목적지는 IaaS입니다. 
→ rinux에 node를 설치하고 이것저것 설치해서 짠하고 만들거에용
React는 누군가가 이미 써놓은 코드이기 때문에 자유롭지 않다. 하지만 안정적이다.
⇒ 뉘앙스는 따라주자.
index.tsx ← 일반적으로 CRA를 사용하면 index.tsx를 생성한다. entry포인트가 index.tsx인것
React 기본 default코드
import React from 'react'

const App : React.FC = () => {
  return ()
}

export default App
해당 코드는 고정입니다. ← 프레임워크를 따라하는중.
react v18
함수 리턴 부분에 소괄호()안에 XML방식(<>)으로 작성이 가능하다.
→ 일반 HTML도 호환이 되고, (XML방식을 HTML이 따라한 것) 
→ 우리가 만드는 컴포넌트도 호환이 된다.
때문에 일련의 약속들이 존재.
return (
 <h1>안녕?</h1>
)
React.FC이란? React Function Component
리액트가 쓴 인터페이스이다.
⇒ import React 안에 들어있는 interface
⇒ 완성도 높은 인터페이스를 쓸 수 있게된다.
에러를 통해서 검색량을 줄일 수 있게되었다.
⇒ 이것은 TypeScript의 힘이다.
에러를 발견하면, 리액트 개발자 가이드가 나타남.
import React from 'react'

const Minam = () => {
  return (
    <h1>미남은 당연히 공욱재</h1>
  );
}

const App : React.FC = () => {
  return (
    <div>
      <Minam />
      <h1>안녕?</h1>
    </div>
  )
}

export default App
⇒ 함수호출을 꺽쇠를 사용한다. <Minam />은 함수를 호출한 것
⇒ 그리고 jsx파일은 항상 부모가 있어야 한다. 그래서 div태그를 생성한 것.
⇒ 리액트의 규칙이다.
app.tsx는 조립하는 용도
index.tsx는 렌더만 한다. innerHTML역할을 하는 것.
app.tsx의 파일의 Minam함수에 변수를 뚫어보자.
import React from 'react'

interface textNode {
  textNode : string;
}

const Minam : React.FC<textNode> = ({textNode}) => {
  return (
    <h1>{textNode}</h1>
  );
}

const App : React.FC = () => {
  return (
    <div>
      <Minam textNode="공욱재" />
      <h1>안녕?</h1>
    </div>
  )
}

export default App
React에서는 매개변수를 사용하려면 {}로 감싸주어야 한다.
⇒ Minam은 React.FC타입의 interface로 지정한 textNode를 사용한다.
변수를 할당할때는 매개변수를 적고 값을 입력한다.
⇒ 실제 데이터를 이렇게 보내지는 않는다
그렇다면 실제데이터는 어떻게 보낼까?
⇒ static이란 directory를 생성한다.
ul태그를 만들어보았다.
import LiTag from './liTag'
import itemOne from "../static/li_data_one"
import itemTwo from "../static/li_data_two"
import itemThr from "../static/li_data_three"

const ulTag : React.FC = () => {
  return (
    <ul>
      <LiTag text={itemOne} />
      <LiTag text={itemTwo} />
      <LiTag text={itemThr} />
    </ul>
  )
}

export default ulTag
interface content {
  text : string
}

const liTag : React.FC<content> = ({text}) => {
  return (
    <li>{text}</li>
  );
}

export default liTag
중요한 점을 알 수 있다.
React식으로 함수를 호출하기 위해서는 앞글자를 대문자를 사용해야한다. 그렇지 않으면 JSX형식과 맞지 않다고 하여 오류가 발생한다.
중요한 점 
매개변수를 사용할 때는 중괄호를 사용한다.
import하여 함수를 호출할 때 앞글자는 대문자를 사용한다.
interface를 활용하여 매개변수의 타입을 지정해주면 편하다.
타입을 지정해줄 때는 React.FC<interface> = ({argument})의 형태를 띈다. 
⇒ interface content {text : string}이라고 한다면 React.FC<content> = ({text})이런식.
해볼만한 것.
React에서 반복문 사용하기.
figma
command입니다!
F ⇒ 탬플릿 생성 
R⇒ 사각형생성  
T⇒ text박스 생성 
Ctrl + g ⇒ 그룹화
Alt + 마우스 좌클릭 ⇒ 복사
space ⇒ 이동.
ctrl alt K ⇒ 컴포넌트화 틀리다면 찾아볼 것. 컴포넌트화 하면 꽉찬 마름모는 컴포넌트 빈마름모는 인스턴스가되어 컴포넌트를 수정하여 인스턴스가 한번에 변경이된다.
여기까지 보았을 때, 지금 내가 해야하는 것은 무엇일까요?
⇒ typescript를 사용하는 것은 무조건입니다.
⇒ component를 사용해보니 간단한 것 같은데요 페이지 구성을 모두 만들어보세요.
⇒ 더 편한건 뭐지? 더 좋은건 뭐지?
Component를 설계하는 과정을 해보세요!

URL: https://www.notion.so/24-07-08-962b2427e47940d0b13ead3bb507c810
개발도구 어쩌구 하는 것들.
typescript
babel
react
css - tailwindCSS
node.js
webpack ★ ← 1번부터 5번까지의 모든 작업은 webpack으로 핸들링이 가능하다.
webpack.config.js
prompt엔지니어링의 Tip
⇒ 내가 원하는 바를 나름의 수치화를 한다.
ex) 
1. typescript2. babel3. react4. css - tailwindCSS5. node.js6. webpack★위 6번까지 프로젝트에 수동으로 설치하고 싶어.많은 설치가 있는 것을 알고 있어. 하지만 이해를 위해서 한번 도전해보려고 해여러개의 설정이 있는 것들을 순서대로 내가 따라할 수 있도록 도와줘너는 나의 선생님이 되어서예를 들어, 1. typescript의 설치 패키지과 설정방법들을 알려줘
10:34
공욱재
이 난이도는 내가 느끼기에 총 10점중에 7점정도 되는 것 같아, 나는 1점 난이도를 원해
⇒ 총점이 10점이면 어떻게~
⇒ 그냥 모르겠어 X / ~를 모르겠어 ← 단어 선택이 굉장히 중요하다.
React, v18 → react.dev
→ 리액트는 업데이트 주기가 어마어마하게 빠름.
→ API DOC, 정성을 들여서 볼 줄 알아야 함.
→ create-react-app : 프레임워크 ← 모든게 설치되어 있음. : 아직까지는 사용 X
프레임 워크란?
 ⇒ 특정한 목적을 가진 라이브러리들의 모음.
→ 기가막힌 고수들이 버그 다잡아내서 애플리케이션만드는데 하등 쓸데없는 것 쓰지 말라고 모든 것이 셋업이 되어있는 도구.
—> 서빙까지 다 설치되어있어서 할게 없다.
그렇기 때문에 우리는 라이브러리를 조립해서 쓴다. : 포트폴리오의 차별점이 되어줄 수 있다.
라이브러리는 어떻게 쓰든 상관이 없다! 
그저, 코드 모음집일 뿐, ‘뚜렷한 목적이 없음!’
라이브러리로 봤을 때 리액트는 우리들에 한해서 매우 쉽다!
리액트 라이브러리 react
→ 바닐라 자바스크립트를 묶은 거라
→ 바로 번역이 가능하다.
프레임워크는 해체하는데 손이 좀 간다.
→ 상당히 안정적인 버전(버그가 좀처럼 없음.)
→ 상대적으로 라이브러리보다 규칙이 많은편.
node와 nodeExpress의 차이점을 알아야 하는 것처럼 프레임워크와 라이브러리를 경계하면서 사용해야 한다.
프레임워크를 먼저 배우면? ⇒ 생산성에서는 압도적.
→ 실무에서는 쓸모 X
→ 열에 아홉은 뜯어서 커스텀 한다.
→ 회사입장에서는 ‘회사 내부용 라이브러리’가 따로있다.
react를 설치하는 법을 압시다!
react-dom(웹 문서용)을 설치하는 법을 압시다! ← 웹앱만들꺼야!
react-native (모바일 앱)을 설치하는 법을 압시다! ← 모바일 네이티브 앱용
load : 적재하다. 싣는다. 데이터를 싣는
loading : 적재하는 중 === RAM에 담는중
reading한다고도 한다. ← post방식으로 할 때, body에 chunk를 쌓는 과정을 겪었던 것처럼.
데이터를 RAM에 읽어들이는 중
웹팩‘에’ 타스’를’ 끼우는 작업.
웹팩’만’ 돌리게 될 것.
⇒ ts를 따로 컴파일하지 않음.
webpack.config.js의 키워드! 4가지
module {} → rules [] → {} → test, use, exclude 
resolve
개발환경 설정이 매우 복잡하다!
⇒ 외울 것은 아니기 때문에, 맥락만 알면된다!! ← 절대로 외우는 것이 아님!!!
webpack에 무언가를 끼운다. “loader” ←★☆로더개념을 이해할 것 외운다면 로더만 외우면 된다.
→ 아주 빈번하게 loader를 설치하는 경우가 많다.
@babel/core, @babel/preset-env ←정도만 설치하면 되게 바뀜!
⇒ preset-typescript는 react가 해주고 cli는 webpack이 있다.
+babel-loader까지.
웹펙의 주요 키중 하나인 module의 아래에 rules를 사용하고 있음.
rules는 아래부터 읽어낸다. [맨 마지막 원소가 ‘가장 먼저 읽히는 놈이 된다.’]
⇒ 그래서 ts를 맨 마지막으로 옮긴것.
⇒ ts를 js로 변경하고 js를 env환경에 맡게 변경시켜야 한다.
⇒ rules는 마지막에서 첫번째로 동작하는 특징을 가지고 있음을 잊지 말자.
rules : [’babel’,’ts’]
명령어 build:dev mode : development로 bundle, build:prod mode:production으로 bundle
React
⇒ 설치 —save-dev가 아님. 그냥 install
npm install react
npm install react-dom // 나 문서에서 react 쓸꺼야 라는 패키지
→ babelrc 파일 변경
typescript 읽고, react 읽고, env로 변환.
webpack.config.js에 resolve 추가.
react 전용 확장자. 
⇒ jsx : javascript XML이라는 뜻
⇒ XML표기법으로 자바스크립트를 쓰겠다.
⇒ tsx : typescript XML
⇒ XML표기법으로 typescript를 쓰겠다.
XML?? ⇒ HTML의 원형
React를 태그방식으로 쓰는 것이 바로 이 방식을 따라한 것.
최종 webpack.config.js파일 ← 현재 상황 react설치
const path = require('path');

let name = 'app'

module.exports = {
  entry : `./src/${name}.tsx`,
  output : {
    path : path.resolve(__dirname,'dist'),
    filename : `${name}.bundle.js`
  },
  module : {
    rules : [
      {
        test: /\.(js|jsx|ts|tsx)$/, 
        use : 'babel-loader',
        exclude : /node_modules/
      },
      {
        test: /\.tsx$/, // 타스인지 확인할 거야.
        use : 'ts-loader',
        exclude : /node_modules/
      },
    ]
  },
  resolve : {
    extensions : ['.ts','.js','.tsx','.jsx']
  }
}
react설치기준 package.json
{
  "name": "bundleprac_2",
  "version": "1.0.0",
  "description": "\"7월8일 수업\"",
  "main": "./dist/app.bundle.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build:dev": "webpack --mode=development",
    "build:prod": "webpack --mode=production"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/KimInteger/bundlePrac_2.git"
  },
  "author": "KimInteger",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/KimInteger/bundlePrac_2/issues"
  },
  "homepage": "https://github.com/KimInteger/bundlePrac_2#readme",
  "devDependencies": {
    "@babel/core": "^7.24.7",
    "@babel/preset-env": "^7.24.7",
    "@babel/preset-react": "^7.24.7",
    "@babel/preset-typescript": "^7.24.7",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "babel-loader": "^9.1.3",
    "ts-loader": "^9.5.1",
    "typescript": "^5.5.3",
    "webpack": "^5.92.1",
    "webpack-cli": "^5.1.4"
  },
  "dependencies": {
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  }
}
tsconfig.json에 jsx찾아서 react-jsx로 주석 해제하기.
import React from 'react';
import ReactDOM from 'react-dom/client';

// React는 컴포넌트를 작성할 때 대문자를 먼저쓰는 특징이 있다. 
// 자바스크립트지만 소괄호를 쓰는 특징이 있다.
const App : React.FC = () => {
  return (
    <div>
      <h1>Hello, World!</h1>
    </div>
  )
}

const root = ReactDOM.createRoot(document.getElementById('root')!);
root.render(<App />)
app.tsx코드
최종의 최종 package.json
{
  "name": "bundleprac_2",
  "version": "1.0.0",
  "description": "\"7월8일 수업\"",
  "main": "./dist/app.bundle.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build:dev": "webpack --mode=development",
    "build:prod": "webpack --mode=production"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/KimInteger/bundlePrac_2.git"
  },
  "author": "KimInteger",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/KimInteger/bundlePrac_2/issues"
  },
  "homepage": "https://github.com/KimInteger/bundlePrac_2#readme",
  "devDependencies": {
    "@babel/core": "^7.24.7",
    "@babel/preset-env": "^7.24.7",
    "@babel/preset-react": "^7.24.7",
    "@babel/preset-typescript": "^7.24.7",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "babel-loader": "^9.1.3",
    "css-loader": "^7.1.2",
    "style-loader": "^4.0.0",
    "ts-loader": "^9.5.1",
    "typescript": "^5.5.3",
    "webpack": "^5.92.1",
    "webpack-cli": "^5.1.4"
  },
  "dependencies": {
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  }
}
npm install --save-dev css-loader style-loader
css-loader : 모듈로 변환 해주는 놈
style-loader : DOM으로 넣어주는 애.
⇒ react 쓰고 나서부터 다시 CSS를 사용한다.
⇒ 자동으로 script를 작성해주기 때문이다.
최종의 최종 webpack.config.js
const path = require('path');

let name = 'app'

module.exports = {
  entry : `./src/${name}.tsx`,
  output : {
    path : path.resolve(__dirname,'dist'),
    filename : `${name}.bundle.js`
  },
  module : {
    rules : [
      {
        test: /\.css$/,
        use : ["style-loader","css-loader"], // 순서 중요 css가 읽히고 style이 읽혀야 한다. script화 이후 DOM으로 넣어주기
      },
      {
        test: /\.(js|jsx|ts|tsx)$/, // 자스인지 확인할 거야.
        use : 'babel-loader',
        exclude : /node_modules/
      },
      {
        test: /\.tsx$/, // 타스인지 확인할 거야.
        use : 'ts-loader',
        exclude : /node_modules/
      },
    ]
  },
  resolve : {
    extensions : ['.ts','.js','.tsx','.jsx','.css']
  }
}
css-loader과 style-loader를 추가.
여기까지 한 것이 일종의 프레임워크를 만드는 행위였습니다.

URL: https://www.notion.so/7-1e34f24f5de2486ebaaf8ec70caa6ae6
24/07/08
24/07/09
24/07/10
24/07/12

URL: https://www.notion.so/24-07-05-e439ec323c514d9a96614cb304de18b4
수치화를 해야합니다.
12시간을 사용한다고 생각하십시오. ⇒ 그리고 자신이 쓰는 비용을 지금 점검해보십시오.
그것을 수치화 해야합니다. 수치화를 해보아야 얼마가 필요한지 가늠을 할 수 있습니다.
생활비용을 생각해보세요. 그것을 가지고 12시간을 꾸릴 수 있습니다.

URL: https://www.notion.so/24-07-04-492764c38c41473da04893786ac15ed6
원티드!
⇒ 이직을 장려합니다!
저희가 보아야 할 것은 개발, 광고, 디자인 쪽입니다.
⇒ UX디자이너, UI,GUI디자이너 웹 디자이너 등
⇒ 개발 PHP개발자와, 웹 퍼블리셔는 피하도록 합시다.
만약, 나는 머리쓰는게 싫어요. 그냥 반복되는 일상이나 가질래요.
⇒ 시키는 거만 할래요~ 머리쓰지말고, 영혼 실지말고, 웹 퍼블리셔하시면됩니다.
⇒ PHP쓰시면 된다. 대신 도전적인 신기술을 사용하면 안된다. 회사의 벽을 치는 형태가 될 것
주말동안 플랜 A, B, C, D를 세워보세요!
Plan A! 
→ 내가 좋아하는 분야 + 괜찮은 연봉 + 욕심이 나는 스킬들 + 워라벨 퇴근을 잘하는
Plan B! 
→ 내가 좋아하는 분야기는 한데, 나머지가 조금 약하네..
→ A가 안되면 바로 선택할 수 있는 것. 계속 A를 붙잡고 있으면 안된다. A가 안됬다면 바로 B를 시도하도록 하자.
Plan C!
→  ‘개발영역 근처’의 일이지만 좋아하지도, 재미있지도 않음
→ 당장에 먹고살아야하기 때문에 하는 선택
Plan D!
→ 새로운 강의 수집
⇒ 해당 플랜에 맞은 회사들을 찾아서 해봅시다.
⇒ 뭐가 있을까?
A. Neople, Smilegate, NEOWIZ
B. 
비용 : 내가 어설프게 선택하면, 꽤나 많이 고달파질 것이다. 
⇒ 절대로 뭉뚱그리지 말 것, 정말로 철저하게 따져볼 것, 노는 것은 없다. 그건 일하기 싫은거지.
⇒ 고로, 힘든 것은 당연하다고 생각하고, 워라벨을 챙기고싶다면 야망을 품어야 할 것이다. 남들보다 많이 쉬고 싶다면, 아주 수준 높은 것을 해야하는 것은 당연한거다. 그리고 그에따른 책임은 항상 따라오는 법이다. → 책임! 매우 중요한 요소이다.
Location API
window → location(document와 형제관계)
location.hash를 사용하는 중.
hash란? ‘고유의 무언가’ → 일종의 식별자로 사용됨.
event가 window에서 걸린다는 것이 핵심이다. 브라우저레벨에서 발동됨.
⇒ 그동안의 경우 ‘문서’에서 이벤트를 걸었다 . document.addEventListener등등
브라우저level의 이벤트에는 무엇이 있나요?
⇒ 3초후에는 이것을 실행해 같은것들이 browser level의 이벤트입니다.
이것을 하기 시작하면서 저희는 SSR에서 CSR로 넘어가게됩니다.
Server Side Rendering ⇒ Client Side Rendering
SSR → 예전에는 요청이 오면 서버에서 문자열을 조랍한다음 ⇒ 응답.
CSR → 이제는 안에 다 숨어있는 상태로 ‘이벤트’형식으로 랜더링
“웹펙"이란? 뭐징?
웹펙이란. 버전관리 도구 git과 svn처럼 번들러라는 것입니다.
번들러로 webpack, vite, rollup등이 있습니다.
설정하고 수동으로 작업하는 것에서는 webpack이 우위를 갖고있습니다.
npm install —save-dev webpack
npm install —save-dev webpack-cli
new-item webpack.config.js ←정의파일을 만들어 주어야 한다.
// webpack.config.js
const path = require('path');

module.exports = {
 entry : "",
 output : {
  path : path.resolve(__dirname, 'dist'),
  filename : "menu.bundle.js"
 }
}
타입스크립트를 번들링하려면?
npm install —save-dev ts-loader
const path = require('path');

module.exports = {
  entry: '/src/import.ts',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js',
  },
  module: {
    rules: [
      {
        test: /\.ts$/,
        use: 'ts-loader',
        exclude: /node_modules/,
      },
    ],
  },
  mode: 'development',
  resolve: {
    extensions: ['.ts', '.js'],
  },
};
붕어빵을 판다고 생각해보자. 붕어빵 장사는 어떻게 일어나고 어떤 구조가 형성되어 있을까요?
문화 ⇒ 본사 ⇒ 슈퍼바이저 ⇒ 소매 ⇒ 클라이언트.
붕어빵을 소비하는 문화가 있기 때문에 붕어빵을 가지고 장사를 시작할 생각을 품었을 겁니다.
본사는 재료의 공급 및 기계와 관리가 필요합니다.
⇒ 책임을 져야하는 직위입니다.
 슈퍼바이저가 본사에서 파견된 직원으로 관리를 담당합니다.
⇒ planer입니다. 플랜을 짜는 역할을 합니다. ← 상당히 머리가 아플 것 입니다.
소매는 슈퍼바이저와 계약하여 가게를 엽니다.  실력은 천차만별입니다.
⇒ 수행하는 것이 속합니다. operating! ← GPT에게 뺏겼습니다.
소비자는 구매하기만 합니다.
그렇다면, 나는 어떤것을 하고 싶습니까?
⇒ 강사님은 저희가 모두 1번을 목표로 했으면 좋겠다고 이야기합니다.

URL: https://www.notion.so/24-07-03-5fd831cb51634178a567d8a63bdb604d
남다른 전략!
작업을 꾸준히 하는 것, 여러분은 바쁜것이 아니라 머리가 복잡한 것입니다.
⇒ 여러분은 전부다 해야합니다.
⇒ 급여가 바뀌는 것, 연봉이 바뀌는 것은 이러한 꾸준함에서 나옵니다.
⇒ 스케줄링을 소홀히 하고 있지는 않습니까? ← 맞아요!!!
⇒ 그렇다면 문제가 있습니다. 다시한번 점검하는 시간을 가지시고, 개인작업도 계속 하셔야 됩니다.
⇒ 어째서 하지 않습니까? → 왜 안할까? 고민을 해봐야 할 법한 문제일까? 아니라고 생각하는데?
→ 안하는 이유는 별거 아니다. 내가 힘들다고 느끼고 있다. 근데 이게 진짜 힘든가? 힘든게 아니라 하기 싫다의 개념으로 가고 있구나, 근데 실제로 싫은 것은 아니야. 그냥 내가 부족함을 느끼는 것이지 그냥 일단 해봐야해. 스케줄링 할 시간이다.
보상은 원래 바로 오지 않는 법입니다.
⇒ 보상을 바라지 않고, 하다보면 결국 다가오는 것이 보상입니다.
typescript는 다른 언어의 장점을 가져다 만든 것이기 때문에 매우 좋습니다.
⇒ 물론 근본이 되는 언어의 한계를 극복하진 못합니다만,
typescript의 이해도가 높다는 것은 enum이라는 것을 알면 좋습니다.
소개 페이지 작성할 것.
⇒ 모듈에서 시작되어 → TSC → babel → bundle → react순으로 할 것입니다.
모두 새로운 알고리즘이 들어가는 것이 아닌 소프트웨어를 이해하는 것이기 때문에 어려운 개념이 아닙니다.
이것을 모두 익히면 바닐라JS를 그때 부턴 사용하지 않을 것입니다.
금일 수업 시작
강사님의 목표
typescript → 컴파일링 환경 만들기. typescript, ts-node, @(플러그인)types/node
babel → @babel/core @babel/cli @babel/preset-env @babel/preset-typescript
⇒ 트랜스파일링 환경이 있다.
2-1. 모든 길은 바벨로 통한다. react, ts뭐뭐 할 것 없이 모두 바벨을 통한다.
2-2. 바벨을 마음껏 설치하는 정도 까지‘만’ 알면 됩니다.
⇒ 그 단계가 설정이 필요합니다.
2-3. 설정할 것이 많다 = ‘자유롭다’라는 의미입니다.
tsc ⇒ 단순히 js를 만드는데 국한되어 있다. 단순히 js변환용이다. 호환성과는 관계가 멀다.
호환성이 상당히 예민한 문제였다. 
→ 여전히 서비스레벨에서는 다루어야 한다.
babel ⇒ CSS도 포함시킬 수 있다. 포함시켜서 JS로 변환이 가능하다.
강사님의 목표 
타스 컴파일 따로
바벨 컴파일 따로
⇒ 이후 두개를 합쳐!
babel의 구조 = 설정은 개발자의 몫
@babel/core : 엔진 → 엔진만 있습니다. 따로 기능은 x
@babel/cli : cli환경에서 핸들링 하고 싶어서 → 엔진 핸들링
npx babel —help ⇒ npm 에 있는 babel쓰려고하는데 뭔지 모르겠어 알려줘. + GPT가 있다면 무서울게 없다.
옵션/명령어
설명
사용 예시
-f, --filename [filename]
표준 입력으로부터 읽을 때 사용할 파일 이름. 소스 맵, 오류 등에 사용됩니다.
babel input.js -f customname.js
--presets [list]
프리셋 이름의 쉼표로 구분된 목록을 지정합니다.
babel input.js --presets @babel/preset-env,@babel/preset-react
--plugins [list]
플러그인 이름의 쉼표로 구분된 목록을 지정합니다.
babel input.js --plugins @babel/plugin-transform-arrow-functions
--config-file [path]
사용할 .babelrc 파일의 경로를 지정합니다.
babel input.js --config-file ./config/.babelrc
--env-name [name]
구성 및 플러그인을 로드할 때 사용할 'env' 이름을 지정합니다. 기본값은 BABEL_ENV, NODE_ENV, 'development'입니다.
babel input.js --env-name production
--root-mode [mode]
프로젝트 루트 해상도 모드를 지정합니다. 'root', 'upward', 'upward-optional' 중 하나입니다.
babel input.js --root-mode upward
--source-type [script|module]
소스 타입을 스크립트 또는 모듈로 지정합니다.
babel input.js --source-type module
--no-babelrc
.babelrc 및 .babelignore 파일을 참조하지 않도록 설정합니다.
babel input.js --no-babelrc
--ignore [list]
컴파일하지 않을 glob 경로 목록을 지정합니다.
babel input.js --ignore node_modules
--only [list]
컴파일할 glob 경로 목록을 지정합니다.
babel input.js --only src
--no-highlight-code
코드 프레임의 ANSI 구문 강조를 활성화하거나 비활성화합니다. 기본적으로 활성화되어 있습니다.
babel input.js --no-highlight-code
--no-comments
생성된 출력에 주석을 작성합니다. 기본값은 true입니다.
babel input.js --no-comments
--retain-lines
줄 번호를 유지합니다. 이 옵션은 코드의 가독성을 저하시킬 수 있습니다.
babel input.js --retain-lines
--compact [true|false|auto]
불필요한 공백 문자와 줄 구분자를 포함하지 않습니다.
babel input.js --compact true
--minified
출력 파일을 최소화합니다. 기본값은 false입니다.
babel input.js --minified
--auxiliary-comment-before [string]
사용자 코드가 아닌 삽입된 코드 앞에 주석을 작성합니다.
babel input.js --auxiliary-comment-before "/* My Comment */"
--auxiliary-comment-after [string]
사용자 코드가 아닌 삽입된 코드 뒤에 주석을 작성합니다.
babel input.js --auxiliary-comment-after "/* End Comment */"
-s, --source-maps [true|false|inline|both]
소스 맵을 생성할지 여부를 지정합니다.
babel input.js -s true
--source-map-target [string]
반환된 소스 맵에 'file'을 설정합니다.
babel input.js --source-map-target output.js.map
--source-file-name [string]
반환된 소스 맵에 'sources[0]'을 설정합니다.
babel input.js --source-file-name input.js
--source-root [filename]
모든 소스가 상대적인 루트를 설정합니다.
babel input.js --source-root src
--module-root [filename]
AMD 모듈 포매터의 선택적 접두사를 설정하여 모듈 정의 시 파일 이름 앞에 추가합니다.
babel input.js --module-root /src
-M, --module-ids
모듈에 명시적 id를 삽입합니다.
babel input.js -M
--module-id [string]
모듈 id의 사용자 정의 이름을 지정합니다.
babel input.js --module-id customModule
-x, --extensions [extensions]
디렉터리가 입력된 경우 컴파일할 확장자 목록을 지정합니다. 기본값은 [.js,.jsx,.es6,.es,.mjs,.cjs]입니다.
babel input --extensions .ts,.tsx
--keep-file-extension
입력 파일의 확장자를 유지합니다.
babel input.js --keep-file-extension
-w, --watch
파일 변경 시 다시 컴파일합니다.
babel input.js -w
--skip-initial-build
감시하기 전에 파일을 컴파일하지 않습니다.
babel input.js --skip-initial-build
-o, --out-file [out]
모든 입력 파일을 단일 파일로 컴파일합니다.
babel input.js -o output.js
-d, --out-dir [out]
모듈의 입력 디렉터리를 출력 디렉터리로 컴파일합니다.
babel src -d dist
--relative
입력 디렉터리 또는 파일에 상대적으로 출력 디렉터리에 컴파일합니다. --out-dir [out]가 필요합니다.
babel src --out-dir dist --relative
-D, --copy-files
디렉터리를 컴파일할 때 컴파일되지 않는 파일을 복사합니다.
babel src -d dist -D
--include-dotfiles
점 파일을 컴파일 및 복사할 때 포함합니다.
babel src -d dist --include-dotfiles
--no-copy-ignored
컴파일되지 않는 파일을 복사할 때 무시된 파일을 제외합니다.
babel src -d dist --no-copy-ignored
--verbose
모든 로그를 기록합니다. 이 옵션은 --quiet와 충돌합니다.
babel src -d dist --verbose
--quiet
로그를 기록하지 않습니다. 이 옵션은 --verbose와 충돌합니다.
babel src -d dist --quiet
--delete-dir-on-start
컴파일을 시작하기 전에 출력 디렉터리를 삭제합니다.
babel src -d dist --delete-dir-on-start
--out-file-extension [string]
출력 파일에 특정 확장자를 사용합니다.
babel src -d dist --out-file-extension .mjs
-V, --version
버전 번호를 출력합니다.
babel -V
-h, --help
명령어의 도움말을 표시합니다.
babel -h
babel config파일
⇒ .babelrc와 babel.config.json을 사용합니다.
⇒ 커뮤니티에서는 보통 .babelrc를 사용합니다(숨김파일처리)
→ rc의 의미는 run command의 줄임말입니다.
npm install —save-dev @babel/preset-env
⇒ 낮은 버전으로 하위호환이 가능해진다.
‘버전’에 대한 인식.
낮은 버전 vs 높은 버전
⇒ 높은버전은 훌륭한 기능이 추가되고, 유용한 기능이 많을 것이다. 하지만 문제점은 버그가 발생할 수 있다.
⇒ 낮은 버전은 편의성은 떨어지지만, 매우 안전된 검증된 버전이다.
babel.config파일 설정법.
파일을 연다.
객체를 생성하고, presets를 설정
⇒ 아까 설치한 @babel/preset-env를 추가한다
env란? environment(환경)을 의미한다. ← 우리가 안만들어도 되게끔, 검증된 형태로 제공하고 있다.
preset = 사전 설정이다. pre - set
해당 모듈을 설치하고 .babelrc에 키워드를 입력하면 컴파일이 실행된다.
내가 작성한 코드는 const지만 var로 컴파일이 되어있는 모습을 확인할 수 있다.
하지만 컴파일이 되는것만 봐서는 의미가 없다. 이것이 저장이 되어야 한다. 저장은 어떻게 할 수 있을까?
바벨에서는 -o라는 커맨드를 사용하여 컴파일한 파일을 생성할 수 있다.
npx babel 입력할파일이름 -o 출력할파일이름  ← -o는 out을 의미하는 플래그이다. 상기 표를 확인할 것.
바벨을 거치는 파일들은 관용적으로 이런식으로 사용한다 다음은 예시이다.
npx babel app.js -o app.babel.js ← 입력파일이름.babel.확장자
바벨로 컴파일 하는 것을 바벨 컴파일이 아닌 바벨 트랜스파일링이라고 한다.
use strict가 의미하는 것은 무엇일까?
"use strict" 구문은 실제로 코드에 중요한 영향을 미칩니다. 이 구문이 삽입되는 이유와 그 효과에 대해 설명해 드리겠습니다.
"use strict"의 목적:
이 구문은 JavaScript의 strict mode를 활성화합니다. Strict mode는 더 엄격한 구문 규칙을 적용하여 코드의 안정성과 보안성을 높입니다.
주요 효과:
선언되지 않은 변수 사용 금지
삭제할 수 없는 속성 삭제 시도 시 에러 발생
함수 매개변수 이름의 중복 금지
8진수 리터럴 사용 금지 (ES6에서는 다시 허용)
with 문 사용 금지
변수나 함수를 삭제하려는 시도 금지
왜 Babel이 이를 삽입하는가:
호환성: Strict mode는 ES5에서 도입되었습니다. Babel은 최신 코드를 ES5로 변환하므로, strict mode를 명시적으로 활성화합니다.
안전성: Strict mode는 잠재적인 오류를 줄이고 더 안전한 코드 실행을 보장합니다.
최적화: 일부 JavaScript 엔진에서 strict mode 코드가 더 빠르게 실행될 수 있습니다.
예시:
Strict mode가 없을 때:

Strict mode에서:
javascript
Copy
x = 3.14;// 암묵적 전역 변수 생성
javascript
Copy
"use strict";
x = 3.14;// ReferenceError: x is not defined
모듈 시스템에서의 자동 적용:
ES6 모듈을 사용할 때는 자동으로 strict mode가 적용됩니다. 하지만 Babel이 이를 CommonJS 형식으로 변환할 때 명시적으로 "use strict"를 추가합니다.
요약하면, "use strict"는 코드의 안정성과 품질을 높이기 위해 Babel이 자동으로 삽입하는 중요한 구문입니다. 이는 코드 실행에 실질적인 영향을 미치며, 잠재적인 오류를 사전에 방지하는 데 도움을 줍니다.
타입스크립트에서 사용하도록, presets을 추가합니다.
{
  "presets": ["@babel/preset-env","@babel/preset-typescript"]
}
해당 프리셋은 순서가 중요합니다. 뒤부터 읽기 때문에 타입스크립트를 JavaScript로 컴파일을 한 이후 하위호환하는 것입니다.
typescript모듈을 설치하고, tsconfig를 설정합니다.
이제 babel을 사용하기 때문에 디렉토리 및 파일관련 것들은 설정하지 않습니다.
⇒ sourceMap과 noImplicitAny정도만 true로 변경해줍니다.
“presets”:[먼저 해석되어야 하는 것 마지막, ts→js→es5하위호환]
 npx babel src --out-dir dist --extensions ".ts,.tsx,.js,.jsx”
src폴더의 파일을 dist폴더로 트랜스파일링 —extensions “확장자지정”
개별 점검할 것 2가지
ts로만 js를 만들 수 있는가.
babel로 ts를 하위호환버전으로 변환할 수 있는가?
⇒ 이 전제가 가능해야합니다. 무엇을 위해서? bundling(번들링)을 위해서
이너미션!
BOM API 
→ DOM API
→ Location API
BOM API는 자식요소로 DOM API가있고, DOM API의 형제로 Location API가 있습니다.
window.location.hash 라는 매서드가 있습니다.

addEventListener(”hashchange”,()⇒{})

이를 사용해서 탭 메뉴를 구현해주십시오.

탭 메뉴란? 누르면 새로운 창이 나오게 하는 것을 의미합니다. 
CSS레벨에서 할 수 있는 방식이 있습니다. 
겹치기를 사용하면 됩니다. z-index방식 말고, location.hash방식으로 진행해주세요.
→ 무엇을 얻어갈 수 있느냐? 
React의 CSR개념을 이해할 수 있습니다. Client Side Rendering
탭 메뉴가 곧 === SPA(single page application)입니다.
window.document.어쩌구저쩌구 ←기존에 사용하던 것.

URL: https://www.notion.so/24-07-02-771790cc445c4073833991baa7c6ba7f
npm install —save-dev -g ts-node
⇒ ts-node라는 패키지를 시스템 전체에 설치
왜? ⇒ 디버거를 활용하기 위해서.
개발자 도구용 패키지를 짧게 다운로드 하는 방법.
npm i -D typescript ts-node @types/node
⇒ 이렇게 패키지를 다운받는 과정을 빌드환경 구축이라고 한다.
build 환경 혹은 개발 환경
reploy환경, distribute / dist, release버전.
ts를 쓰는 순간 js는 아예 안보는 것이 좋다.
⇒ 만약 타스를 쓴다면 모든 것을 타스로 쓰는 것이 맞다.
TS전용 타입 Any ⇒ anything
무엇이든 수용해주겠다는 의미.  === 에러를 내지 않겠다.
때문에, any타입을 사용하면 ts를 쓰는 의미가 많이 희석된다.
⇒ 쓰지 않는 것을 강력하게 권장. 
하지만 때에 따라서 Any를 써야하는 상황이 있다. 다음과 같다.
js프로젝트를 이식할 때, js파일을 떼어낼때 확인을 위해서 any타입을 사용한다.
다른 패키지에서 ts공식지원이 어려운 경우.
개발환경구축이란? 
매우 중요한 개념입니다. - 웹서비스 같은 경우
유행을 타는 편. → 늘 적응을 해야함.
typescript
tsconfig.json
—complieOption
⇒ noImplicitany
⇒ rootDir : ./소스코드모음 디렉토리 src
⇒ outDir : ./배포용모음 디렉토리 dist
이제 rootDir만 가지고 사용을 할 것이다.
dist폴더를 전혀 보지 않게 될 것.
⇒ sourceMap : true 디버거를 추적할 때 좋음.
⇒ include와 exclude
컴파일 옵션 밑에 작성.
무슨 기능인지는 GPT와 claude를 참조합시다.
node는 모듈을 구현하기 위해서 CommonJS라는 것을 채택하였다.
⇒ require(), module.exports 등등
⇒ TS를 쓰는 순간 모두 ESM방식을 사용한다.  ESM이 뭘까? 
ESM ⇒ 쓰고싶지만 타스가 가로채버림 ← 타스가 알아서 해준다.
그래서 따로 설정할 일이 없음.
package.json세팅
→ 명령어 셋팅
→ entry를 dist/app.js로 변경하는 편(그때 그때 다름)
강사님이 원하는 목표 : 자유로운 타입스크립트 셋업 
⇒ 그렇다면 tsconfig의 주석들이 무엇을 의미하는지 알아야 할 것이다. 
결국 개발환경을 세팅할 수 있어야한다.
⇒ 이것을 한다면, 자바스크립트에서 벗어날 수 있다.
⇒ 복잡한 스텝이 있기는 하지만, JS를 안쓸 수 있는게 어디야!
babel 세팅
@babel/core
@babel/cli
@babel/preset-env
@babel/typescript
npm install --save-dev @babel/core @babel/cli @babel/preset-env @babel/typescript
Babel의 정의
타스처럼 개발자용 SoftWare
타스는 우리가 편하게 쓰자. Babel은 broswer를 위한 하위호환을 위한 소프트웨어
const와 let등이 모두 var로 쓰임. 배포버전에서는 여전히 const는 쓰이지 않는다.
⇒ 이를 바꿔주는 작업을 일일이 할 수 없기 때문에, babel과 같은 것이 생겼다.
⇒ JS가 인기를 얻게된 최고의 작품중의 하나이다.
⇒ 우리가 마음껏 최신버전의 코드를 적을 수 있는 이유가 바로 Babel덕이다.
타스, 자스 할 것 없이 모두 완전호환이된다.
⇒ 버전을 알 필요가 없게 되었다.
⇒ 물론 Babel이 있다는 전제하에.

URL: https://www.notion.so/24-07-01-3cfac7b031e24d318bc887d0304ad291
AWS? GCO? Azure?
⇒ clound계열 회사들은 우리나라의 것이 쓸만한 것은 없다.(NCP)
카드로 결제를 해야합니다.
⇒ 신용카드 절대 X!!!!!! 체크카드를 사용하세요.
클라우드 인터넷에 관심이 있다면 언제든지 하도록 하세요!
딱히, 배우는 것은 없습니다.
⇒ 페이지 하나라도 배포하면서 관리해보는 연습을 해보세요.
⇒ prettier배포가 있습니다. 고로 0원으로 할 수 있습니다. 한번 해보세요!
찾아봅시다. GCP는 30만원정도 무료로 준다.
뭐가 최곱니까? AWS가 일단 최고라고 합니다. 이유? 커뮤니티가 너무 큽니다 너무 좋아요.
⇒ 키워드는 클라우드 컴퓨팅입니다.
일반인들이 쓸 수 있는 레벨 :
SaaS Software as a Service ⇒ 코드가 필요 없는 형태의 클라우드.
PaaS Platform as a Service ⇒ mpm이 뭔지만 알아도 쓸 수 있습니다. 
IaaS Infrastructure as a Service ⇒  클라우드를 통해 기업 및 개인에게 컴퓨팅, 스토리지, 네트워킹, 가상화와 같은 주문형 인프라 리소스를 제공하는 클라우드 서비스 모델입니다.
프링글스를 만든다고 생각해봅시다.
맨처음에 만든 프링글스 칩이 프링글스 통의 마지막에 들어가 버릴 것입니다.
그렇다면 맨 처음에 만든 프링글스 칩은. 마지막에 먹게 됩니다.
이것이 자바스크립트 엔진입니다.
자바스크립트의 엔진은 함수를 쌓아뒀다가 역순으로 실행을 합니다.
그렇다면? 먼저 실행해야 하는 함수가 있다면 어떻게 해야합니까?
⇒ 그것을 위해 컨베이어 벨트 같은 공간을 하나 만들어 두었습니다.
기본적으로 생각해야 할 것은 다음과 같습니다.
⇒ 프링글스 통 하나, 컨베이어 벨트 한개, 작은 컨베이어 벨트 한개, 인형뽑기 집게 2개.
여기서 컨베이버벨트는 Queue라 부르고, 인형뽑기는 이벤트 핸들러,
프링글스 칩은 함수이다. (이벤트)
인형뽑기에 의해서 뽑아지는 프링글스 칩은 비동기함수이다.
프링글스 통은 콜스택이라고 한다. 호출이 쌓인다는 의미이다.
큐는 이러나 저러나 일을 받아서 함.
큐, 콜스택, 이벤트 루프 그렇다면 작은 컨베이어 벨트는 무엇입니까? 
그것이 바로 promise라고 합니다. microqueue, testqueue
콜스택
이벤트 루프
QUEUE
빌드 환경 구축 연습.
function a(b) {
  if(typeof(b) === 'number'){
    if(Number.isInteger(b)){
      let result = b + 10;
      return result;
    }
  }
}

console.log(a('1'+1)); // undefined
⇒ 타입 선언을 하지 않은 이유. 쉽게 하기 위해서.
⇒ 근데 개발을 하다보니, 자동으로 타입을 설정해주는 것이 오히려 역으로 문제가 되더라.
⇒ 최초에는 매우 편리하다고 생각했는데,,,근데 이제는 자바스크립트를 script로 쓰지 않으니 오히려 독이 되어버림.
⇒ 다른 환경이라면 언어를 바꾸면 그만이지만, browser라는 어마어마한 것 때문에 바꾸질 못함. 그렇기 때문에 동적 타입 선언( 정수, 숫자라고 선언하지 않아도 되도록 )
‘자동으로 타입을 정해주는 형태’가 피로도를 상당히 높히게 됨.
⇒ 현대 언어 중 가장 불친절한 에러를 뿜어내는 언어가 javascript입니다. 어디가 틀렸는지를 말을 안해준다.
⇒ 디버깅이 너무나도 힘들다. → 오류까지 잡아내면서 쓸 코드가 아니었기 때문
그래서 탄생한 이야기 ⇒ 보완책을 만들자! 이것을 버릴 수는 없다!
typescript가 탄생 → ms가 만듦.
때문에 vscode와 매우 호완이 좋다.
그래서 javascript는 천천히 사양길에 들고있다.
JS의 단점.
분명한 버그인데, 못 고치는 현상
이미 너무 많은 사람들이 쓰고 있는 관성
압도적인 브라우저 생태계
아~니,그럼? 개발만 편하면 되는거 아님???? 
→ 그래서 broswer는 typeScript를 읽지 못한다.
⇒ 그렇기 때문에 typescript는 전적으로 개발자를 위한 언어이다. DX - Developer Experience
⇒ 그래서 브라우저에 사용하려면 js로 컴파일을 해야한다.
자 그럼 타스를 쓰면 뭐가 좋을까?
타스의 장점
다른 언어를 배울 때 엄청나게 편하다.
에러가 정말로 친절하다.
예기치 못한 버그를 원천차단한다. === 에러를 뿜어내기 위해서 쓰는 도구이다.
→ 당장 편하자고 쓰는 언어가 아님, 개발자를 불편하게 하기 위함. 코드의 안전성은 오히려 증가.
install방법.
npm install —save-dev typescript  -D를 사용.
⇒ 개발단계에서만 사용할 거야!
⇒ —save-dev를 사용하지 않으면? 배포용이 되버린다. 혹은 
  "devDependencies": {
    "typescript": "^5.5.2"
  } // dev가 붙어있는지 확인, 개발용으로 받았다는 의미.
config파일을 생성해야 한다.
npx tsc —init ← typescript compiler
⇒ 에러가 나는 것은 정상이다.
⇒ 주석들은 나중에 내가 추가할 수 있는 기능들이다.
⇒ 이것은 초기화를 하는 작업이다. npm —init으로 프로젝트를 초기화하는 것과 같다.
work-2.ts파일을 생성해보자.
오류가 뜨는 것을 확인할 수 있다.
⇒ 이로인해 알 수 있는 장점!
타입을 완전히 제어할 수 있다.
타입선언으로 ‘내가 원하는 것’만 사용가능하다.
npx tsc 파일명.ts를 하면 충분히 컴파일하여 사용할 수 있다.
ts-node를 설치할 것 ⇒ 디버깅 파일.
npm install —save-dev ts-node
⇒ 매번 자스로 컴파일하기 불편해서 타스로 디버깅할래.
사용법
npx ts-node 파일명.ts
타입스크립트용 플러그인 설치.
@types/node ⇒ node용 셋업을 설치해준다는 의미.
node.js타입정의가 모두 끝난 플러그인을 설치해줌.
⇒ 예를 들어서 http나 fs에 들어있는 타입정의를 모두 정리해준다는 의미.
tsconfig 파일에서 해야할것 :
noimplicitAny를 ctrl+f해서 찾아내서 주석을 해제한다.
⇒ any타입을 사용하지 않겠다 라는 의미.
Any타입을 써야할 때는 언제인가? ⇒ JS파일을 TS로 이식할 때 사용함.
⇒ 그때는 풀어놓지 않으면 실행이 되지 않기 때문이다.

URL: https://www.notion.so/7-61c7d64b14ed4231997bafc613cc7dfe
24/07/01
24/07/02
24/07/03
24/07/04
24/07/05

URL: https://www.notion.so/7-c6fb64e72137455b825ebf0193203923
7월 첫째 주
7월 둘째 주
7월 셋째 주
7월 넷째 주
7월 다섯째 주

URL: https://www.notion.so/24-06-28-504b80f62a9f4ca39145e49fb09576b6
1. 여성인권이 언제 신장되었다고 생각합니까?
1-1. 전쟁
1-2. 세탁기
⇒ 어떻게 세탁기?
세탁기가 주는 것은 시간입니었습니다. 세탁기가 나옵으로써 여성들은 시간을 얻을 수 이었습니다.
음.. 여성만 벌었다고 할 수는 없겠군요.
⇒ 이처럼 시간은 매우 중요합니다.
⇒ 그렇다면 낭비하는 시간은 없는지 찾아보는것이 중요할 것입니다.
낭비되는 시간이 없는지 도파민 단식을 시도해보는것은 어떻습니까?
2. 이번주에 하지 못한 것을 찾아봅시다. 
1. JS vs Py
어떠한 차이가 있을까요?
err에서 차이가 납니다.
python은 err처리를 매우 잘 알려줍니다. 그에 반해 JS는? 그냥 에러가 났다고만 말해줍니다.
⇒ 그렇기 때문에 여러분은 Python과 TS로 작업한 작업물을 변환시켜보는 작업을 해보시는 것은 어떻습니까?
⇒ 코드 안정성이라는 것이 있습니다. (TS) 이게 왜 필요한지 필요성을 느껴보셔야 할 것 입니다.
이게 왜 필요할까? err코드가 많이 날수록 코드는 더욱 안전해집니다.
왜냐? 자그만한 에러마저 잡아내서 사람들이 고쳐내기 때문입니다. 
타입스크립트 중요한거 자신만의 tsconfig → tsconfig를 만드는 방법을 알아야 할 것.
⇒ tsconfig뭘까요?
// class 써보기.
// unity unreal typescript. 
static
new
배성빈
유효성 의존성 주입 di.  네스트, 넥스트 
class ⇒ 활용방안. 
클래스 의존 관계를 줄이면서 하나의 기능을 합친다.
⇒ 기억해두자 일단은 기능 구현.

URL: https://www.notion.so/24-06-27-a8c45f259b274f40a60058f11893972e
1. 책, 책, 책, 책을 읽읍시다!
글을 적어야 합니다 여러분, 저희는 ai에게 명령을 어떻게 내립니까? 글로서 내립니다. 혹은 말로 이야기한다고 할 수 있습니다. 하지만 그것을 가공하는데 텍스트만한 것은 없습니다.
글을 소비하십시오. 낯설을 수도 있습니다. 하지만 해야만 합니다.
그노무 쇼츠, 릴스같은것으로 삶의 질을 떨어뜨리지 마십시오!
그거아십니까? 아마존에서 투자한 ai가 이번에 3.5버전이 나왔는데 GPT를 이겼답니다. 클라우드? 라고 합니다.
프롬프트 단 3줄만으로 게임을 만들어냅니다.
⇒ 그렇다면 그 3줄은 어디서 나왔겠습니까?
바로 글입니다. 여러분 글을 읽읍시다.
현재 우리의 세대는 유튜브에 너무 익숙해져있습니다. 삶의 질을 떨어뜨리고 있습니다. 우리는 2만원으로 한 사람의 몇년치의 고민을 읽어낼 수 있습니다. 이 얼마나 치사한 물건입니까. 이 얼마나 가치가 퇴색되어 있는 물품입니까.
그렇기에 저희는 책을 읽어야 합니다. 와 책! 치킨보다 싸다. 치킨 한마리에 2만원이 넘어가는 시대에 책 한권에 2만원 투자못하겠습니까? 한번 쯤 혹은 장기적으로 혹은 또 반 강제적으로 글을 소비해주시길 바랍니다.
이하는 저(강사)의 추천리스트입니다.
토지같은 것 너무 무겁고 재미가 없습니다. ← 이건 나중에 시도해 보십시오.
추리소설을 추천드립니다. 
히가시노 게이고의  -비밀- 영화도 있습니다! 90년대영화이지만
심야식당 재밌습니다.
추리소설은 독자와 작가가 눈치게임을 하는 것입니다. 반전의 반전을 섞어 느낄 수 있으시면 좋겠습니다.
⇒ 제가(강사) 생각해보기에는 추리소설로 책에 대해 입문하는 것이 좋다고 생각합니다.

URL: https://www.notion.so/24-06-26-6d89abd155e1476ebba3b547ca928ffc
1. 중독을 관리해야합니다!
저(강사)는 다양한 중독이 있습니다.
활자중독이구요, 코딩중독이구요, 돈까스중독이구요.
⇒ 하지만, 저급적인 것은 중독되어 있지 않습니다.
→ 릴스와 쇼츠같은 것들입니다.
여러분을 안좋게 중독시키는 것들이 있습니다.
그런것에서는 벗어나셨으면 좋겠습니다.
이것은 제가 말씀드리는 중독 리스트입니다.
미디어 (영상) - 아이스크림정도의 수준입니다. — 초정제당류
당을 정제한 것을 한번 더 정제한것이 초정제입니다. 
⇒ 매우 위험! 몸에 좋지 아니하다! 당신은 아이스크림을 200번 먹을 수 있는가?
⇒ 그것이 아니라면 줄여주시길 바랍니다.
‘자극’적인 것에 대한 중독.
⇒ 당신의 자극이 부적절한것은 아닌지? 당신은 자극을 통제할 수 있는지?
⇒ 예를 들자면, 영화를 본다면 영화관에서 보는지? 혹은 커피를 마실 때 커피샵으로 가서 마시는지?
⇒ 핸드폰이 주는 짧고 연속적인 자극 ← 릴스, 쇼츠 등은 좋지 않습니다.
⇒ 통제권이 얼만큼 있는지 확인하십시오. → 완전한 통제를 원합니다.
2. 얕은 복사와 깊은 복사.
예시 :
강사님이 종이에 글자를 적어서 3장을 A,B,C에게 나누어주었습니다.
A,B,C는 하나의 램이 됩니다.
⇒ 메모리별로 각각의 값이 할당되었습니다.
⇒ 그렇다면, 같은 값이 할당되었다고 둘은 같습니까? ← 아닙니다.
이 상태에서 D에게 새로운 정보를 할당합니다.
D가 가지고 있는 값은 A, B, C입니다. 위치값이라고 할 수 있겠습니다.
⇒ 메모리 주소라고 합니다.
primitive타입 실제값을 가지고 있는 것, (원시타입이라고 많이 부른다.)
A, B, C가 가지고 있는 값입니다. 각각 1, 콜라, true
pointer개념에 해당합니다.
예를 들어서 D가 데이터를 실행한다고 합시다. D는 A를 말하면, B를 말해야합니다.
⇒ 순서대로 입니다. 이를 pointer라고 합니다.
⇒ D는 실제 데이터 값을 가지고 있지 않기 때문에, A , B, C의 값을 참조만 합니다.
이를 참조값이라고합니다. 이것을 레퍼런스타입이라고 하는데, 유명한 것이 객체와 배열입니다.
const a = 1;

const b = 1;

console.log(a === b);

const c = [1]; // ? 변수 C의 index 0번째는 값이 1이다.

const d = [1];

console.log( c[0] === d[0] );

console.log( c === d ); // print : false;

// 해당 console.log는 어째서 false를 뱉어낼까요? 그 이유가 위에 적힌 글과 같습니다.
// 저장되어있는 메모리가 다르기 때문입니다. 둘은 각각의 메모리에 따로 저장이 되어 있습니다.
저(강사)는 이를 주소타입이라고 부릅니다. 실제로 이렇게 불리는 것은 아닙니다. 제가 이름을 붙인 것일 뿐입니다. 객체혹은 배열은 포인터를 가지고 있습니다. 위치 값만 가지고 있기 때문에, 그 위치의 값이 가지고 있는 값을 가져올 뿐, 이 친구는 값을 가지고 있지 않습니다. 그저 포인터! 위치를 찍고 가져올 뿐입니다.
⇒ 이현씨에게 pointer개념을 알려드리자.
얕은 복사? ⇒ 이거 근데, 몬스터 생성자로 가져온다고 한다면, 하나의 생성자에서 버프를 받았을때, 동시에 연동이 되게 할 수 있겠다. 같은 친구들은, 아냐 그건 잘 못됬어. 원본값이 변경될 수는 없다.
⇒ 하지만 얕은 복사본이 바뀐다고, 원본이 바뀔까?
⇒ 얕은 복사본을 건드렸지만, 원본도 함께 바뀌었다.
얕은 복사는 원본을 파괴한다.
이해를 돕기위한 코드
const a = [1,'콜라',true];

a[1] = '포카리스웨트'; // a[1]의 값을 재할당.

const b = a; // 재할당된 a를 b에 할당
console.log(b); // print : [1,'포카리스웨트',true];
이 상태에서 b[1]에 사이다를 할당하면? 
const a = [1,'콜라',true];

a[1] = '포카리스웨트';

const b = a;
console.log(b);

b[1] = '사이다';

console.log(a); // print : [1,'사이다',true]'
console.log(b); // print : [1,'사이다',true]'
이처럼 원본 배열이 함께 변화된다. → 파괴됨.
객체와 배열은 메모리에서 ‘주소’를 담는 규칙으로 복잡한 데이터를 해결하고 있는데, 이때 주소자체의 ‘위치차이’ 때문에, 같은 객체,배열처럼 보여도 다르다고 판단 되어야만 합니다.
때문에, 자바스크립트 언어에서 객체 배열을 ‘복사’하는 방식 두 가지를 채택했다.
얕은 복사 (shallow copy)
같은 주소인데, 부르는 이름만 다른 경우. → ex) 지번주소와 도로명주소
깊은 복사 (deep copy)
특정 주소데이터를 그대로 복사해서 ‘ 다르게’ 사용
때문에 원본을 파괴하지 아니함.
ex) D의 참조값을 직접 복사하여 (객체로 재조립하여) E에게 할당.
E가 데이터를 수정
⇒ E의 데이터는 변했지만, D의 데이터는 변경되지 아니함.
대표적으로 사용할 수 있는 것이 map매서드이다.
const origin = [
  {name : '김정수', age : 29},
  {name : '김인티저', age : 27}
];

const shallow = origin.map((item)=>{
  let result = {
    name : item.name,
    age : item.age
  }

  return result
})

console.log(origin);

console.log(shallow);

shallow[1].name = '인티저김';

console.log(origin);

console.log(shallow);
왜 const는 빈 객체를 초기화해도 되는 걸까?
GPT에게 명령하세요
JavaScript의 배열매서드중에, 깊은 복사를 관장하는 shallow copy가 아닌 deepCopy를 해주는 매서드는 무엇이 있는지 리스트를 뽑아주세요.
※강조하는 배열매서드! 4종!
forEach
배열을 for문으로 돌린다. forEach를 사용한다? 배열이다.
map()
매우 좋음! 그냥 좋음!
filter()
로딩창을 사용할 때 많이 사용함.
reduce()
누산기. 
append하듯이 사용함.
Arrayfrom() 
⇒ 배열로 취급해 주겠다.
⇒ 유사배열객체에서 사용.

URL: https://www.notion.so/24-06-25-0877535eec814200921e627a9dcd2bb7
GPT에게 명령하기.
끊어서 토큰화 시켜서 명령하기!
React살펴보기. ← 공홈참조.
React – 사용자 인터페이스를 만들기 위한 JavaScript 라이브러리
map과 forEach의 차이점 알기 ← 배열 매서드.
⇒ map의 경우 주어진 함수를 호출한 결과로 새로운 배열을 반환.
⇒ forEach는 반환값이 없음! 그저 안에 설정된 함수를 실행할 뿐.
reduce와 fillter의 차이점 알기.
⇒ fillter는 주어진 함수의 조건을 충족하는 새로운 배열을 반환한다!
⇒ reduce는 단일 값을 반환한다.

URL: https://www.notion.so/24-06-24-83f1ca3b97de4340a1c565c588fcac5b
Promise 써보고 ⇒ 콜백하고 차이가 뭐야? ← 차이점을 발견하는게 중요.
promise쓰는게 어려워 보인다? 길을 바꿔서 진행할 것
⇒ 이것은 할 때까지 기다리지 마세요. 좋은 거아닙니다.
⇒ 그렇다면 일단 내가 해야할 것?→ 배열 매서드 찾아봅시다.
⇒ 금요일날 했던 자판기 작업. 
→ 이름만 바꾸면 블로그 글. 이름만 바꾸면 개인정보 페이지이다. 
→ 결국은 인풋과 아웃풋 그리고 로직이 들어가 있을 뿐이다. 
⇒ 쇼핑몰이 될 수도 있다.
⇒ 생각해보아라, 글을 적고, 값을 입력하면 그 값이 저장되고, 원할 때 출력할 수 있다.
⇒ 일반인과는 다른 ‘관점’을 가지도록 합시다.
정리를 잘 할 수 있도록 합시다.
A를 해보았다면, B를 해볼 수 있는가? 
B를 해보았다면, C를 해볼 수 있는가?
⇒ 중요하다. 그래서 내가 해볼 것? 내가 지금 JS로 작업하는 것들 나중에는 다른 언어로 작업을 해보아야 할 것이다.
특히, node.js를 사용한 것? python으로 해보자. ← 자판기 작업을 다한다면 그렇게 해봅시다.
그런데 python을 사용해서 서버를 열었을 때, 그것을 자바스크립트로 나타낼 수 있나?
생각해보니까. 원래는 어떻게 랜더링을 하지? ← 어떻게 하는 거지?
의식적으로 해주세요!
→ 조건에 부합하는 것이 있다. 그렇다면 조건을 알고 시작해야하지 않겠나?
→ 알고 시작하고, 모르는 것을 찾아내자. ← 모르는 것 매우 많다 지금.
알려고하는 핀 포인트가 무엇인지만 잡아낼 수 있다면, 해결의 포인트는 쉽게 다가올 것이다.

URL: https://www.notion.so/6-ba9141cf7ad44f7a885c325c3df7683e
24/06/24
24/06/25
24/06/26
24/06/27
24/06/28

URL: https://www.notion.so/24-06-20-1956a40ee02343b3bbda6e27f8fd69e6
비중을 조율하는 작업이 필요하다.
⇒ 나의 스타일대로 repo를 다룰 수 있어야한다.
사실 나는 지금 GPT를 잘 사용하고 있지 않다.
GPT를 사용하는것에 익숙해지기위해서는 설계를 하고 걸계를 GPT에게 계속 물어볼 수 있어야한다.
그러기 위해서 Debugger가 필요한 것 같다.
⇒ 그림을 그려보자. 회의를 못하니까 채팅으로 계속 질문이 난무할 것이다.
⇒ 그렇다면 채팅으로 계속해서 이야기를 해야할 것이다.
⇒ 항목을 나누어서 서로 가져다가 만들어보자.
그러면 남은 시간 동안 설계를 잠깐 해볼까?

URL: https://www.notion.so/24-06-17-e16083be8a92428792693d6aa4c8b5d8
0. 수업시작 전
0-1. GPT
일반인들은 GPT를 잘 쓰지 못한다. 무료임에도 불구하고, 어째서일까?
0-2. 팀프로젝트
면접에서 팀프로젝트의 질문은 무조건 나옵니다!
⇒ 어떠한 일이 있었는데 이런식으로 해결했습니다.
⇒ 과정중에는 이러한 일이 있었습니다.
⇒ 전체적으로 이런식으로 진행되었었습니다.
⇒ 나도 도움을 받았고 ( 상세하게 ), 나도 타인에게 이러한 도움을 주었습니다.
⇒ 우리는 그 결과 이러한 결과물을 내었습니다.
0-3. 금주는 AJAX와 DB에 대하여 공부할 것입니다.
1. GPT와 GEMINI를 둘다 틀어봅시다.
여러분 GPT와 검색엔진의 차이점은 무엇이 있을까요?
이 차이점을 알기 위해서는 GPT가 나오기전의 시대를 알아야 합니다.
우리의 전세대에서 검색엔진이란 그저 문서를 찾아보기 위함이었습니다.
⇒ 그렇기 때문에 ‘검색엔진’입니다.
그렇다면 GPT는 무엇을 할 수 있습니까?
⇒ GPT로 지식을 찾기 위해서라면 그냥 검색엔진을 사용하면 됩니다!
검색엔진은 도서관을 부수는 형태로 나타났지만, 여전히 도서관은 존재합니다, 지식을 학습하는것은 다른 영역이기 때문입니다.
GPT는 일반적으로 바보입니다.
여러분은 GPT에 힌트를 많이주어야 합니다. 
⇒ GPT에게 나의 정보를 전해주고, 정보와 목적을 일치켜서 물어봅니다.
⇒ 1. 나는 떡볶이를 좋아해
⇒ 2. 그래서 그런데 둔산동 근처에 있는 떡볶이 집을 추천해줄래? ← 역제안
1-1. GPT
GPT는 전세계 지식을 한데 뭉쳐 놓은 것에는 의심이 없다.
⇒ 언제 써먹냐의 문제이다.
일반인들이 쓰기에는 버거운 지식이다.
⇒ 어째서? 내가 주문하는 것에 대한 논리의 모순을 찾아야 한다.
컴퓨터는 틀리지 않기 때문이다.
왜 GPT는 거짓말을 할까?
⇒ 사람은 ‘없다, 싫다, 아니다’등 부정문을 싫어하기 때문이다.
⇒ 사용자 경험상 “진실”보다도, 친절한 응답을 원하기 때문이다.
⇒ 그렇기 때문에 엄격하게 틀렸다면 틀렸다고 이야기를 해달라고 GPT에게 주문을해야 틀렸다고 이야기한다.
⇒ 또, 그렇기에 GPT의 답은 ‘내가 함부로 믿어서는 안된다.’
GPT는 특수한 경우를 제외하고는 ‘결정’자체를 하지 않는다.
⇒ 금융관련해서는 절대로 결정내리지 않는다. ← 주식, 상품 등등
⇒ 개발 코드도 ‘ 가장 좋은 것을 선택 ‘ 하지 않는다. ← ( 해당 코드는 실수할 수 있습니다. 사용에 유의하세요)
설명의 양과 답변의 품질이 비례한다. ★
⇒ GPT가 답답하다!
⇒ 내가 설명을 덜했다.
⇒ 설명을 잘하면? 
⇒ 제법 잘 나온다.
GPT가 잘하는 것
⇒ 반복 작업은 끝내준다!
⇒ 경우의 수 작업은 끝내준다. (조건만 성립된다면 절대 틀리지 않는다.)
⇒ ‘주변지식’을 금방 찾아낸다.
⇒ ‘대체로 분명하다’라고 할만한 것들은 잘 해내는 편이다.
‘우리’가 GPT를 바라봐야 하는 관점
⇒ 아직까지는 ‘지식’을 탐구하는 사람들의 전유물이다.
⇒ 그렇기 때문에 딱히 지식이 필요가 없다면, 굳이 쓸 필요도 없다.
⇒ 여기서 지식은 업무에 대한 지식을 이야기하는 것이다. (교양지식을 말하는 것이 아님)
⇒ GPT는 지식을 ‘조립’해주는 존재이다.
⇒ 조립할 지식이 없다면 ‘무용(無用)’하다
⇒ 조립할 지식이 없다면? GUI로 잘 만들어진 형태를 사용하세요 
과연 정말로 ‘강사’가 필요할까?
⇒ 강사는 지식을 전해주는 사람이다. 
⇒ 지식은 GPT가 전해줄 수 있다. 물론 당신이 GPT를 다룰 수 있어야 겠지만 말이다.
⇒ 이미 강사라는 직업은 종말되었다고 할 수 있다.
→ 의도만 있다면 지식은 거의 1분안에 가져와진다.
지식이 썩어난다 라는 말 밖에 할 수 없는 상황
⇒ 지식의 ‘가치’가 떨어지는 현상이 일어난다.
⇒ 지식이 흔해지기 때문이다.
⇒ 마치 맛집들의 레시피가 대 유튜브시대에 만천하에 알려진 것 처럼.
⇒ 알려지기전까지만해도 몇백만원에 거래되었던 레시피들이 이제는 유튜브에 널려있다.
⇒ 더 이상 지식은 어딘가에 숨어있지 않다.
⇒ GPT는 숨어있는 지식을 끌고 나올 수 있다.
Q1. 근데 그렇다면 굳이 코딩을 안해도 되는것이 아닌가?
A1. 맞아용!
Q2. 근데 왜 아직도 배워야 하죠?
A2. 시간을 줄일 수 있어용!
⇒ 누구나 코딩을 할 수 있는 시대가 이미 왔다.
⇒ 하지만 사전지식이 없을수록 ‘시간’에 반비례한다.
그렇기 때문에
→ “모두가 생산성 효과를 누리지는 못할 것이다.”
→ 방향성을 못잡는 문제점도 존재한다.
반복적으로 쉽게해달라고 주문을 하면, 반복적인 말을 응답한다.
어째서일까?
⇒ 무엇이 어려운지 지정을 해주지 않았기 때문이다.
⇒ 말의 주어가 없었다.
⇒ 즉, GPT가 이상한게 아니라 내가 멍청한 것
주어와 목적어를 잘 설정할 것
⇒ 논리적으로 명확한 형태로 ‘말’을 해주면 대부분의 경우 답에 근접한 응답을 한다.
전문용어로
제로샷, 원샷, 퓨샷이라고 한다.
힌트가 없는 경우 = 제로샷,
힌트가 한개인 경우 = 원샷,
힌트가 여러개 이상인 경우 = few샷
1-2. GPT3.5 vs GPT4.0
‘주변지식’ 탐문 하는 것에는 모데르이 버전이 높은것이 나은편이다 ⇒ 대신 느리다 (GPT 4.0)
‘이미 정해진 답’을 알아내는 것은 → GPT3.5가 최고다 / 어째서? ⇒ 엄청나게 빠르다
“내가 무엇을 원하는지만 정의하면”
⇒ GPT와 함께 구축하면 된다.
GPT가 죽었다 깨어나도 못하는 것이 무엇?
⇒ “ 내가 무엇을 원하는지 니가 만들어봐라! “ ← 절대 못함.
1-3. GPT를 쓰다보면 생기는 일
하나하나가 틀린말이 없어서(정해진 지식) → 받아들이는데 큰 노력이 필요하다.
⇒ 무분별하게 쏟아내는데 그게 틀린소리가 아님.
잘못된 사용법 ( 일반 소비자들이 사용하는 방식인 → 체리피킹 ) 하는 형태로 습관을 들이면
⇒ “Prompt( = 질문 )의 수”가 줄지 않는다. 
⇒ 매번 같은 질문을 해야하는 상황이 온다. ★
GPT가 유저가 된 다음의 현상!
하루 종일 질문하게 될 것이다.
내가 얼마큼 이해하는지를 ‘물리적’으로 알게 된다.
모르는 것에 대한 ‘까방권’이 사라져버린다. ⇒ GPT가 다 알고있다.
10년차 개발자가 아니어도 관록을 만들 수가 있다.
“잘 결론지은 답”을 내야한다. ⇒ 이것이 안되면? 거짓말속에 살게된다.
회사가 괜찮아 보이는 곳은 GPT를 금지하는 경향이 짙다.
⇒ 거짓말 속에 사는 사람들을 걸러내기 위해서. + 내부용 GPT를 쓰기때문에 다르다.
2. 잘쓰는 법 팁!TIP!
문장형태(자연어)로 주어, 동사, 목적어 등등 분명하게 내 의도를 피력해야한다.
다량의 힌트를 주어야 한다. ex) A는 알겠는데, B는 모르겠어.
모르는 단어나 개념이 나오면? ⇒ 절대로 넘겨선 아니된다.
⇒ 나의 시간이 줄어들지 않는다. ← 나올 때 마다 계속해서 찾게됨.
설계를 노력하면 코드가 바로 구현될 것
※ 미세 TIP!
하나의 의제는 = Prompt 하나에서 모두 끝내자!
⇒ 질문 수가 많아질수록 더욱 똑똑해진다!
코드로 이야기하면 엄청나게 빠르게 이해한다.
Prompt에게 역할을 부여해주세요! ⇒ 상황 설정!  ex) 선생님, 강사 등
‘나’의 상황, 목적에 대해 충분히 교육해야 함
Mission 개발자의 팀프로젝트를 할 때 좋은 점, 좋은 것을 GPT에게 물어서 알아보세요!
팀 소개페이지1
팀 아웃풋  어떤식으로 무엇을 처리할지에 대하여.
ERP가 뭘까?
내가 누군가와 팀인데 그 팀이 갑자기 사라졌다! 아파서 못나왔다!
⇒ 그렇다면 팀의 코드를 계속해서 리딩해야한다.
⇒ 무엇을 했는지 확인을하고
⇒ 진도를 확인하고, 무엇을 해야할지 계속해서 파악을 해야한다.
⇒ 그래야 속도가 날 수 있다.
의견 통일이 아니다! 의견 나열이다.
모두의 의견은 존중 받아야 한다!
학습 효과는 희생? 아니 희생이 뭐임 우리 모두 다같이 좋은 효과를 가져갈 수 있도록 하자!
하면 안되는 것!
팀원은 님 친구가 아닙니다.
⇒ 말을 자르지 마십시오. 말을 모두 할 때까지 당신은 기다리셔야 합니다.
⇒ 친구라면 회복할 수 있겠지만, 우리는 친구는 아니고, 팀원일뿐입니다.
⇒ 팀원이 말을 끝마치면, 반드시 답변을 하도록 합니다. ← 말을 들었다는 의미로 답변을 해야한다.
⇒ 못 알아들었다면 질문을 해야 합니다. ← 알겠죵?
⇒ 아ㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏ니, 그게아니라! ← 안됩니다. / 그 사람의 말을 전면적으로 부정하는 말입니다.

URL: https://www.notion.so/6-b291c8e220ca47c48cdd77d9e86df54a
24/06/17
24/06/18
24/06/20

URL: https://www.notion.so/24-06-14-330f90f276354e038e1217b0be36a27c
0. 주말을 어떻게 보내는게 좋을까요?
술은 안드셨으면 좋겠습니다.
이번 주말은 여름을 직격으로 맞은 이후의 처음으로 겪는 주말입니다.
그렇기 때문에 휴식을 충분히 쉬셨으면 좋겠습니다.
강사의 권장은 나들이를 하더라도 짧게, 시원한 공간에서 책을 읽는 것입니다.
1. 오늘의 평가!
⇒ 이 정도는 하셔야 됩니다 수준.
⇒ 어렵진 않습니다.
⇒ 하나의 포트폴리오가 되었으면 좋겠습니다.

URL: https://www.notion.so/24-06-13-422ed194e3dd44f8adad80e7e317a282
내일은 평가날! = 점검날!
기본기 점검을 한다!
⇒ 나(강사)는 조금 더 어려운 곳에서의 평가를 원한다!
⇒ 기본기가 부족하면 안되는 때가 온다! 무조건이다!
⇒ 충분히 당신은 분석할 수 있는가?
⇒ 3개월만에 노하우를 얻는 것은 힘들다!
git평가!
⇒ branch, checkout(switch), merge 원활하게 하는가?
⇒ 기능검사.
AJAX (핵심이 될 것! ★)
⇒ 임의의 RESTAPI를 써서 정보를 조회한 이후
⇒ 그곳의 정보를 <li>태그로 만드세요!

URL: https://www.notion.so/24-06-12-f7075cd8897e43fd8288f974a8d4ac2d
0. 수업 시작 전
0-1. 컴포넌트 개념에 익숙해집시다.
우리가 해야할 것을
컴포넌트를 사용 → 하나로 묶음 → 랜더링
3가지라고 하였을 때, 우리가 할 것은 컴포넌트와 하나로 묶음입니다.
⇒ 랜더링은 프레임워크가 해줍니다.
etc. 컴포넌트의 개념을 먼저 이해할 필요가 있을 것같다.
⇒ 연습을 한다면 내가 만든 블로그의 template를 쪼개보자.
⇒ html은 root만 남기면 될 것 같다.
⇒ 그리고 html은 모두 삭제되도 된다.
⇒ db를 활용할 경우 굳이 html파일을 생성할 필요가 없다.
⇒ writeFile의 용도가 사라진 것.
→ 혹은 지금까지 나는 writeFile을 ‘잘못’쓰고 있었다.
내 생각에 이것은 한번 정리를 하고 갈 필요가 있다.
⇒ 어디까지 html로 할 것이고, 어디까지 css를 할당할 것인가?
⇒ 기점 자체는 있어야 하는게 아닐까?
⇒ html파일이 필요가 없어지는게 아닌가??????
가장 먼저 해야할 것은 컴포넌트를 설계하는 것이다.
⇒ 가장 먼저 해야할 것이자 가장 중요한 것이다. 컴포넌트 설계는 내가 뭘 쓸지 몰라!
⇒ 그냥 다 준비해.
※TIP
컴포넌트에는 각각의 고유의 이름을 부여해야 한다.
⇒ ex) tagComponent (X) → tagComponentStringReturn(O) 
⇒ 이름만 보고도 역할을 알 수 있도록.
고유의 이름을 부여했다면, 넘버링을 하도록 하자.
코딩의 피로도를 낮추기 위해서 컴포넌트를 설계하도록 하자.
 1.  
안보이는 컴포넌트 구성요소 찾기
데이터와의 연결성 ( 참조키 )
1. 컴포넌트는 왜?
일반 함수면 편할 것을
왜 “캡슐화 encapsulation” 한답시고 꽤 격식이 있는가.
해당 예시를 보아보자.
const basicData = {
  name : "",
  age : 0,
  job : ""
}

const component = () => {
  let obj = {};

  const decision = () => {

  };

  return `
  <!DOCTYPE html>
  <html lang="ko">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width initial-scale=1.0">
      <title></title>
    </head>
    <body</body>
  </html>
  `;

};
객체를 쓰는 편이다. ‘리터럴 ( 실제 데이터 )’를 묶어 쓰기 위해서
⇒ 물론 꼭 그러라는 법은 없다. 하지만 대다수의 사람들은 이렇게 사용한다.
무언가 기능을 하는 내부 함수를 넣는다.  ⇒ 왜? 굳이 내부에?
→ 외부에서 따로 호출하면 되는거 아닌가?
→ 외부에서 선언하고 호출해도 될텐데?
리턴 - 신경쓰는 편 ( 매우 많이 신경 쓰는 편 )
생성자 함수를 사용하였다.
const basicData = (name, age = 0, job = '백수') => {
  return {
    name : name,
    age : age,
    job : job
  }
}

class BasicData {
  constructor(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
  }

  set name(value) {
    if(typeof(value) === 'string'){
      this._name = value;
    } 
  }

  get name() {
    return this._name;
  }

  set age(value) {
    if(typeof(value) === 'number'){
      this._age = value;
    }
  }

  get age() {
    return this._age;
  }

  set job(value) {
    if(typeof(value) === 'string') {
      this._job = value;
    }
  }

  get job() {
    return this._job
  }
}

const component = (data={}) => {
  let obj = data;

  const decision = () => {
    if(obj instanceof BasicData) {
      return obj;
    } else {
      return {
        name : '아닌데영?',
        age : 12,
        job : "이거 양식아님!"
      };
    }
  };

  return `
  <!DOCTYPE html>
  <html lang="ko">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width initial-scale=1.0">
      <title>${decision().name}</title>
    </head>
    <body>${decision().age} ${decision().job}</body>
  </html>
  `;

};

let a = component(new BasicData('김정수',35, '인티저'));
console.log(a);

console.log(component(new BasicData('김인티저',29,'정수')));
console.log(component(basicData()));
decision() 함수의 실행문에 instanceof를 사용하여 생성자 함수를 통해서 생성된 객체만을 리턴하게 하였다.
⇒ instanceof는 어디에 쓰일까?
⇒ 이것을 왜 사용했을까?
⇒ 게임적으로 생각을 해보자. 어디에 쓸 수 있을까?
카드의 종류가 총 3가지인 카드가 있다고 하자.
카드의 종류는 몬스터카드, 함정카드, 마법카드이다.
만약 마법카드의 사용효과가 덱에서 랜덤하게 한장의 몬스터카드를 가져온다고 했을 때,
⇒ instanceof를 사용하여 몬스터카드생성자를 사용한 카드였을 때 리턴을 시키고
⇒ 아니라면 다시 돌리게 하는 식으로 사용할 수 있을 것이다.
⇒ 근데 이것은 내가 게임식으로 생각을 한 것이고, 이것을 어디에 쓸 수 있을까?
feat : 회사가 “최신 버전”을 쓸리가 없음. ⇒ 서비스 중지, 인력 → 레거시 → 모던 
—> 생성자 함수일 확률이 높다
—> 불과 2년전만하더라도 1,2기 학생들은 함수형 프로그래밍을 안가르쳤다.
—> 취업에 결정적인 역할을 합니다.
—> 생성자 함수는 컴퓨터 일반에 해당하는 지식이기 때문에, 다른 언어의 지식을 습득할때 흡수율을 높여준다. === 회사의 선택지가 넓어진다.
컴포넌트는 다르게 말해서 다음과 같다.
큰기능(){
 작은 a기능()
 작은 B기능()
}
흔히 우리가 했었던, <ul>과 비슷하게 보도록하자.
나는 <ul>이라는 태그하나만 봐도, 저게 순서가 중요하지 않은 리스트가 들어가겠구나 라는것을 추측할 수 있는 것 처럼.
1-1. state
⇒ innerFunc, anotherFunc로 사용했던 혹은 핼퍼함수, 이너함수라고 불렀던 것의 명칭이다.
⇒ 어떠한 값이 인풋되었을 때, 어떠한 조건(state)에 따라
⇒ 값을 바꿔낼 수 있다.
const component = () => {
  let obj = {
    name : "인티저 김",
    age : 20,
    job: "開発者"
  };

  let innerFunc = () => {
    if(obj.age > 20) {
      return '여름엔 역시 맥주가 최고지!';
    } else {
      return ("やっぱ、夏には牛乳が最高！");
    }
  };

  let anotherFunc = () => {
    if (obj.job === '開発者') {
      return '아니잖아?'
    } else {
      return '개발자가 되도록 노력하세요.'
    }
  };

  return `
  <h1>${obj.name}</h1>
  <h2>${innerFunc()}</h2>
  <h2>${anotherFunc()}</h2>
  `;
}

console.log(component());
※ TIP
순간 떠오른 생각을
⇒ 없애버리는 것이 미덕인 잘못된 버릇을
⇒ 필터링 없이 모두 쓰는 것
⇒ 생활패턴, 코딩, 생각 나는 것을 모두 적는 연습
설계를 몰라서 못한다?  → X
⇒ 개발자의 실력,
⇒ 스케쥴러의 투명성과 연관되어 있다.

URL: https://www.notion.so/24-06-11-ee18e8f5f2d64f5fa5d9e9b56eaf8167
0. 授業前
０－１．後悔とは
自分がしたことをあとになって気づく、悔やむことを言う。
私によって後悔になることは何があるか。
まずは、一年後にも、以前と同じ暮らしをしていること。
二つ目は、自分の過失を認めてないこと。
最後に、独立に失敗したこと
0-2. 웹 컨소시엄?
⇒ 와 ! 애플에 gpt가 박혀서 들어와요!
⇒ 랜더라는 함수, 앱이라는 함수, 컴포넌트라는 함수 
⇒ react에서 사용되는 것인가보다.
const getUserInfo = (name, age, job) => {
  return {
    name : name,
    age : age,
    job : job,
  };
};

const formComponent = (action,method,name,age,job) => {
  const userInfo = getUserInfo(name,age,job);
  return `
  <form action = "${action}" method = "${method}">
    <label for = "name"> 이름 : </label>
    <input type="text" id="name" name="name" value="${userInfo.name}" required>
    <label for = "age"> 나이 : </label>
    <input type="number" id="age" name="age" value="${userInfo.age}" required>
    <label for = "job"> 설명 : </label>
    <input type="text" id="job" name="job" value="${userInfo.job}" required>
    <button type="submit">제출</button>
  </form>
  `;
};

const App = (formAction, formMethod,name,age,job) => `
  <h1>함수의 리턴은</h1>
  <h2>사람의 머리를 맑게 해준다.</h2>
  ${formComponent(formAction, formMethod,name,age,job)}
`;

const renderApp = (formAction, formMethod, name, age, job) => {
  const appDiv = document.getElementById('root');
  appDiv.innerHTML = App(formAction, formMethod, name, age, job);
};

document.addEventListener("DOMContentLoaded", ()=>{
  renderApp("/submit","post","김정수",29,"딴따라");
});
0-3. 고지사항 6/17 팀 사전 조직
⇒ 팀 빌딩(team building)
프로덕트를 만들기 위하여 → 프로젝트를 한다.
왜? ⇒ 혼자 하는 것 보다, 같이 하는 것이 더욱 유연하고 더욱 빠르니까.
항상성 유지에 도움이 된다. ( A가 아프면 B가하고, B가 바쁜일 있으면 A가 해주고 등등 )
⇒ 회사측면에서는 프로젝트 진행에 위기가 있으면 아니됨.
이것은 통일시키는 작업이 아님 ⇒ 무엇인지 아는 작업이다.
조별과제가 아닙니다! ⇒ 서로 다름을 인정하고 / 그대로 하는 것입니다.
⇒ 즉, 서로의 행동을 통일시킬 필요는 없습니다!
⇒ 수직적 구조는 있지 않습니다. 저흰 모두 수평적 입니다!
⇒ 말을 꼭 조심하도록 하세요.
1. classroom Repeated Learning - 2
작업의 순서.
⇒ 그대로 따라한다.
a라는 익명의 힘수를 생성 
⇒ console.log로 확인
b라는 변수를 생성하고 a함수를 호출
⇒ console.log로 확인
a함수에 매개변수를 추가
이것을 왜 사용하나요?
다량의 코드를 만날 준비를 합니다. ⇒ 다량의 코드는 도저히 읽을 수 없습니다.
코드 내부를 확인하다가 날이 샐수도 있습니다.
확정적인 요소가 있다면, 최대한 확정해놓고 시작하자 라는 의미입니다.
⇒ ‘확정하는 것을 “결정”’하는 것이 개발자가 가능한 것입니다.
이를 캡슐화라고 하는데.
⇒ 캡슐로 만들면 내가 편해집니다.
⇒ 비타민 C 제품이라고 생각합시다.
→ 물에 탄것, 알약, 가루, 발포제, 젤리…등등
언제 사용하나요?
⇒ 내가 쓰는 코드중에 매번(반복)적으로 써야 되는 것이 있다면?
⇒ 캡슐로 만드는 형태를 고려해 달라! ← 강사님의 조언
새로운 브랜치를 사용합니다.
⇒ git checkout -b work-1 
⇒ work-1브랜치를 생성하고 이동합니다.
해당 브랜치에서는 formatHTML이란 함수를 제작합니다.
// ! default params
// 매개변수 안쓸 때도 있을 떄를 대비하여 디폴트 파라미터라는 것이 있다.
// 매개변수 = 대체될 값을 적으면된다.

function formatHTML(language = 'korean') {
  let htmlData = {
    titleOne:'김정수',
    titleTwo : "KimInteger",
    h1:"내 이름은",
    p: "인티저 입니다."
  };

  // * helper function
  let decision = () => {
    if (language === "korean") {
      return htmlData.titleOne;
    } else if (language === 'english') {
      return htmlData.titleTwo;
    }
  };

  let html = `
  <!DOCTYPE html>
  <html lang=ko>
    <head>
      <title>${decision()}</title>
    </head>
    <body>
      <h1>${htmlData.h1}</h1>
      <p>${htmlData.p}</p>
    </body>
  </html>
  `

  return html;
};

console.log(formatHTML('korean'));
console.log(formatHTML('english'));
! Default Params
⇒ 작성법 함수(매개변수 = 대체될 값)
⇒ 여기서 대체될 값이 디폴트 파라미터가 된다.
모던 웹에서 많이 쓰이는 ‘컴포넌트 패턴’이란 것이 있다.
1-1. 컴포넌트
컴포넌트 내부
기본데이터 ( name = ~, age = ~등등 ) 
내부함수 ( helper function, inner function )
표현 output
⇒ 이것을 하나의 컴포넌트로 묶어버린다.
branch를 work-2로 변경
⇒ html파일로 작업을 시작합니다.
⇒ 이유는 html을 사용하지 않은지 오래된 것 같아서.
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>와 work-2 아시는구나!</title>
</head>
<body>
  <div id="root"></div>
  <script>
    const root = document.getElementById('root');

    const tagComponent = (tagName,textNode) => {
      return `
      <${tagName}>${textNode}</${tagName}>
      `;
    };
    
    const app = () => {
      return `
        ${tagComponent("p","공욱재입니다.")}
        ${tagComponent("h3","공미남입니다.")}
        ${tagComponent("button","월평파더입니다.")}
      `;
    };
    
    console.log(app());

    const renderApp = () => {
      root.innerHTML = app();
    }

    document.addEventListener('DOMContentLoaded',()=>{
      renderApp();
    })

  </script>
</body>
</html>
⇒ 태그와 안의 내용 content를 지정할 수 있는 함수를 생성하고 그것을 취합하고(app)
⇒ 브라우저에 랜더링함(renderApp)
⇒ 이것을 명단을 받아서 만들어봅시다!
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>와 work-2 아시는구나!</title>
</head>
<body>
  <div id="root">
  </div>
  <script>
    const names = [
      "구하림",
      "김보미",
      "김수현",
      "김정수",
      "문혜림",
      "배성빈",
      "백지원",
      "송이현",
      "신지윤",
      "유으뜸",
      "유호영",
      "이연승",
      "이재영",
      "이종수",
      "임유진",
      "정호연",
      "조우식",
      "조자연",
      "최유진",
      "황재민"
    ];
    const root = document.getElementById('root');

    const tagComponent = (tagName,textNode, tagName2) => {
      return `
      <${tagName}>${textNode}</${tagName2}>
      `;
    };
    
    const app = () => {
      let name = [];
      names.forEach((item)=>{
        if (item === "김정수") {
          return name.push(tagComponent("h1", item, "h1"));
        } else {
          if(item[0] === '이' ){
            console.log(typeof(item));
            return name.push(tagComponent("p style='color:blue'",item,"p"));
          } else {
            return name.push(tagComponent("p", item,"p"));
          }
        }
      });
      return name.join('');
    };
    
    console.log(app());

    const renderApp = () => {
      root.innerHTML = app();
    }

    document.addEventListener('DOMContentLoaded',()=>{
      renderApp();
    })

  </script>
</body>
</html>
2. figma
코딩하기 전에→ width, height 값
⇒ 드래그로 하면 편하지 않겠습니까?
⇒ 설계를 합시다.
조립하기전에 배치 → 스케치 하듯이
⇒ 코딩 시간을 줄이는 작업입니다.
사용하면 좋은 것들
⇒ 프레임 도구, 도형 도구, 확대축소 ctrl +, -
⇒ 컴포넌트 설계를 피그마로 하게 될 것입니다.

URL: https://www.notion.so/24-06-10-708925264fd947e1b8ba99cb2011e3e9
0. 수업시작 전.
어떻게 쉬었습니까?
⇒ 어떻게 쉬었지?
⇒ 그냥 목, 금, 토, 일을 다 적어볼까?
목요일의 경우 난 무엇을 했을까?
⇒ 오전에 회사를 갔다. 12시에 돌아왔다.
돌아와서 무엇을 했는가?
⇒ 비프음을 찾아 다녔다.
⇒ 주파수를 찾았고, 주파수를 어떻게할지 고민하였다.
⇒ 이후 4시가 되었고, 나는 친구와 함께 수영장으로 갔다.
안타깝게도, 수영장은 문을 닫아서 그대로 자전거를 타고, 피자를 먹고 놀았다.
10시엔 돌아와서 잠을 잤다.
금요일엔 뭘 했지?
⇒ 회사 문을 열고, 집으로 돌아왔다.
⇒ 돌아와서는 그냥 쉬었다. 엄청나게 쉬었다. 푹 쉬었다.
⇒ 점심 약속이 있었다. 짜파게티를 먹었다. 3봉지를 끓였고, 아이스크림까지 먹었다.
← 롯데 아이스크림도 맛있더라, 피칸맛.
⇒ COOPTest에 살짝 내용을 올렸다.
⇒ 이후 게임을 했다. 저녁은? 김치찌개를 먹었습니다.
토요일엔 무얼했지?
⇒ 회사에 가서 문을 열고, 점심전에 돌아왔다. 그리고 나는 코드를 켰나? 아니, 하브루타 노트를 켰다.
⇒ 그리고 하브루타 노트를 왠종일 적었다. 뭘 하지? 무엇이 있지? 하면서
⇒ 점심을 먹고도 하브루타를 적었다.
친구와의 약속이 이번에도 있었다.
⇒ 수영장을 갔다.
⇒ 수영장을 갔다와서는 피자를 먹었다.
⇒ 피자를 먹고 쉬다가 친구와 발더스게이트를 했다.
⇒ 토요일은 단 한번도 코드를 보지 않았구나.
일요일엔 무얼 했는가?
⇒ 일단 12시에 눈을 떴다.
⇒ 눈을 뜨니 짜장면이 먹고싶어서 짜장면에 탕수육을 시켰다!
⇒ 2시까지 먹었다.
⇒ 그리고 나는 설명창을 만들었다. 모달창을 만들어보고자 했다.
⇒ 모달창을 완성하고는 사이퍼즈를 했다.
⇒ 이후 저녁을 먹었다. (김치찌개에 닭가슴살머것써용)
⇒ 그리고 쉬면서 동방화영총을 하고,
⇒ 잠을 뒤척였다. 아무래도 집중을 많이 한 것일까?
⇒ 뇌를 쉰 의미가 없다.
0-1. 반성할 점.
너무 놀았어요!
휴식도 제대로 못했어요!
공부는? 된것 같지 않아요!
즉, 이번 휴일은 완전 거진 빵점이네요! 그래도 주자면 40점은 주도록 합시다.
0-2. 그럼 이번 주말을 지금 시점에 설계해볼까요?
이번 주말은 약속을 없애봅시다!
게임은 토요일날만. 즉, 토요일은 쉬는날로 합시다.
일요일은 그럼 무얼 하나요? ⇒ 코드를 작성하거나 혹은, 아이디어 설계! ← 이거 중요. ★
0-3. 금주의 기록.
⇒ DB를 할 것입니다!
⇒ 간단하게 할 것이니 걱정하지 마십시오.
⇒ DB를 배운다면, 내가 팀장일 때 나는 DB로 해봐야겠다.
0-※ TIP.
사회가 요구하는 기준이 있습니다. 즉, 허들이 있습니다.
허들에는 무엇이 있을까요? 이건 기본입니다.
문제해결능력
⇒ 하위적으로 대화능력이 있습니다. 대화능력 ≠ 수다 입니다.
생각을 글로서 옮길 수 있는 능력, 혹은 말로 잘 가공할 수 있는 능력.
간단하게 보자면 아침 9시에 일어날 수 있는가?
협동할 수 있는가?
환경에 적응할 수 있는가? 환경을 바꿀 수 있을까.
항상성 - 스스로 시간 안배를 잘 할 수 있는가?
개발자 피라미드를 그려보자면 어떻게 될까요?
하위권
⇒ 생각없이 그저 코드만 적는 사람. ← 생각 X
중위권
⇒ 그래도 새로운 기술을 받아들일 수 있는 사람, 받아들이고 적용할 수 있는 사람
상위권
⇒ 자신만의 생각을 가지고 코드를 적는 사람. ← 생각 O
최상위권
⇒ 생각은 물론 거기에 가치까지 형성할 수 있는 사람. 가치를 형성하고 가치를 만들 수 있는 사람.
⇒ 가치까지 생각하는 사람.
1. SQLite3
⇒ 서비스용은 아님
⇒ 짧게짧게 쓸 수 있음.
⇒ 거부감을 줄이는데 일조할 수 있다.

URL: https://www.notion.so/6-c449a0742d304188bfbac3fa94bd6553
24/06/10
24/06/11
24/06/12
24/06/13
24/06/14

URL: https://www.notion.so/24-06-05-8828f12318104ff4bfd1237658aaba8a
1. AJAX란?
Asynchronous Javascript And XML(JSON)의 준말이다.
⇒ XML을 사용하나요? 
아니요, 안쓰는 것은 아니지만, 지금은 XML이 퇴화되었기에 주류는 JSON을 사용한다.
1-1. 기대되는 효과?
외부데이터를 외부서버로부터 받아낼 수 있다.
⇒ 여기서 외부데이터가 중요한 이유는?
⇒ 개발자가 일일이 기초데이터를 수집할 수 없기 때문. 정확히는 효율성 문제.
ex) 미세먼지농도측정기 → 기초데이터를 확보하는 기기.
⇒ 공기 XX당 먼지에 해당하는 요소들이 포함되어있는지 ‘수집’만 한다.
⇒ DATA : 측정 ‘값’, 수집된 ‘값’
⇒ 정보란? 어떠한 판단이 들어간 DATA를 뜻한다.
ex) 미세먼지 농도가 일정량의 DATA를 넘어가면 몸에 좋지 않다!
⇒ 이것이 정보(information)이다. 미세먼지 나쁨, 좋음, 매우좋음… etc 등등 ‘판단’된 값.
※ 사람들은 왜? 정보와 데이터를 헷갈려할까?
⇒ 누군가의 판단이 섞인 것이 많기 때문이다.
⇒ 지속적인 정보노출로 인한 일종의 세뇌효과도 있다.
⇒ 여기서 지속적인 정보노출이란? 광고와 같은 것을 말한다.
날것의 데이터는 무엇이 있을까?
음식의 성분표, 통계자료, 주식차트, 음식가격 등등…
여기서 정보는 어떻게 될까?
음식가격이 비싸다! ⇒ 가격의 지표에 따라 판단이 들어간 정보이다.
1-2. AJAX란 결국?
데이터를 가지고 오는 기술이다.
⇒ 빠르게 데이터를 가져오겠다. 중요한 건 데이터 라는 것이다. 데이터와 정보는 다름을 위의 1-1. 목차에서 확인했다.
날것의 데이터를 정보로 가공할 때 → AJAX를 활용할 때가 많다.
현황이 중요한 데이터들이 있다. ⇒ AJAX를 사용.
ex) 현재 교통량, 
실생활의 측면에서 날것의  데이터 vs 정보의 차이점을 발견해 내보세요!
⇒ 아이디어가 떠오릅니다!
AJAX + 프로젝트 구상법을 묶어보는 형태입니다.
해당 코드에서
⇒ AJAX가 객체를 불러오는 작업이라는 점 ( 인스턴스 )
인스턴스에 ‘무엇인진 모르겠지만’
⇒ 메서드, 키 몇개 등등 들이 들어있다.
⇒ 아직 정확한 기능은 모르겠다.
객체를 찍어내는 방법 + 서버통신방법
⇒ 합쳐진 기술이란 점을 추리할 수 있다.
여기서 추론할 수 있는 것 생성자 함수를 사용하는 이유가 무엇인지 떠올려야 한다.
생성자 함수는 일종의 규격 ⇒ 고정적인 무언가를 ‘보장’한다.
때문에 xhr을 사용하는 것도 고정적인 규격을 통과시켜서 사용.
서버통신 프로토콜 ⇒ 외우거나 이해하거나 해야함.
⇒ node.js를 먼저 배운 이유이다.
비동기 동작 → 순서를 어기는 형태
AJAX는 이 3가지가 짬뽕으로 섞여있다.
2. 무궁무진한 데이터의 바다
여러분은 무궁무진한 데이터를 받을 준비가 되었습니까?
⇒ 데이터 포털에 들어가서 ‘대전’이라고 검색해봅시다.
REST API - 신원을 확인함.
⇒ 우리가 문서를 송출해주는 것처럼 서버를 운영하고 있다.
⇒  API서버는 요청하는 주소에 따라 ‘객체’를 응답해준다.
‘API를 활용하여 만드는 사람입장’
⇒ 굳이 저 서버를 건드리지 않아도 됨.
⇒ 부대찌개 밀키트(데이터) + 나만의 방식(정보화, 해석)인 느낌.
서버가 운용중이다?
⇒ 비용이 나간다.
⇒ 이는 우리의 세금으로 운용되고 있다. 때문에 비용은 세금으로 처리
⇒ 아무나 못쓰게 ‘신청’을 받는다.
⇒ 신청이 승낙되면 열쇠를 발급받는다.
new XMLHttpRequest()라는 생성자 함수를 사용했다.
⇒ 이것이 객체임을 나는 알 고 있다.
⇒ 그렇다면 나는 객체에 접근하는 방법도 알고있다.
⇒ console.dir(객체명);
우리는 HTML 첫날부터 객체를 생각했다.
⇒ 지금하는 것 또한 객체이다.
⇒ 객체는 이미 알고 있지만, 그것이 무슨 내용인지 모른다면?
⇒ 조회를 하자!
3. 시간을 소중하게 사용하세요!
긴 휴가를 가지게 되었습니다.
총 4일의 휴일입니다. 자신을 탐문해주시길 바랍니다.
4일간 자신에게 스스로 물어보면서 자신을 탐색해 보십시오.
⇒ 그리고 나름의 정의를 내리고 나름의 정리를 하십시오.
⇒ 블로그는 왜 만드십니까?
⇒ API는 왜 가져다 쓰십니까?
⇒ 이것으로 대체 무엇을 하려고 그러십니까?
⇒ 모든 것에 의문을 품고 스스로에게 물어보시기 바랍니다.
⇒ 시간을 느리게 가져보는 것입니다.
※ 오늘의 의제 키워드
실생활의 측면에서 날것의 데이터와 정보의 차이점을 발견해 보십시오!

URL: https://www.notion.so/24-06-04-edb3d87a4e274c51a6dc5cf258e41db3
0. 수업시작 전.
0-1. programming일반!
적어봅시다.
데이터 타입은 매우 많습니다. 아직 배우지 못한 데이터 타입도 존재합니다.
⇒ 빅인트, null, undefined…등등
⇒ 하지만 현재 상황에서 가장 중요한 것은? 객체와 함수입니다.
함수를 직접 만들 줄 알아야 합니다.
0-2. 함수!
⇒ 남이 만든 함수 method와
⇒ 내가 만든 함수 modeling이 있습니다.
⇒ 함수를 직접 만들 수 있다면 당신은 구조화를 할 수 있다는 뜻입니다.
생각보다 이것이 되는 개발자는 많지 않다고 합니다.
어째서 일까요?
그것도 중요하겠지만, 더 중요한 것은 그렇다면 내가 이것을 할 수 있게된다면 하나의 경쟁력을 가지게 되는 것이겠지요?
0-3. 제어문
제어문은 연구가 필요합니다. 
⇒ 이 제어문은 사람마다 어떻게 쓸지 천차만별이기 때문입니다.
⇒ 내가 이 제어문을 완벽하게 다룰 수 있다면 그것만으로 대단한 것이니 칭찬해주도록 합시다.
0-4. 서비스
⇒ 네트워크와 서버관련 직무입니다.
⇒ 강사님의 추천은? ⇒ 알기 쉬운 책을 읽어보는 것입니다.
0-5. 개념 concept
⇒ 결정을 할 수 있어야합니다.
⇒ 정확히는 결정을 잘 내릴 수 있어야 합니다.
같은 목표를 두고 여러사람이 경쟁을 할 때, 사람마다 하는 방법은 제각기 입니다.
어느 방법이 옳은지는 알 수 없습니다. 하지만 설계를 하고 개념을 정하고 계속해서 내리다보면
나의 선택이 옳지 않다 ⇒ 대체적으로 옳다로 갈 수 있습니다.
설계를 해보도록 합시다. 뭔지 몰라도 겪어봐야 느는법입니다.
0-6. 정체성!
1. this 객체 생성
1-1. Error!
우리는 원하지 않는 것을 에러처리 해버릴 수 있다.
⇒ 에러는 반가운 일
⇒ 에러없이 실행되는 것이 사고이다.
“개발자는 에러를 일부러 발생시키고 있다.”
⇒ “틀린 작성법이 아니다.”
에러가 나기 때문에 그것을 캐치하고 고칠 수 있다.
버그와는 다르다!
1-2. 생성자 함수!
⇒ class와 constructor set get등을 사용한다.
⇒ 생성자 함수안에 함수를 작성하면, 매서드의 방식으로 활용할 수 있다.
⇒ 해당 함수는 덧셈하나를 위해서 ‘규격’을 만드는 이상한짓을 한 것이다.
타입을 여지없이 만들었다
⇒ number타입만 받도록 하였다.
함수가 아닌 → 매서드로 만들었다.
이것이 시사하는 바가 무엇인가?
⇒ ★”원하는 것이 아니면 절대로 가동되지 아니함.”
객체명 instanceof 생성자함수명
⇒ 생성자 함수의 규격을 따른것이 맞는지 검사하는 코드.
⇒ 이 객체는 생성자 함수에서 나온것이 맞습니까? boolean타입을 반환함.
일반 함수 → 변형의 여지가 약간은 있지 않을까? 하는 뉘앙스
생성자 함수 → 진지하게 사용하는, 궁서체
⇒ 오차가 있어선 아니됨. 거푸집을 만든다는 느낌.
1-3. this!
⇒ this는 너무 유연해서 → 물렁물렁하다.
⇒ 확고한 것을 좋아하는 개발자의 세계에서 이것은 매우 양날의 검이 된다.
잘만 사용하다면 정말로 편하다.
못쓰면 에러의 온상이다.
⇒  this를 만났을 때 ‘ 당황하지 않고 확인하는 방법’을 배운다. ← 오늘의 키워드
각각의 this가 무엇을 가리키는 지 확인할 수 있도록 한다.
⇒ 내가 this를 만난다면 가장 먼저 해야할 것은 콘솔창에 찍어서 확인하는 것이다.
자바스크립트 규칙(룰)상
기명 함수 선언 방식에서의 this는 
⇒ 깔끔하게 최상위 객체(root)를 본다.
= Node.js → global
= browser → window를 바라본다.
※ 함수 선언방식에서 this를 맞이하면 긴장할 필요가 있다.
그것이 무엇을 가리킬지 모르기 때문이다.
고로 되도록이면 this는 생성자 함수 혹은 매서드를 만들 때를 제외하고는 사용하지 않는다.
※ 이유는? ⇒ 너무 변화가 심하기 때문이다.
this를 많이 쓸수록 ‘코드가 유연해진다 ‘ 
⇒ this를 많이 쓸수록 ‘개발자가 괴로워진다.’
JAVA,C#,C++ → 객체 지향언어이기 때문에 생성자 함수가 정말로 많이 쓰인다.
⇒ 애초에 태생부터 C언어에 불만을 가진 사람들이 (불편해서) 만든 것이기 때문에
⇒ 정말로 많이 비슷하다.
⇒ 억양만 다른 사투리같은 것이라고 생각하면 좋겠다.
⇒ 무엇을? 생성자 함수를.constructor function
1-4. 자바스크립트의 경우
⇒ 만들어 ‘진’ 생성자 함수를 사용할 때가 훨—-씬 더 많다.
⇒ 익힐 것이 많은 언어
⇒ 만들 것이 많은 언어는 아님 - 다 만들어져있음
forEach(), → if, array, callback, return
“만들지 않아서 생기는 이해부족을 막으려고 노력중인 강의 & 훈련이다.”
★ “다른 자스유저들은 여러분들 처럼 하지 않음.”
⇒ 그래서 내가 이기기 쉽다!
다양한 언어를 ‘전반적으로 난이도를 낮추는 방법’
⇒ 생성자 함수를 사용하는 패턴을 익힙시다.
함수형 프로그래밍 → 현대적입니다.
⇒ 대응이 빠른 형태에서는 적극도입이 되고있습니다.
⇒ React → 완전히 체계를 바꾼 사례입니다.
다른 언어들은 굳이 모듈, 어려운 규칙을 만들지 않는 이상 함수형을 하고 싶어도 못함.
내가 뜻을 펼칠 곳이 ‘자바스크립트’가 아닐 수도 있는다는 전제하에.
⇒ 생성자 함수는 필요한 존재이다.
기존 서비스에서는 → 언어버전업데이트는 쉬운일이 아니다.
⇒ 시간이 매우 많이 소요됨, 근데 효과는 미미함.
⇒ 그래서 안하게 됨.
2. data.go.kr
⇒ 도메인.go.kr ⇒ 국가기관이라는 뜻
→ 세금으로 만들어진 서비스
→ 다른 나라는 좀처럼 없는
⇒ 상당히 규모가 큼

URL: https://www.notion.so/24-06-03-bb54323483194e8a86b138876b6030ed
0. 수업 시작 전.
0-1. 한달을 뒤돌아보며 이번 한달을 계획해봅시다.
5월 한 달은 어땠습니까? 기억나는 것은 있습니까? 무엇이 기억에 남습니까?
⇒ 나는 5월달에 개인 블로그를 만들어보고자 했습니다.
⇒ 하지만 블로그에서 메모장으로 격하가 되었습니다.
⇒ 이것은 확실히 기억이 납니다.
그렇다면 다른 기억은 없으십니까?
⇒ 놀랍게도 Node를 처음 배운 달입니다.
⇒ 그리고 나는 당연한 사실을 다시 깨닫는 날이기도 했습니다.
⇒ html은 :(콜론)을 제목으로 인정하지 않습니다.
⇒ 포켓몬의 한 종류인 타입 : 널 덕분에 알게된 정보기도 하고,
⇒ 생성할 파일의 이름을 ‘넘버 : (이름).html’으로 하려다, 계속해서 뜨는 오류때문에 알게되었기도 합니다.
외에도. setTimeout이나 setInterval등 동기와 비동기도 알게 된 달이기도 합니다.
동기 비동기로는 하늘에서 네모가 떨어지는 버튼을 만들어 보았고,
readline을 통해 간단하게 CLI환경에서 자신의 지식검증게임같은 것도 만들어 보았습니다.
이것들은 나에게 있어서 과연 무슨 영향을 주고, 무슨 영감을 주었습니까?
⇒ 게임의 구성을 생각할 수 있게 되었습니다.
⇒ 문제를 내고 정답을 입력하는 구조는 결국 모든 것입니다.
⇒ 이것을 잘 생각해보도록 합시다.
0-2. 일정을 짤 때 잘 생각해 둡시다.
⇒ 이번 주는 목요일과 금요일이 쉬는 날입니다.
⇒ 이것은 하나의 기회입니다. 
⇒ 강사님의 추천방식 :
밖으로 나갔으면 좋겠다. ( 머리 감고, 씻고 )
한 10분정도 산책을 나갔다 오세요.
0-3. 금주의 키워드 ( keyword )
Restful API(Representational State Transfer)
AJAX(Asynchronous JavaScript And MXL)
Constructor function ⇒ 생성자 함수.
⇒ 대규모의 객체를 맞이하게 될 것입니다.
⇒ 생성자 함수를 가지고 AJAX”통신”을 하게 될 겁니다. 
⇒ “통신” = ‘Protocol’덩어리
⇒ JAVA에서 따왔고, C++이 모토이다. ( JAVA는 이것만 쓰게 되어있다. )
⇒ 이것을 잘 이해를 한다면 다른 언어를 만날 때 Learning curve가 확 줄어든다.
Git
⇒ commit 빈도와 branch 사용 빈도를 보면 내가 Git을 잘 사용하는지 알 수 있을 것이다.
⇒ Git 명령어 알아두면 좋은 것.
git rebase
git stash
git tag
0-4. 금주 강의 일지.
6/5 RESTful API - 외부데이터 테스트
6/6 현충일
6/7 휴강일
⇒ 다음과목 : 데이터베이스 (패키지) ⇒ React, express
6/17(월요일) - Project A 팀 조직
⇒ 5명씩 4팀 ⇒ 모두 랜덤 ⇒ 팀장도 랜덤.
⇒ 이유는? 회사에서 내가 상사와 동료를 고를 수 없기 때문이다.
⇒ 협업 능력 및 관계 능력을 중요히 보기 때문에 더욱 랜덤으로 
⇒ 중요도는 압도적으로 ‘중요’☆
⇒ 팀 빌드 작업 → 규칙, 호흡, 스타일파악 등등
⇒ 팀 소개 페이지와 같은 간단한 것을 만들 예정.
팀장 → 결정 ( 리더쉽 )
팀원 → 결정을 따르고, 의견을 낸다. ( 팔로워 쉽 )
⇒ 수평적구조로 결정만 하는 사람(팀장)과 의견만 내는 사람(팀원)
1. git branch
브랜치를 그냥 만들어보십시오.
git branch work-1 ⇒ 넘버링을 붙일 요량으로 하이픈을 달음.
1-1. branch를 만드는 전략!
파일명당 브랜치 하나씩
⇒ work-1 브랜치에서 work-1 파일 만듦
work-1은 복습
⇒ work-2 브랜치에서 work-2 파일 만듦
work-2는 생성자함수 작업.
각자 달라서 충돌나지 않음. ⇒ 충돌을 미연에 방지할 수 있음.
1-2. 주석다는법.(?) (가이드?)
파일명 위에다가 정리해서 자신이 무슨 작업을 할 것인지, 미리 적어놓는다.
간단한 명세라고 할 수 있다.
함수를 선언하면서 함수의 로직을 설명하는 주석.
⇒ 해당함수의 목적은 매개변수 2개로 각각 객체의 이름(key)와 값(value)가 되었으면 좋겠다.
매개변수의 a는 변수이기 때문에 대괄호로 감싸줄 필요가 있다.
localVariable[a] = b; 의 형태로 감싸준다.
점표기법(dot notation)이 아닌 대괄호 표기법을 사용해서 매개변수 a를 키값으로 매개변수 b를 리터럴값으로 객체를 생성했다.
만약 당신이 막혔다면?
⇒ 일단 브랜치를 생성.
‘가장 기본형’으로  시도.
⇒ 해결할 때까지 해당 브랜치에서 계속해서 시도.
해결을 했다면?
⇒ 커밋을 하고 브랜치를 다시 바꾼다. 
⇒ 커밋을 하지 않으면 브랜치가 변경되지 아니함.
★아무리 느려도 해야 되는 일★
⇒ 내 예상대로 나오지 않으면
⇒ ★바로 멈추어서 점검해야 한다.★
⇒ “내 예상이란?” → 내가 만든 함수를 말하는 것. 
⇒ 내가 만든 함수는 설명 할만큼 이해를 해야 한다.
⇒ 이렇게 하지 않으면 ‘사고’가 난다.
branch 작업은? :
⇒ “ 한번에 한개씩만 하세요.”
⇒ 브랜치 + “뜯어서 본다.”
⇒ “그거 한개 뜯어서 확인해볼래요?”
아! 하지만 해당 함수의 문제점. []대괄호 표기법을 사용하면 num타입의 변수를 넣었을 때, 문제가 생길 수 있다.
if문의 조건을 걸어주어서 문자열만 받을 수 있도록 하였다.
새로운 브랜치를 만들고 새로운 파일을 생성하였다.
⇒ work-3브랜치 work-3.js 파일
work-3함수를 작성하고 모듈화하였다.
이후 모듈을 실험하기 위하여 새로운 브랜치 work-3-1을 생성 및 헤드를 옮긴다.
test.js에서 모듈을 호출.
⇒ 모듈은 만드는 파트가 있고, 쓰는 파트가 있습니다.
⇒ 기본적으로 모듈은 하나의 파일이 하나의 기능을 합니다.
만드는 파트 → Modeling
쓰는 파트 → Controller
모듈을 사용하면서 상징화의 수준이 높아지는 중입니다.
→ 처음에는 조금 복잡해도,
→ 일련의 규칙이 훨씬 편해진다.
for문으로 사용한 것을 배열이기 때문에 forEach를 사용해보자. ⇒ work-4 branch
2. memo
2-1 브랜치의 갯수가 해프다.
파일을 만든만큼은 기본으로 갯수가 존재하고,
무언가 시도할때마다 또 만듦
버리는 브랜치도 꽤 있음
커밋도 많이 한다. ⇒ 커밋자체가 몇줄이 되지 아니함.
2-2. 함수를 통해서 객체화
⇒ 어떤 데이터의 딱지를 붙이는 함수를 만듦,
⇒ 배열, 객체가 너무 많이 쓰이기 때문이다.
함수가 호출되면 → “객체가 만들어지는” 굉장히 많이 쓰임.
필요하면 매개변수의 타입을 ‘제한’하는 ‘안정성’을 챙길 수 있음.
얼추 모양이 잡히면 모듈로 변환함. ⇒ 추상화 작업.
2-3.약속!
이 사람.. 브랜치를 정말 많이 쓰는구나!
커밋을 참 ^^좋아하는 구나!
리턴이 잠깐만,,,왜… 왜 왜 헷갈리지?????
막힐때의 약속!
브랜치를 만든다.
기본형을 만들어본다. ★★★★★
이해가 되는 시점까지 테스트하기!
소스코드가 많은 형태 → 팔레트 기능을 대체한다.
“형상’관리 도구 → git의 특징.
Modeling한다 ⇒ 무언가 해내는 / 함수 선언
Controller ⇒ 무언가 수행하는 (실행하는) / 호출
View : 보이는 부분도 편집.
코드에도 유형이 있다.
DOM API vs Node.js
다른 ‘작성법’이 필요 없다. ⇒ 생산성의 이점.
기승전 ‘객체’
객체가 ‘내 도구’가 되어야 한다. ⇒ 그래야 편할 것이다.
“그래봐야 객체” ← 이런 상태가 되어야 한다.
3. Constructor function
만드는 것에 “어떤 규격(size)”을(를) 정하자.
규격에 해당하는 것들을 만들자.
“규격을 만드는 함수 “ ⇒ 옷 사이즈같은 것에 해당.
“붕어빵 틀 “ → 거푸집.
3-1. 문법.
해당 코드를 실행할 경우, ramenName이 나오지 않는다.
그리고 진라면을 사용해도 진라면이 출력되지 않는다.
하지만 함수로 만들면? undefined가 떠버린다.
그리고 객체의 이름이 붙어있지 아니함.
당장 위의 코드는 생성자 함수 constructor function으로 만든 것이다.
⇒ class ⇒ 객체에 이름이 붙어있다.
하지만 일반 함수로 만들면?
⇒ 그냥 일반 객체가 출력이 된다. (이름이고 뭐고 없음)
instance : 인스턴스
찍혀서 나온 라면을 → 인스턴트 음식.
⇒ class는 혹은 생성자함수는 instance가 찍혀져서 나오는 규격을 가지고 있다.
⇒ 같은 객체인데 마크가 붙는다!
⇒ 마치 made in korea, made in china와 같다.
3-2. 객체를 만드는 두가지 방식
class 방식과
일반 함수 리턴 방식
⇒ 이 두 개의 차이는 ‘인스턴스’에 있다.
어쩌다가 나온것일까? 생성자 함수란 것은?
⇒ ‘자스표준님 제발 규격문법 좀 만들어주세요.’
⇒ ‘객체를 써야되는데 구별이 안가서 죽겄습니다.’
?? : “그러라는 언어가 아닌데?”
⇒ ‘그냥 만들어!’
?? : “ 그러면, 급한데로 객체 잘 쓰는 언어에서 가져올게”
⇒ ‘기왕 하는거 JAVA에서 가져오는건 어떰?’
?? : “okeydokey”
둘은 같은 기능을 하지만, 표기법에서 차이가난다.
어째서 이런게 필요할까?
⇒ 규격이 너무 많이 필요해서 코드리딩이 어렵기 때문이다.
⇒ ‘문법’상으로 구별이 가지 않는다.
⇒ 이를 sementic sugar라고 한다. ⇒ 왜 sementic sugar…?
⇒ JAVA의 스타일을 따라가고 있다.
⇒ 객체지향 프로그래밍 = 생성자 함수 지향 프로그래밍.
코드가 짧을수록 의미가 적다.
코드가 길면 길수록 의미가 매우 커진다. ⇒ 진가를 발휘한다.
new라는 키워드가 나오면 ⇒ 무언가 ‘규격’에 다르고 있다.
class 함수명{
 constructor(매개변수){
  this.키값 = 매개변수 // 가능
 } 
 set 키값(매개변수){
  if(키값 !== 매개변수){
   console.error(가능);
  }
  
 get 함수(){
  return this._매개변수;
  }
 }
}
결국 미래에는 거의 모든 작업을 생성자 함수로 작업하게 될 예정이다.
⇒ 어째서?
⇒ 예상외의 일을 감지하는 것보다, 코드를 직접 보는 것이 훨씬 나은 선택이기 때문에,
※ 암묵지
선형적
웹 서비스 애플리케이션
생성자 함수 ⇒ constructor function
⇒ 편의성을 위해서, 하위 키워드를 지원.
⇒ 전적으로 개발 편의성을 위해서, 가독성을 위한 것.
⇒ set, get → setter, getter ⇒ deepDive책을 반드시 참고할 것
⇒ new 대문자() → 무언가의 규격을 통과하였다는 뜻.
⇒ instance “인스턴스” → 나는 규격화 조건을 통과한 객체입니다.
→ new XMLHTTPRequest()
→ new Date() 
→ new Promise …etc

URL: https://www.notion.so/6-79b16dfb475642f9af531f00bec0d2f3
24/06/03
24/06/04
24/06/05

URL: https://www.notion.so/6-b5d3e1c836e4412183af22698665588b
6월 첫째 주
6월 둘째 주
6월 셋째 주
6월 마지막 주

URL: https://www.notion.so/24-05-31-6de3c7429f2c4f868e063ef1bb63e227
0. 수업 시작 전.
작업은 하던대로 하십시오.
오늘은 5월의 말일 입니다. 강사가 직접 학수고대를 하고 있는 날입니다.
2024년 5월 말일 날 ‘나는 이런 작업을 했다.’라는 나름의 형태를 남겼으면 좋겠습니다.
오늘은 내 설계와 나만 있는 세상으로 좁히고 완전히 몰입해보도록 하십시오.
타의적인 시선 신경쓰지 마십시오.
남이 어떻게 보던 말든 내 것을 하면 됩니다.
1. data.go.kr회원가입함.
아이디를 잊지 말 것.
⇒ 다음주는 데이터를 만져볼 계획, 네트워크를 만져볼 계획이다.

URL: https://www.notion.so/24-05-30-9b92b451623a4b36aa26a9e4a053a742
0. 수업시작 전.
오늘 목표로 했던 것을 모두 해봅시다!
⇒ 내일은 더러워진 코드를 정돈하는 것은 어떻습니까?

URL: https://www.notion.so/24-05-29-93beb32d853e4c59bbd8552af0b0d980
0. 수업시작 전.
0-1. 놓아야할 때 입니다.
스트레스 해소를 미디어로 하지 마십시오!
⇒ 하지만 인지적으로 내가 계획적으로 한다면 스트레스 해소를 미디어로 하셔도 됩니다.
그냥 미디어를 키지 마십시오!
⇒ 습관적으로 유튜브를 키거나, 습관적으로 tv를 키는 행위 등등 습관적으로 미디어에 다가가는 것을 경계해 주십시오. 즉, 무의식으로 키는 미디어를 최대한으로 막아주십시오.
→ 할게 없으면 유튜브 키는 것 혹은 커뮤니티를 키는 것, 하지도 않을 것인데 컴퓨터를 키는 것 등등
→ 잡생각이 들면 차선책을 찾게 됩니다. 
→ 지금 저희는 건설적인 삶을 쓰고 있기 때문에, 최대한 지금 이 순간에 적응하셔야 합니다.
⇒ 스스로를 묶을 줄도 알아야 합니다. 
“아~ 공부해야되는데…” = X
“머리가 복잡하다. 어차피 이 머리로는 공부가 안 된다. 이것을 보고 공부를 하자.” = O
쇼핑몰 ( ? )
⇒ 이건 모르겠네.
⇒ 쇼핑몰의 마케팅에 집중력을 빼앗길 수 있다.
강사님’s want ⇒ 집중력을 빼앗기지 마십시오!!!
☆★10분 활용법☆★
⇒ 10분정도만 멍하니 자신의 작업을 생각해봅시다!
⇒ 자신을 핸들링 해보는 것.
자 그렇다면, 내가 해야할 것은 무엇일까? 일단 알람 다 꺼. 이번 쉬는시간에 알람부터 끈다.
1. Git branch
git으로 중간세이브는 알겠다 ⇒ git commit
git으로 내 소스코드를 보관하는 것도 알겠다. ⇒ git push / git clone / git pull
그래서 git branch는 뭐냐?
우리들의 작업에 융통성을 발휘할 수 있게 해주는 ‘삭제’ 작업을 없애주는 매우 중요한 기능이다.
⇒ git branch
1-1. branch
직역하면 ‘나뭇가지’라는 의미이다. 
난이도가 있다. ⇒ 눈에 보이지 않기 때문에 난이도가 있다.
⇒ 커맨드를 익혀야 하는점이 있지만, 어려운 개념은 아니다.
가능성 ( 장점 ) : ( 단점을 상회하는 너무나도 좋은 장점)
내 코드를 commit으로 보관하는 것 뿐만아니라
⇒ 자가복제해서 편하게 실험할 수 있다.
⇒ 다른시도를 하기 위해서 새로운 복제품을 만들어서 사용하는 형태.
⇒ A코드가 있다면 A-1, A-2등 내 맘대로 원본을 파괴하지않고, 복제를 만들어서 실험 → 비파괴적인 코딩이 가능해진다.
⇒ 협업에서 사용하면 매우 좋다! 스스로 혼자 해도 충분히 좋다.
⇒ 기존에 했던 것을 변형해서 사용해보고 싶다. → branch를 사용하세요.
완전히 습관들었다는 가정하에.
⇒ 새로운 시도를 하는데 부담이 없다.
⇒ 새로울 일이 너무 많은 개발자들에겐 너무 좋은 기능. 
협업을 할 때 매우 쓰인다. ← 선택사항이 아님. ⇒ 대신에 재택근무도 가능.
단점 :
해왔던 습관이 아니다.
⇒ ‘브랜치’를 즉, 다른버전을 만든다는 것이 영 낯설음.
⇒ 그래서 더러 실수가 나기도 하지만, 괜찮다. 아직 연습이고, branch니까.
절차가 제법 있는편이다.
⇒ branch생성, branch변경, commit, 기존 branch로 이동, git merge branch
⇒ 까먹을때가 더러 있다.
1-2. branch 명령어
git branch → 브랜치 조회.
git branch 만들고싶은이름(영어여야함)
git checkout(switch) 옮길branch명
⇒ 스위치됨을 확인.
⇒ branch를 핸들링해서 ‘모드’를 바꾼다? ← 라고 이해해보자.
git merge 합칠브랜치명
⇒ 현재 branch에 ‘합칠브랜치명’에서 작업한 것을 병합한다.
⇒ 병합한다는 의미이고, 승인의 형태이다. 내가 한 작업을 그대로 가져가겠다는 뜻. 완료의 의미.
⇒ merge를 했다면 push를 하자 git push origin main
1-3 메모.
git push origin main
⇒’원본 중에, main 이라는 브랜치를 업로드 하겠다.
=== 전체는 아니라는 뜻.
시사점.
⇒ 전혀 삭제를 하지 않았음.
⇒ 카피조차도 딱히 하지 않음.
⇒ 원본을 비파괴적으로 사용함.
→ 모든 작업의 실험 방향을 볼 수 있게됨.
예를 들어서 내가 지금 설계에 적은 시도마다 브랜치를 설정해서 하면? 된다.
하다가 되면요? 그걸 병합하면 되지.
1-★ 시도.
repo를 만들었다 branchHandle
vscode에서 git clone https://github.com/KimInteger/branchHandle.git 을 실행
만들어진 폴더로 들어가서 npm init을 하고 그것을 커밋함.
: 토막상식 ⇒ npm init을 한다는 것은 javascript라는 의미이다. 다른 언어는 또 다른 패키지가있다.
현재까지의 행위를 말로 옮기면?
⇒’저장소를 생성했고, 저장소를 열었고, 프로젝트를 초기화했다.’
git add 파일명을 사용하여 스테이징함.
git commit -m ‘메세지’ 로 중간저장.
git push origin branch ⇒ 원본 저장소에 저장
현재까지의 행위를 말로 옮기면?
⇒ 내 소스코드를 github에 잘 업로드하였다.
→ push만 잘해도 누락없이 나의 코드를 백업할 수 있다.
→ ‘안되서 일단 작업부터 했어요’ = X 기록이 안되면 모든 작업이 누락되어 버린다. 무조건 해결하고 움직이기.
→ git은 stable이 유지가 되어야 한다. ⇒ 안정적으로 항상성이 유지되어야 한다. 
git branch ⇒ 현재 branch를 알려준다. *(에스터리스크)
그래프를 확인
아직 push가 일어나지 않았기 때문에, 원본은 package.json인 상태이지만,
commit을 하기만 한 현재는 push가 되어있지 않다. 현재 나의 파일과 원본 저장소의 파일은 차이가 있다는 뜻.
git branch 만들고싶은이름
⇒ git branch KInt를 입력
git branch로 다시 제대로 입력되었는지 확인.
git checkout KInt 
⇒ branch를 바꾸었다.
KInt일 때 commit을 함.
git checkout main
KInt일 때 생성한 파일이 사라져있음.
git checkout KInt
다시 생성됨.
branch가 main인 상태에서 새로 git branch intK를 생성
git branch로 다시 조회.
app.js를 add.js로 이름을 변경하고 커밋
가지가 생김. 합치면 충돌이 일어나요!
git checkout intK
app로 변경됨. 왜일까요?
⇒ 생성된 시점에선 app이었으니까용.
intK인 상태로 commit을 한다.
git switch main
⇒ intK를 적용하고 싶음. 일단 main으로 이동(큰줄기로 이동)
병에 물을 담았다.
물을 병에 담았다.
main에 intK라는 브랜치를 ‘합친다’
main모드에서 ‘합칠 브랜치를’ 
git merge 브랜치명
⇒ 현재 branch에서(main)에서 합치고 싶은 브랜치’를’ 적을 것
⇒ 메인에 와서 합치는 행동을 하는 중.
⇒ 확인 과정을 거침.
행동방향
“무조건적으로! 시작할 때 브랜치 만들기”
그 와중에도 새로운 실험이 필요해! ⇒ 또 브랜치 만들기.
가지를 뻗어나가는거다. 늘 했던 그거, 처음부터 했던 그것 트리구조.

URL: https://www.notion.so/24-05-28-e8a51213304840d9893c6fd12953608c
0. 수업 시작전.
0-1. 앞으로의 계획.
6월 15일 경 팀을 결성 ⇒ 팀 소개 페이지를 만들어 보세요~
7월 중순쯤 팀프로젝트를 시작. ‘ERP’
8월쯤 세미나가 있을 것.
9월쯤 발표를 시작합니다.
0-2. git fatal에러 확인
fatal: unknown write failure on standard output
문제가 무엇일까 생각해보았다 아무래도 commit메세지에 한글을 적어서 일어나는 일 같았다.
검색을 통해 알아보니 맞다고한다.
git에 명령어를 입력해주면 사라진다고 하는데 명령어를 이해하기 위해 검색을 해보았다.
명령어는 다음과 같았다.
git config --global i18n.commitEncoding cp949
git config --global i18n.logOutputEncoding cp949

git config --global(전역으로 선언) i18n.commitEncoding(커밋메세지를지정) 인코딩방법
git config --global(전역으로 선언) i18n.logOutputEncoding(로그에 나오는 메세지를 지정) 인코딩방법
—global과, commitEncoding은 이해를 하였으나 i18n이 무엇인지 도저히 이해가 가지 않았다.
그래서 검색을 해보았다.
국제화라고 한다.
그렇다면 이렇게 이해할 수 있을것이다.
깃'의' 구성'에' 전역으로선언'한다' 국제화인데커밋에사용되는언어를인코딩할꺼야 이방법을사용해서
⇒ issues!
vscode자체가 utf-8의 방법으로 인코딩을 하기 때문에, cp949의 방식은 글씨가 깨지는 현상이 발생한다.
나중에 더 제대로 알고 쓰도록하자
git config --global --unset i18n.commitEncoding
git config --global --unset i18n.logOutputEncoding
1. github
1-1. git자체는 github와 관련이 없다!
github는 소스코드 저장소이다. 어째서 github를 쓸까?
⇒ github는 마이크로소프트의 것이기 때문이다.
⇒ 그래서 vscode와 연관이 매우 좋다.
⇒ 마이크로소프트? ⇒ 챗 지피티도 마이크로소프트의것
⇒ 아주 공격적으로 성장하는 중 사실상 개발자들의 커뮤니티이다.
1-2. github를 사용할 때 하면 안되는 것!
private는 사용하지 않는다.
⇒ 일반적으로 개발자들은 공유하는 문화가 있다.
⇒ “쓰고 싶으면 편하게 쓰세요. 니가 내 코드를 쓰는게 나한테 꽤 기쁨이야!”
⇒ 깃허브에 개발자들에게 쓸만한 것을 만들어 올려서 ← 후원을 받는 경우도 있음.
github에서 저장소를 만들기 시작하는 순간부터 git init은 안쓴다.
git clone을 사용
git clone : remote에 있는 소스코드를 local로 복제한다.
사용법 : git clone 주소
1-3. github는 뭘 먹고 살아요?
팀 작업을 private로 운영하는 것 
팀 작업 private 저장소의 권한 설정을 유료로 판매한다.
개인은 모두 무료이다 ⇒ 사용자 유치를 위함.
1-4. push 와 pull
git push origin branch(vscode왼쪽아래표기)
“깃아 내가 원본에 ‘main’이라는 줄기가 있거든? 그것을 업데이트(업로드) 할게”
여기서 origin은 github에 있는 것을 의미한다.
원본을 깃허브에서 만들고, 사본을 본따서 가져온 후 
⇒ 작업을 진행한 다음에
⇒ 원본에 적용하는 작업을 하는 것.
깃 허브에 올라간 것을 확일할 수 있다.
git commit = “숨쉬듯이 많이”
git push = “퇴근할때” / “동료가 요청할 때”
git pull = “출근해서”
우리가 보고있던 것은 Code부분 ⇒ 저장소 본연의 역할만 함.
issues ⇒ github 서비스
⇒ 계획력있는 작업을 해보자.
이슈를 추가할 수 있다.
1번 작업, 2번 작업, 3번 작업으로 분류해서 할 수 있다. 설계를 하면서 이슈를 달아버릇 한다면, 업무 효율에 도움이 된다.
예를들어서 내가 지금 블로그를 설계하는데 1번은 글쓰기 2번은 글삭제 3번은 글 수정 등등, 으로 해놓고, 몇번 작업을 할지만 정하면 되는 것이다.
그것이 뭔일인지는 모르겠지만, 타인과 함께할 때 타인에게 부탁하기 편해진다.
예를 들어 OO씨 3번작업해주실래요? 
OO씨는 3번작업이 무엇인지 모르지만, 3번작업이 있다는 것이 알기에 3번작업으로 들어가서 확인해서 알 수 있다.
project나 wiki를 활용해보자.
project = 칸반보드를 만드는 것
나의 순서와 해야할 일을 적어놓고 사용하자.
todo 와 in progress, done이 있다.
할일 ⇒ 진행중 ⇒ 완료 이다.
⇒ push와 pull은 협업을 위해서 사용하는 것이다! 
1-5. 설치해야하는 extensiton ‘GitHub Pull Requests’
vscode내에서 issues를 관리할 수 있다.
★ 오늘 배운 것은?
깃허브를 사용하는 법을 배운것이다.
branch는 깃허브와 관계가 없다! ⇒ branch는 매우 복잡하고 어렵다.
git은 몸에 완전히 붙어야 한다. 
⇒ 키보드를 쓰는 것 만큼 git도 몸에 완전히 붙어야 한다.
⇒ 설계와 완성도 중요함. 지금 배운 것은 설계에 필요한 만큼만 배운 것이다.
반복연습 ⇒ 열 몇개 이상 안할 것
설계를 구현 하는 것이 중요하다.
설계에 쓰일만한 커밋전략을 세우자!
오늘 훈련할 양은 스테이징과 커밋이 잘 되는지 확인 ⇒ push까지 잘 되는지 확인한다.
★ 오늘 해보세요! ⇒ 금일 미션
설계에 git을 포함시켜보세요!
그렇다면…
project를 만들고 이것은 그냥 큰 단위를 나누는 것
issues를 만들고 ⇒ 각 파트 별로. ⇒ project의 큰 단위를 쪼개는 것.

URL: https://www.notion.so/24-05-27-21ec2446345344b1802cab3965b97641
0. 수업 시작 전.
0-1. 금주의 목표 
금요일에는 내가 설계했던 것을 만들어 봅시다! 쉽진 않을 것 같은데? 어디까지 만들지 한정을 지어 봅시다.
월요일 : 반복의 함수화, 함수의 모듈화
화요일 : 폴더를 읽어내서 진짜로 저장소처럼 활용하기
수요일 : 삭제기능 설계
목요일 : 삭제기능 추가.
// 이거 readfile로 json읽어서 응답해주면 되는거 아닌가? 일단 쏴주긴 할 거 아니야.
금요일 : 작성,삭제이 가능한 간단한 블로그 스켈레톤이 완성되었다! 이제 서버에서 쏘아진 정보를 js에서 읽어내 보자!
CRUD의 D를 알아내자.
innerMission 균형감있게 집중력을 유지하는 법.
1. Git. 
Git을 왜 사용할까요? 
코드를 받을 때 더 이상 메일로 주고받지 마십시오!
소스코드가 절대로 날아가지 않는다.
언제든지 내가 원하는 시점으로 돌아갈 수 있다. ★ (핵심)
‘코딩’이 아닌, CLI소프트웨어 중 하나이다.
git을 활발하게 쓰는 회사를 다녔으면 좋겠다. ⇒ 재택근무가능 회사라는 뜻.
키워드 10개, 습관 붙이기. ← 이거면 끝!
 최종형태(배웠을 때 기준)
언제든지 꺼내어 쓸 수 있다. (특정시점으로)
version 1, 2, 3, 4등 여러개를 만들 수 있다.
손이 알아서 써진다.
★ 배포 자동화용으로도 쓸 수 있다.
⇒ 이것까지 다 할 수 있어야 한다!
SI : 아웃소싱의 형태를 띄게 됨(외주업체) ⇒ 의미가 변질 됨.
보통 사람들에게 알려진 3D업종의 프로그래머를 의미.
밤샘 근무가 일상인 형태
SI 업체 : system integration, 시스템 통합업체
CI 업체 : Continuous integration, ⇒ 지속적인 통합 : 유지보수 업체.
1-1. Git 용어
fetch, rollback(빽섭), update, release, test server, etc…
git init
git add
git status(스테이징 검사, 에디터가 도와주는 부분)
git commit
git checkout
git log ※ 에디터가 도와줌 ⇒ git graph 확장자.
1-2. 기본형 vs Github버전
local환경
remote환경
.이름 ←”숨긴다!”라는 의미로 확인할 수 있다.
수업시간중 깃 명령어 사용했던 순서
git version으로 버전 확인
git init으로 .git폴더 생성 git 초기화 단계.
ctrl shift g를 통해 소스제어에서 밑 사진을 확인
diff
diff이라하여 difference를 의미 ⇒ 무엇이 생성되었다.
초록색 = 추가, 빨간색 = 삭제의 의미이다.
git을 초기화 한 이후 부터는 해당 ‘저장소’의 모든 파일이 다 추적된다.
⇒ 소스코드가 날라갈일은 없어진다. 일종의 보증.
git add 파일이름
⇒ 이 파일을 버전관리할거야.
명령어를 입력하면 해당 파일이 스테이징 된다.
스테이징이란? 
⇒ 무대 : 추적할 준비가 되었다.
staging : 버전관리 할 것들을 골라내는 편
git commit -m ‘메세지’
스테이징된 파일을 커밋할거야. -m은 설명을 달아주는 것. 
깃은 메모없이는 절대로 기록을 할 수 없게 되어있다. 그렇기 때문에 commit작업을 통해서 설명을 해주어야 한다.
시스템당 딱 한번 있는 일 (내 정보 등록)
git config —global user.name “내이름”
git config —global user.email”내이멜”
git graph ← 확장팩extention설치.
→ commit을 눈으로 확인할 수 있도록 만들어준 시각화 도구.
⇒ commit이 되었음을 확인하는 것은 버전이 등록되었음을 의미한다.
⇒ git log / git log —graph로 CLI환경에서 확인할 수 있다.
q를 누르면 깃의 화면에서 나갈 수 있다. ⇒ 조작을 할 수 없는 상황에서 탈출
중간정리
무언가 작업을 함.
diff → 차이점을 확인(작업내역)
staging → 무대에 올린다. 기록을 하겠다. git add 파일명
commit → git commit -m ‘이 커밋의 의미 즉, 작업의 의미, 작업설명’
git graph 확장자를 사용했다. 사실은 git log커맨드를 사용하면 된다.
GUI를 말리는 이유.
회사중에 GUI를 못쓰게 하는 곳이 있다. CLI를 고집하는 회사가 없지 않음.
Linux, 배포환경에서는 사실상 CLI로만 가능하다. = sourcetree, github Desktop등 쓰기는 편하지만 배포환경에서도 버전관리를 해야하기 때문에 CLI를 써야한다.
⇒ GUI환경을 쓰지 못하게 되는 경우가 있다. …Linux환경
돌아가는 방법.
돌아가고 싶은 것의 commit부분을 카피한다. 이후
git checkout 카피한commit
⇒ 그 당시 특정 시작점으로 이동한다. 
이 상태에서도 git graph는 남아있기 때문에 돌아가기위해서 마지막으로 commit 한 것의 commit코드를 복사하여 git checkout 복사코드 를 사용한다.
⇒ 이것이 그 유명한 rollback이다.
⇒ 마치 타임머신처럼 내 작업내역을 마음대로 돌아다닐 수 있다.
낯설지만?
오늘 git을 배움으로서 얻게 되는 것은
코드에 대한 기록 + 백업이다. ⇒ 코드 자체랑 관련이 전혀 없다!
때문에 손으로 히해하는 문제이다. 손에만 익히면 된다.
혹은 회사마다 룰이 다를 수 있기 때문에, 그냥 쓰는 법만 알면 된다.
Q. 파일을 언제 기록하나요?
A. 파일을 만들때, 시도할때,종료할 때.
⇒ “숨쉴 때’ 숨쉬듯이 commit을 하세요.
교부된 책은 ‘개념’만 확인 하는 용도 → 되도록이면 CLI를 활용할 것
어째서? ⇒ server ‘환경’ ⇒ Linux ⇒ GUI가 없음.
현실 : 귀찮아서 client킬 시간이 없음. 그냥 빨리빨리 CLI로 처리하고 말지.
VSCODE, IDE모두 git 인터페이스를 지원해준다. 때문에 기본기인 CLI에 익숙해질 필요가 있다.
별도의 클라이언트를 사용하는 것은 ‘지양’해주었으면 한다. ← 강사님 comment
repo만들기.
github에 접속하여 +create를 한다.
반드시 public으로 만든다. ⇒ 나는 면접을 받을 것이니까 praivate일 필요가 없다.!
git clone 해당repo의 주소.
⇒ 이 방식을 사용할 경우 git init을 하지않아도 된다. 이미 .git폴더가 초기화되어있음.
git push origin main(브랜치)
1-3. 개발환경셋팅. - env구성, 환경구성
내 프로젝트에 걸맞는 형태로 셋팅을 ‘보통’ 수동으로 하는 편이다.
⇒ npm, git, …ETC
commit 하나당 한가지 일만 한다. 하나의 파일 하나의 commit
⇒ 정말 커밋하는 일이 많아진다. 
⇒ 중간세이브를 잘한다는 의미는? 얼마든지 시행착오를 ‘보완’할 수 있다.
⇒ 언제든지 내가 원하는 시점으로 돌아갈 수 있다.
commit의 빈도는 얼마든지 변덕이 가능한 상태여야 된다. 
⇒ 중간 커밋을 덜하느니 많이 하는게 낫다.
1-4. 금일 미션
나의 작업에서 git commit으로 중간 저장만 계속하세요.
git은 버전관리 도구 이다!
git : github가 메인 도구 소프트웨어
→ 백업 & 협업까지 모두 사용 가능
→ 명령어에 대한 반복사용 ‘만’ 필요하다.
→ CLI환경에 대한 거부감 낮추기.
⇒ 최종적으로 모든 코드는 github에 올라가야 하는 것 ( 취업 )
개발자의 경우 ‘로컬’ 파일은 믿지 않는다.
local → github(코드관리) → 배포
새 디렉토리를 로컬에서 생성 
git init, npm init
⇒ GET, POST 기본 서버 만들기.
⇒ 새로운거 하지 말고, 늘 했던것으로.
⇒ 스테이징과 커밋을 추가만해주기.
SVN : x 잘 사용안해용. 일부 회사가 사용. 앵간하면 git쓰는 회사로 갑시다.
1-5. 익일을 위한 키워드
키워드
git clone
git push
git pull
중요한 키워드 ⇒ branch 키워드 핸들링

URL: https://www.notion.so/5-27f656836d9945e7bb76ecc500c92324
24/05/27
24/05/28
24/05/29
24/05/30
24/05/31

URL: https://www.notion.so/24-05-24-9e3dd0b33bc349d6a6d0c30841785154
0. 대화를 해봅시다.
수다가 아닌, “대화”를 해봅시다. 친구와 진솔한 이야기를 나누면서 생각의 영역을 키워가 봅시다.
내가 만든 문제는 내가 해결해야한다.
1. 설계를 두려워 하지 마십시오.
개발자는 머리를 쓰는 직업입니다.  하드코딩의 시대는 갔습니다 나보다 GPT가 더 코딩을 잘합니다. 나는 설계를 할 줄 알아야합니다. 설계는 나의 영역이고, 로봇은 침범할 수 없습니다.
왜냐하면 로봇은 스스로 생각하지 않기 때문입니다. 무언가의 인풋이 있어야 아웃풋을 낼 수 있습니다.
설계를 할 줄 알아야 로봇에게 일을 시킬 수 있습니다. 설계를 무서워하지 말고, 설계를 싫어하지 마십시오. 나는 설계를 좋아하고 있었으면 좋겠습니다.
2. 5년 후의 6월의 나는 무엇을 하고 있을까?
그것을 위해서 다음주에 내가 만드려고 하는 것을 완성시키는 모습을 보입시다.
5월말 6월초라는 기점을 잡아서 좀 어려운 목적을 잡고, 그것을 성사시켜서 미래의 나에게 추억거리를 줍시다! 그것을 감지 합시다!
다음주에 스케줄링을 하면서, 여기까지는 이것은 될 것 같은데요? 를 정해놓자!
이번의 일정체크는 2달간의 일정이 체크 된 것 이었으면 좋겠다.
5월달을 돌아보면서 칭찬할 건 칭찬하고, 부족한 것은 부족하다고 인지하자. 그리고 6월에는 내가 여기까진 하더라 하는 부분을 그대로 체크해서 반영하자.
6월달에는 새로운 목표를 잡아보는 것이다.
3. 다음주부터는 GIT을 시작할 것이다. 

URL: https://www.notion.so/24-05-23-c6d36a6619d2435fa0f4f69c005f780f
0. 수업 시작 전
0-1. 설계를 열심히 합시다!
우리는 설계가 전부입니다! 만드는 것은 무엇? gpt가 할 수 있습니다. 여러분 설계… 설계를 하셔야 합니다..!
고로 글도 써보십시오! → 글을 써서 절차를 익히십시오!
설계서 기반으로 작업을 착수할 것이다.
⇒ 실수도 적어야 하고,
⇒ 시행착오도 모두 적어야 한다.
0-2. 6/14일부터는 JavaScript를 버리고 TypeScript를 사용한다.
TypeScript는 JavaScript의 불편한점을 상당히 해소한 형태의 언어입니다.
0-3. 내일은 블로그를 만들 것 입니다.
설계부터 시작해서 블로그를 만듭니다. 설계라 함은 내가 모르겠는 것도 적는 것이 설계입니다. 그냥 머릿속에 나오는 모든 것을 글로서 적고, 순서를 지키지 않아도 좋습니다.
일단 다 적고, 그 다음에 정리를 하고, 순서를 하고, 하다가도 모르겠으면 또 적고, 설계란 끝까지 함께 나가는 것이 설계입니다.
결국 웹서비스를 운영하게 될 것인데 그렇다면 블로그를 하나하나 뼈대부터 만들어봐야 하지 않겠습니까? 열심히 만들어 봅시다. 
바닐라로 만드는 것이 곧 끝납니다. 이제 할 줄 안다고 염두해두고 넘어간다는 뜻입니다.
⇒ 내가 할 수 있고, 내가 말할 수 있다면 그때부터는 편한 것을 사용하는 것이 당연히 효율에 좋습니다.
⇒ 내가 아는 만큼까지를 잘 알고, 그 이후는 편한것을 사용합시다.
⇒ 모르고 편한 것을 사용한다면, 편한 것을 쓸 수 없게 되었을 때, 당신은 아무것도 할 수 없습니다.
⇒ 결국 코어가 있어야 활용도 잘 할 수 있습니다.
1. CLI환경에서 application만들기
1-1. 초창기 컴퓨터의 모습은?
⇒ 명령줄 → commandLine형식이었다.
니가 입력해! 내가 확인할게.
대표적인 것이 CLI이다 Command Line Interface 대표적으로 npm, git 같은 것들이다.
⇒ 일반사용자용X  전문가 개발자용이기 때문이다.
GUI software보다 CLI software가 많으면 많지 적진 않다.
GUI의 한계는 “사람손을 너무 많이 탄다.” = “ 개발자의 품삯이 너무 많이 들어간다.”
⇒ 상업적인 비즈니스가 아닌 이상 거진 GUI는 찾기 어렵다.
1-2. readline
DI 초기화 → package.json을 만드는 작업 자체가 
readline이라는 모듈이 CLI환경으로 질문을 하고 우리가 답을 해주는 형태이다.
readline을 연습하기위해 노드에서 예제를 해보자.
const readline = require('node:readline');

const rl = readline.createInterface({
 input : process.stdin;
 output : process.stdout;
});
안에 객체로 들어가는 것을 따로 빼서 객체를 선언하고 넣어도 된다!
인터페이스를 만들었다면, 기본 method를 사용해보자.
question()매서드 
⇒ rl.question( ‘ string ‘ , callback{});
string에 만약 내가 할 질문을 넣고,
callback의 매개변수는 사용자의 답변을 받는다.
고로 console.log와 백틱을 사용하면?
rl.question('너의 이름은 무엇입니까? : ', function(answer){
  console.log(`당신의 이름은 ${answer}입니다.`);
});

// ! 요청과 응답이네?
다만 이대로 출력을 하면 터미널이 계속해서 새로운 응답을 기다린다. 때문에 꼭 close를 달아주도록 하자.
rl.question("너의 이름은!! : ', function(answer){
 console.log(`당신이 적은 대답은 ${answer}다!!`);
 rl.close();
});
⇒ 이것은 CLI application을 만들때 사용한다. 굳이 따지자면 back-end에서 사용하는 ⇒app이다.
CLI 입출력 도구라고 명명할 수 있겠다.
햄버거 메뉴바를 만드는 것은 ⇒ GUI application에 해당하는 영역이다. 눈에 보이는 영역.
의문점이 들것이다 process.가 뭐지? process 앞에 하나가 생략되어 있다. 
global.process.stdin // 이 될 것이다.
즉 global 최상위 객체의 키에 해당된다. 그렇다면 stdin은 무엇일까?
Node.js의 입력방식을 가져온 것이다.
→ <input> === stdin, stdout ⇒ standard in / standard out을 이야기 한다.
stdin = 표준 입력 → 입력하는 방법! standard input이라고 이해하자
stdout = 표준 출력 → 출력하는 방법! standard output 이라고 이해하면 된다.
그래픽 처리는 딱히 필요가 없고, 기능호출만 잘하면 되는 것들이 있다. 그럴때!
→ readline이 매우 요긴하다.
이 readline은 사실상 http와 비슷한데
환경을 조성해주는 createInterface();가 있고,
question();으로 질문과 답을 구성할 수 있다. 요청과 답을 할 수 있다는 듯.
close(); 로 응답을 종료 시킬 수 있다.
이외의 event가 있다. 이것을 사용해서 원래대로 돌아간다거나? 혹은 새로운 것을 만든다거나 할 수 있을 것 같다. 찾아보도록 하자.
readline활용 1. 응답을 받아 파일 만들기
이것으로 여러가지를 할 수 있을 것이다. 사용자의 응답을 받아서 그 응답을 제목으로 파일을 만든다고 한다면? 조건을 걸면 된다!
저건 그냥 하나의 퀘스천일 뿐이고 그 안을 어떻게 채우던 나의 몫이니, 그것을 fs.writeFile 매서드를 사용하면 사용자의 응답을 받아 작성되는 파일을 만들 수 있다.
// ! 만들고 싶은 제목의 파일 만들기

const fs = require('node:fs');

const path = require('node:path');

rl.question('만들고싶은 파일의 이름을 말해주세요! : ',
function(answer){
  let data = answer;

  fs.writeFile(path.join(__dirname,`${data}.txt`),"kyao", (err)=>{
    if(err){
      console.error('생성실패!');
    }
  })

  rl.close();
})
readline활용2. 데이터를 조회해서 true,false를 판단한 후 값 반환.
// 강사님 최대한 기초를 활용함.
const rl = readline.createInterface({
  input : global.process.stdin,
  output : global.process.stdout
});

rl.question('포켓몬스터 이름을 작성해주세요 : ', function
(answer){
  for(let i = 0; i < pokemonData.length; i++){
    console.log(i+ "번째");
    if(answer === pokemonData[i]){
      console.log(`포켓몬스터 이름이 존재합니다!!!`);
      rl.close();
    } else {
      console.log('당신은 포켓몬도 모릅니까?');
      rl.close();
    }
  }
});
질문이 들어와서 사용자가 응답을 하면?
⇒ 반복문이 돌아가면서 찾을 것이다.
하지만 이렇게 하면 계속해서 콘솔을 찍기 때문에 어지러울 수 있다!
도착할 때까지 계속해서 찾기 때문.
rl.question('포켓몬스터 이름을 작성해주세요 : ', function
(answer){
  for(let i = 0; i < pokemonData.length; i++){
    console.log(i+ "번째");
    if(answer === pokemonData[i]){
      console.log(`포켓몬스터 이름이 존재합니다!!!`);
      rl.close();
      break;
    } else {
      console.log('당신은 포켓몬도 모릅니까?');
      rl.close();
    }
  }
});
브레이크를 걸어주면 도달했을 때 멈춰줄 수 있다.
조금 더 세련되게 바꾼다고 한다면?
rl.question('포켓몬스터 이름을 작성해주세요 : ', function
(answer){
  for(let i = 0; i < pokemonData.length; i++){
    if(answer === pokemonData[i]){
      console.log("No.",i+1,`${answer}`);
      rl.close();
      break;
    } else {
      console.log('당신은 포켓몬도 모릅니까?');
      rl.close();
    }
  }
});
대신 터미널이 나한테 시비를 거는 것을 막을 수는 없다. 막으려면 매서드를 사용해야 할 것 같다. 혹은 조회를 따로 한 후, 조회한 번호를 변수에 할당하고 그것을 출력하면 될 것이다.
⇒ Array.prototype.includes를 사용.
혹은  forEach를 사용한 방법.
const rl = readline.createInterface({
  input : global.process.stdin,
  output : global.process.stdout
});

rl.question('포켓몬스터 이름을 작성해주세요 : ', function
(answer){
  let data = [];
  pokemonData.forEach((Element) => {
    if(answer === Element){
      data.push(Element);
      rl.close();
    }
  });
  console.log(data);
  if(data.length === 0){
    console.log('그런건 포켓몬이 아니야아아아아!!');
  } else {
    console.log('당신은 포켓몬을 알고 있군요?');
  }
  rl.close();
});
위 함수를 해석하자면? 답을 받고, 그 답을 가지고 pokemonData라는 배열을 조회한다. 그리고 맞는 값이 있을 경우 그 값을 data라는 배열에 넣는다.
즉 ⇒ 있으면 넣어,
두 번째 if문에서는? 존재하는지 안 하는지를 판단하는 거라고 할 수 있다.
length가 0이라면 포켓몬이 존재하지 않았다는 의미일 것이다. 왜냐하면 배열에 있는 요소와 맞는 값이 없어서 추가를 하지 못했을 테니까
하지만, 0이 아니라면 추가가 되었다는 것이다. 고로 정답을 맞췄다는 것에 해당하는 답을 콘솔로 출력해준다.
const readline = require('node:readline');

const fs = require('fs');

const pokemonData = JSON.parse(fs.readFileSync('./pokemon.json','utf8'));
// ! JSON파일은 해석이 필요하다. 그래서 한번에 JSON.parse를 통해 변수에 할당

/*
* 검증을 거친다.  
* console.log(pokemonData);
? 제대로 할당은 되었는가?
* console.log(typeof(pokemonData));
? 타입은 뭐지? // object
* console.log(Array.isArray(pokemonData))
? 이거 배열임? // true;
*/



const rl = readline.createInterface({
  input : global.process.stdin,
  output : global.process.stdout
});

rl.question('포켓몬의 이름을 작성해주세요. : ',(answer)=>{
  if(pokemonData.includes(answer)){
    console.log(`당신은 ${answer}를 좋아하시는 군요! 저도 그렇습니다.`);
    rl.close();
  } else {
    console.log('그건 포켓몬이 아니야!!!');
    rl.close();
  }
})
이것은 나의 답. 배열이기 때문에 includes매서드를 사용하였다.
나만 쓸 것이기 때문에 따로 그래픽처리가 필요 없을 때 확인용으로 사용하면 매우 빠르게 확인할 수 있다.

URL: https://www.notion.so/24-05-22-ee753bccfbd34e01a713184baa7187e6
SetTimeOut에 대하여 공부하자!
1. AJAX(에이젝스, 에이작스)
2. setTimeout
3. console.time(”식별자”)
4.setInterval
5. 연습 포인트
※ 암묵지
SetTimeOut에 대하여 공부하자!
뼈대를 만드는 작업!
function을 만들고 일단 console.log를 쓴다
function a() {
  console.log();
}

function b() {
  console.log();
}

function c() {
  console.log();
}
변수들을 선언하고, 준비한다.
let fromData = {
  a : "1. 꽁꽁 얼어붙은",
  b : "2. 대전천 위로",
  c : "3. 고양이가 부수고다닙니다."
}

function a() {
  console.log(fromData.a);
}

function b() {
  console.log(fromData.b);
}

function c() {
  console.log(fromData.c);
}
이는 메모리에 리딩되어 있지만 아직 쓰지는 않은 상태이다.
함수 자체는 선언되어 있지만, 호출하지 않으면 실행되지 않는다.
호출을 해서 실행하면 차례대로 실행된다.
인터프리터방식이라고 하여
→ 위에서 아래로,
→ 왼쪽에서 오른쪽으로
→ 하나읽고, 바로 실행하는
서양식 작문법의 형식을 가지고 있다.
보통의 경우 변환작업을 거치지만 JavaScript는 이 변환작업이 없다. 
런타임 → 실행하는 환경.
client end user
→ 순서를 기다리는 것 보다
→ ‘바로 나 먼저 해주길 원함’
→ 순서를 어기는 것이 더 나음.
브라우저에서 되는 것부터 보내주는 것과 같다.
브라우저는 요청을 할 때 순서대로 처리하지만, 먼저 html을 보내주고 그다음에 css 그다음에 js 그다음에 요청이 오는 순서대로 처리한다.
1. AJAX(에이젝스, 에이작스)
Asynchronous Javascript And XML 
→ 알맹이만 쏙 새치기하는 기술
2. setTimeout
 ‘스탑워치 함수가 존재한다.’
→ 지정된 시간에 실행되는 함수. (순서가 어찌되었든간에 새치기)
→ 게임 매칭시스템. 매칭되면 바로 동의창이 나타남.
매개변수를 외워야 한다!
setTimeout(callback, delaytime);
스탑워치 함수 ( 하고싶은 것, 기다려야되는 시간 );

예를들어서
setTimeout(function(){
  console.log('고양이가 다 때려부순다');
},1);
뭔지 모르겠지만 1이란 delaytime이후 콘솔이 실행된다.
바로 찍힌다.
여기서 1은 1초가아니라 1000분의 1초이다.
delaytime은 밀리세컨드를 기준으로 삼기 때문에, 1이라하면 0.001초를 지정한 것이다.
인터프리터의 특징을 생각하면 가장먼저 실행되어야 함에 틀림 없음에도, 나중에 실행됨을 확인할 수 있다. 이것은 setTimeout이 비동기 함수이기 때문이다.
자바스크립트의 비동기함수는 setTimeout 단 하나다.
유능해지기 위해서 만든 것이고, 이것을 사용하기 시작하면 순서를 어기는 독자적인 라인을 탄다.
독자적인 라인을 탄다는 것은?
절차적으로 실행되는 함수와는 다른 라인을 탄다. 적용되는 것이 다르다는 것이다.
자신들만의 라인이 있어서 이 함수는 거기에 쌓이게 된다.
그래서 만약에 동일한 함수를 3개를 넣어본다고 하자.
setTimeout(function(){
  console.log('고양이가 다 때려부순다');
},1000);
setTimeout(function(){
  console.log('고양이가 다 먹어치운다');
},1000);
setTimeout(function(){
  console.log('고양이가 아니 왜 호랑이에요?');
},1000);
이러면 3개가 동시에 나오기 때문에 어떤 순서로 나올지는 랜덤일 것이다.
그러면 결과를 보아보자.
몇번을 반복해도 같은 결과가 나온다.
그렇다. 동기처리 함수에서는 순서를 지키지 않지만 새로 쌓인 비동기함수의 공간에서는 절차적으로 쌓이는 것이다. 
비동기 끼리 모이는 것은 절차적으로 실행이 된다는 것을 알고 있어야 한다.
이것으로 우리는 핸들링을 세련되게 할 수 있다.
setTimeout(function(){
  console.log('1. 슈퍼파월');

  setTimeout(function(){
    console.log('2. 슈퍼히어로랜딩');
  },1000);
  // 1번이 실행되고 다음에 2번이 실행된다 
  // 결국 최종적으로 3초후에 실행이 된다.
  // 절차적으로 실행이 됨을 확인할 수 있다.
  // 동기적으로 작동했다.

},2000);
위 함수는 비동기함수인 setTimeout을 동기화한 것이다.
순서를 어기는 놈을 순서를 지키게 할 수 있는 유일한 방법이 callback이다. 그때가서 부르는 형태.
그렇기 때문에 이것을 호러게임을 생각하면 좋겠다.
맵을 이동하고 몇 초후에는 무조건 소리와 함께 병이 깨지는 이펙트가 나온다거나? 하는 식으로 활용하는게 이 setTimeout을 이용하면 가능할 것 같다.
함수가 함수에게 일을 시키는 것이다. 
“비동기 함수를 동기처리한다.”라고 할 수 있다. → callback처리 했다는 뜻
setTimeout(function(){
  console.log('1. 슈퍼파월');

  setTimeout(function(){
    console.log('2. 슈퍼히어로랜딩');
  },1000);
  // 1번이 실행되고 다음에 2번이 실행된다 
  // 결국 최종적으로 3초후에 실행이 된다.
  // 절차적으로 실행이 됨을 확인할 수 있다.
  // 동기적으로 작동했다.

},1000);


setTimeout(function(){
  console.log(1);
  a();
}, 500);

function a(){
  setTimeout(function(){
    console.log('2.슈퍼파월');
  },500);
}
이것은 형상화를 할 필요가 있을 것 같은데?
이 경우, 
고로 내 생각대로 실행이 되지 않을 때, 바로 떠올려야 할 생각은? 
→ 어 이 함수? 비동기인가? 비동기 함수를 사용하는 것인가?를 감지해야 한다.
→ 감지하고 나면 그것은 따로 관리해야 한다.
점원을 생각하면 편하다.
→ 대형마트의 캐셔들은? 손님이 많건 적건 오는 순서대로 그 사람의 물건을 절차적으로 처리한다.
→ 다르게 말하면 동기적으로 처리한다.
→ 그렇기 때문에 손님이 일을 한다.
→ 줄이 적은 줄을 찾아가지고 가는 것이다. 그리고 내가 살 것이 2개밖에없어도 내 앞에 손님이 수십개를 사면 난 그만큼 기다려야한다.
즉, 융통성이없다.
→ 무언가 처리량을 늘리려면 라인을 늘려야한다.
여기서 이 라인을 컴퓨터용어로 하자면 멀티쓰레드라고한다.
→ 캐셔는 서버리소스라고 할 수 있다.
→ 캐셔가 처리능력이 좋을 수록 줄이 줄어드는 속도가 빨라질 것이다.
→ 하지만 결국 한줄에 하나씩이니 융통성이 떨어진다.
그렇기에 마트는 셀프계산대를 도입했다.
소량의 물건을 가진자는 셀프계산대를 가서 결제를 하는데, 혹 점원의 결제를 필요로 하는 품목은 상주하고있는 직원이 카드를 들고 승인을 해준다.
JavaScript는 싱글 쓰레드언어이다.
→ 융통성있게 별에별일을 다한다.
→ 그럼으로써 얻을 수 있는 것은 자원을 아낄 수 있다.
→ 인건비(리소스, 자원)를 줄이기 위해서 → 융통성을 발휘함.
절차적인 진행‘외’의 것들을 해결하기 위한 아이디어 → 절차보다는 실행우선.
비동기-동기의 절차를 내 마음대로 ‘핸들링’한다!
⇒ 자바스크립트, node.js의 장점이다
똑똑한 판단과 실행이 가능하다!
하지만, 어지간히 복잡하다…
3. console.time(”식별자”)
console.time('작업');
setTimeout(()=>{
  console.log('1. 돈까스가 돌같았음.');
},1000);
setTimeout(()=>{
  console.log('2. 커피는 맛있음.');
},1000);
setTimeout(()=>{
  console.log('3. 메가커피 스모어블랙쿠키프라페먹어보고싶다.');
},1000);
console.timeEnd('작업');

// console.time('식별자');
// console.timeLog('식별자');
// console.timeEnd('식별자');
// 위와 아래가 동일해야한다, 매개변수가 식별자이다.
// 타임로그는 중간에 시간을 찍을 수 있다.
실행시간을 확인할 수 있다.
timeLog를 사용한 코드 
console.time("first");
setTimeout(function(){
  console.timeLog('first');
  console.log('1. 슈퍼파월');

  console.time('first-1');
  setTimeout(function(){
    console.timeLog('first-1');
    console.log('2. 슈퍼히어로랜딩');
    console.timeEnd('first-1');
  },500);

  console.timeEnd('first');
},490);

function a(){
  setTimeout(function(){
    console.log('2.슈퍼파월');
  },2000);
}

console.time('second');
setTimeout(function(){
  console.timeLog('second');
  console.log(1);
  a();
  console.timeEnd('second');
}, 1000);
변수를 함수로 할당해서 사용한다면? 무한히 사용할 수 있는 setTimeout
let counter = 0;


const timer = function(){
  setTimeout(()=>{
    counter++;
    console.log(counter);
    timer();
  },1000);
}

timer();
하지만 이것은 ‘무한히’반복된다. 조건문을 달아서 멈출지점을 지정해주자.
const timer = function(){
  setTimeout(()=>{
    console.log(counter+'vw');
    counter++;
    if(counter < 10){
      timer();
    } else {
      console.log(`${counter}초 세기가 종료되었습니다!`);
    }
  },1);
}
이것을 활용하면 어떤일이 일어날까?
이것을 만약에 한 태그의 .style.width값에 넣는다면? 점점 커지는 요소를 만들어낼 수 있을 것이다.
이것으로 무엇을 만들 수 있을까? 포켓몬스터의 인카운트를 이런식으로 처리할 수 있지않을까? 
아니면 호러게임에서 이미지가 다가오게 하는 것을 시도할 때, 웹툰에 옥수역귀신이었나? 그런 것을 다 이것으로 가능하지 않을까? → 가능하다!
이를 ‘재귀’함수라고 한다.
예제 : factorial
const factorial = (n)=>{
 if(n === 0){
  return 1;
 } else {
  return n * factorial(n-1);
 }
};

console.log(factorial(10);
다음 코드를 실행하면?
10*9*8*7*6*5*4*3*2*1이 반환된다.
4.setInterval
유일한 비동기함수 setTimeout
→ 내가 나를 부르는 재귀함수로 변형되면?
⇒ setInterval이 된다.
재귀함수(recursion function)가 된다.
synctax
setInterval('반복 실행하고 싶은 것', '실행 간격');

let intervalHandler = 0; // ? 상태변수. 어떤 상태일 때 이렇게 하겠다.

let timer = setInterval(()=>{}, 1000);
5. 연습 포인트
html파일을 하나 만들어서 그냥 네모하나 만들고 그 옆에 submit이건 뭐건 이벤트를 달 수 있는 버튼을 하나 만들자. 
그리고 클릭을하면 네모가 밖으로 사라지게 하자!
사용될 css
→ position : absolute;
→ left , bottom, top, right 등으로 강제 이동을 시켜보자.
※ 암묵지
synchronous
→ ‘동기’적 작업.
→ ‘순차적인’, ’절차적인’
→ 지금까지 내가 적은 모든 코드는 ‘동기방식’을 채택하였다. 어째서?
→ 코드를 리딩하는 방법을 익혀야 했기 때문이다.
예를 들어서 줄이 긴 카페에 갔다고 생각을 하자. 줄이 길고, 카페 음료 별로 제작시간이 다르지만 먼저 온 손님부터 처리하는 것과 같다. 나중에 온 사람이 아메리카노라는 간단한 것이라고 해도, 순서대로 주문이 들어온 순서대로 처리해주는 것이다.
Asynchronous
→ 비동기 작업
→ ‘절차를 어기는’
→ ‘예상을 빗나가게 한다’
→ ‘종료가 먼저 되는 녀석부터’실행
예를 들어서 중국집을 갔다. 점심시간에 중국집을 가면 짜장면을 미리 조리해 둘 것이다. 
그리고 손님이 둘 들어왔는데 먼저 온 손님은 짜장면과 탕수육을 시키고, 다음에 온 손님은 짜장면만 시켰다.
그러면 먼저 온 손님보다, 나중에 온 손님을 먼저 갖다주는 것과 같은 이치.
Python
→ 태생이 교육용 언어이다!
→ 때문에 파이썬은 동기로만 작성할 수 있었다.
→ 하지만 이제는 몸집이 커졌기 때문에 비동기도 들어와있긴 한다.
컴파일언어
콜백function에 익숙해지기위해 일부러 지옥에 들어가보자. callbackHell!을 검색해보자.
XMLHTTPRequest()라는 것을 알아보자.
fetch
AXOIS도 찾아보자.
callbackhell이란 것을 경험해보자. 결국 callback→promise→XML→axios→fetch다.
promise → async/await까지 나아가보자.
⇒ 데이터가 모두 비동기로 들어온다는 것이다.

URL: https://www.notion.so/24-05-21-4ffd7073faac4aeaa8c50798721bedb5
0. 수업시작 전
0-1. 학습 포인트 JSON
JSON확장자 extention을 공부하도록 하자! 
안으로 파고들자면 쓰기, serving하기, 서빙 받은 것을 저장해서 활용하기, reading하기 등
글쓰기 게시판
→ post로 쏘아진 정보를 받아와서 가공한 다음 html템플릿 혹은 태그 템플릿을 만들어서 appenChild로 보내는 형태로 하고 싶은데. 서버에서 쏘아진 파일을 문서에 연결된 js파일로 연결해야 한다.
→ 수현씨의 코드를 한번 확인해보도록 하자.
POST와 짝꿍이 맞는다.
POST로 받은 data를 JSON의 형태로 정제하여 내보내는 경우가 많은데, 이유는 별거아니고 JSON이 다른 언어에도 통용되기 때문이다. JSON이란 Data화폐느낌이라고 해야 할 것이다.
0-2. 학습 포인트 GET과 POST의 차이점을 깨달아라!
내가 아는 GET과 POST를 나열해보자.
GET 
→ url에 정보가 저장됨
→ url에 저장되기 때문에 보안에 취약함
→ 많은 양의 정보를 보낼 수 없음.
→ 대게 브라우저가 요청하는 방식은 대부분 GET임.
1. JSON 이해하기
1-1. DOM API와 Node.js
DOM API ⇒ 매우 큰편이다. 근데
Node.js ⇒ 활용할 수 있는 메서드가 너-무 많음
Node.js writeFile method 스크린샷
Tip! ctrl을 누르고 해당 함수를 마우스오버하면 그 함수에대한 정보가 나온다!
모든걸 다 알필요는 없다! → “빠르게 method를 파악하는 능력을 기르자!”
txt파일 ⇒ 기본 텍스트 파일(메모장) 파일 이름, 파일 내용을 만들 수 있다.
→ 한계가 존재한다. ⇒ 한 가지만 가능하다.
아니 좀 다양하게 쓰고싶은데?
key와 value를 사용하는 JSON을 사용하자!
JSON ⇒ JavaScript Object Notation 자바스크립트의 객체 표기법을 따르겠다!
JSON메서드는 딱 두가지
그냥 객체를 → JSON으로 바꿔주는 → JSON.stringify()
JSON을 객체로 만들어주는 → JSON.parse
수많은 다양한 언어들이 json처리하는 것들이 지원된다. 왜냐? 편하니까
→ 정규적인 데이터 전송방식으로 활용됨. ( 저장 )
→ JavaScript의 객체표기법을 따라하기 때문에 JavaScript는 json수저를 물었다고 할 수 있다.
→ json처리를 많이 해보면 모든 언어에서 활용할 수 있다.
객체를 객체로만 쓰는 것이 아니라
JSON 호환성이 높은 데이터포멧
Key, Value에 대한 응용 가능성을 느껴보는 것
⇒’객체 편집’, ‘객체 핸들링’하는 작업.
1-2. 오늘의 연습.
많은 것들을 저장해보자. 규칙을 만들어놓자.
html문서를 객체화 시켜보자.
post를 받을 때 JSON으로 받으면 편함! txt로 받으면 귀찮…
JSON으로 저장하고. JSON처리된 것을 꺼내서 써먹어보기.
이것이 모두 되었다면? ⇒ JSON.stringify 와JSON.parse가 익숙하다!
⇒ POST로 받아보세요! POST로 받아온 JSON파일을 다시 가공해서 파일을 만들어보고 그것을 또 받아와바라!
→ 게시판 만들기 느낌인가?
필요한 것 2가지 index.html 과 파일을 보낼 html파일(편의상 send.html)이라고하자.
send.html에서 form태그로 POST를 통해서 보내면? ⇒ 그것을 읽어서 index.html에 추가 게시판의 형태로 만들어진것을 클릭하면? JSON으로 나온것을 html로 표기.
나열합시다! 내가 생각하는 것 !
성공
내 마음대로 JSON 만들기(write)
성공
내 마음대로 JSON을 활용하기
성공
POST method를 활용해서 입력받기
성공
받은 데이터 저장 및 표현(활용)
성공
연결되어 있는 것들
⇒ DB, 자료구조, 네트워크 표준, 서빙, 자바스크립트,  네트워크 - 호완성
※ 키워드
심상화(Symbolic) Mental Image멘탈이미지 있어보이는 말이다.
→ 심상화 작업은 A가 A다! 라고 정리할 수 있는 형태이다. 예를들자면?
→ 몬스터를 보면 각성제다! 라는 것이 떠올리는 것처럼.
data.go.kr → 시간 날 때 가입합시다.

URL: https://www.notion.so/24-05-20-c7a5916de62d451ab8235c52c1424eb4
0. 수업 시작 전
0-1. 금주의 학습목표.
0-2. for…in과 for… of
0-3. 서버개념 network에서 POST를 익혀봅시다.
0-4. 이 모든것을 완료한다면?
0-5. 마음가짐.
※ 그래서 이거 어떻게 익힘?
1. for…in
1-1. 모듈화!
2. 설계를 할땐 그림을 그리자
2-1. 설계란? 생각을 떠올리는 것 숨 쉬듯이 적어라!
2-2. 양이 중요하다. 가치 판단은 하지 않는다!
2-3. 결론은 단정 짓지 말라! 결론은 정하지 않는다.
2-4. 무(無)조건으로 만들어보자.
주제 : 여행! 조건 없이 모두 적어보자.
※ 검색 키워드
0. 수업 시작 전
0-1. 금주의 학습목표.
일반에 대해 공부하게 될 것이다. 공통적으로 모두 물어보았던 것이 있었다.
 “설계” 늘 고민해야 하는 것이다. 
개발자의 특성은 다른 여타 설계가 필요한 직업들에비해 현장비용이 없다는 것이다.
우리는 컴퓨터 하나만 있으면 되니까!
설계를 함에 고민해야 될 부분은 무엇이냐?
의외의 것을 찾는 일! ← 하나라도 찾아내면 이득.
→ 따박따박 찾는 것은 정해져있을 때 가능한 것. 우리는 그렇지 않다. 변화가 심하다. 언제 갑자기 코드를 갈아 엎을지 모른다. 왜?
→ 비용이 안드니까. 드는 것은 나의 노동력 뿐이다.
→ 하지만, 의외의 것을 찾는 것은 다르다. 
설계를 하면서 같이 가져갔으면 하는 것 
→ 스케줄링이 나를 핸들링하는 형태이다.
→ 설계법을 익히도록 하자.
이번 주의 포인트 설계법을 익히는 과정.
→ 설계법을 익히면 뭐가 좋은다? 미리 난감함을 캐치할 수 있다.
→ 물론 예상뿐이므로 상당히 난항을 겪을 것이다. 하지만 복잡함을 줄일 수 있다.
→ 그러면 일을 줄일 수 있고, 나의 시간을 확보할 수 있다는 결론을 얻을 수 있다.
“설계포인트를 직접 찾아서 내 설계가 얼마나 유효한지 연습하도록 하자!”
설계가 어렵더라도 혹은 익숙하지 않더라도 계속 시도해보는 형태로 나아가자.
0-2. for…in과 for… of
객체를 다루는 것을 익숙해지도록 하자! 이 두 문법은 객체를 핸들링하는 문법이다.
반복문을 좀 더 심화적으로 연습하면서 객체를 핸들링해보도록 하다.
참고로 python은 for…in 단 하나만 가지고 있다.
0-3.  서버개념 network에서 POST를 익혀봅시다.
reading의 개념을 이해해야 한다. post작업까지가 이번주의 마지막 목표
0-4. 이 모든것을 완료한다면?
클래식한 웹서빙의 쌍두마차를 획득할 수 있다. WEB 2.0을 이해할 수 있다고 볼 수 있다.
0-5. 마음가짐.
내뱉는 말에는 힘이 담겨있다. 너무 강한 워딩을 사용하지말자 실제로 영향이 어느정도 있다.
멘탈붕괴라는 말을 많이 쓰는데, 이 말은 정말로 궁지에 몰렸을 때에나 사용하는 것이다. 그리고 스스로도 정말 돌파구가 없다고 판단하게 된다.
말을 바꾸도록하자. 실제로 멘붕이 올만한 일은 아직 하지 않았다!
멘탈붕괴 → 한 번에 해결되지 않았다. 혹은 막연하다 막연한 느낌이 들었다. 혹은 내가 알고있는, 알고있던 것과는 다르다. 같은 어휘로 치환해서 사용하도록 하자.
정말로 어려운 것은 오히려 선거철에서 누구를 뽑을지 고르는게 더 어렵다.
※ 그래서 이거 어떻게 익힘?
계속 해보세요. 필요없어도 for in을 써보면 어떻게 될까? 필요가 없어도 POST방식으로 받으면 어떻게 될까? 무던히 의연하게 계속해서 반복하면 된다.
설계는 내가 하는 모든걸 계속 설계하면 된다. 이거하면 무슨일이 벌어질까? 이걸하면 어떻게 될까 등등
1. for…in
들어가기 앞서
매개변수도 변수이다. parameter → veriable이다 즉 매개변수는 데이터타입과 같은 가짓수를 가지고 있다.
“함수에서 쓰는 변수” ← 매개변수arugment
알고는 있지만 잘 몰라서 활용하지 못하는 케이스다. Object를 많이 사용한다고 한다. 
매개변수에 객체를 할당해 보는 연습을 해볼까?
서버가 네트워크 기반이기 때문에
→ 네트워크 상태불량이라는게 존재한다.
→ 이때 사용하는 것이 바로 예외처리. 예외구문이다. (exception처리)
→ “이것을 사용하면 내가 원하는 것 외에는 다 에러” 
// ! try catch의 경우 try만 보면된다!!
// ! catch는 error를 잡는 용도로 사용!
// ? 예외처리라고한다! catch로 예외처리!
function forObject(a,b) {
  try {
    if(typeof(a) === 'object') {
      if(typeof(b) === 'object') {
        console.log("감지했다!!");
        console.log("a, b 매개변수 모두 객체입니다.");
      }
    }
  } catch(error){
    console.error(error);
    console.error("하하하! 사람이 마치 개미같구나!");
    console.error("人がゴミに見える");
  }
};
try와 catch를 사용해서 연습해보도록 하자!
new키워드 ← 반드시 객체!
 객체는 length 라는 값이 존재하지 않기 때문에 객체의 key 이름을 조회하려면,
Object.keys() ← 와 같은 매서드로 배열처럼 사용은 가능하지만, 복잡해진다.
→ 나쁜것은 아님! 실제로 많이 사용함.
하지만 배열만 쓰는 것은 아니기 때문에, 객체도 반복문이 있으면 좋겠다라는 needs가 발생했다.
“객체를 따로 배열처리를 하지 않고 반복할 수 있으면 좋겠다!”
→ for…in문 매서드 생성됨. for문과는 완전히 다른 것
→ for(let 변수이름 in 객체명){}형태의 작성법.
변수이름에 해당하는 부분이 ‘반복용’으로 쓴다라고하여 → 반복자(iterator)라고 칭한다. 그리고 for…in문이 사용되었다면 자동적으로 → 객체구나 라고 떠올리면 된다.
function forObject(a,b) {
  try {
    if(typeof(a) === 'object') {
      if(typeof(b) === 'object') {
        let values = [];
        for(let key in a) {
          console.log(key);
          // ? a,와 b가 객체이기때문에 반복문을 돌릴 수 없다.
          // ! 매개변수를 반복형태로 쓴다하여 '반복자'라고 한다.
          values[0] = a[key];
          // ! 배열로 초기화한 values의 인덱스번호 0번째에 a[key]의 값을 할당.
          console.log(values);
        }
        for(let key in b){
          values[1] = b[key];
        }
        console.log(values);

        let addValues = values[0] + values[1];

        console.log("다 더한 값 : ", addValues);




        // ? let result = a.first + b.first;
        // ! 치명적인 단점! first가 리터럴이기 때문에 한번만 사용할 수 있는 코드
        // ! a, b에 first라는 키가 있어야한다는 치명적인 단점이 있다.
        // ! first가 없으면 사용할 수 없는 함수
      }
    }
  } catch(error){
    console.error(error);
    console.error("하하하! 사람이 마치 개미같구나!");
    console.error("人がゴミに見える");
  }
};
sudo코드로 이야기 해보자 시나리오
입력으로 뭐가 자꾸 들어옴
들어오는 것들이 자꾸 객체네?
객체를 반복처리, 실행하고 싶을 때가 너~무 많음
이때 비장의 카드 for in 문
지역변수 배열 초기화
→ “내가 편하자고 사용하는 패턴”
→ 전문용어 반복자(iterator)
const a = {
  first : 1
};

const b = {
  first : 2
};

function objectLoop(array,object) {
  for(let key in object){
    array.push(object[key]);
  };
};


function forObject(a,b) {
  try {
    if(typeof(a) === 'object') {
      if(typeof(b) === 'object') {
        let values = [];

        objectLoop(values, a);
        objectLoop(values, b);

        console.log(values);

        let addValues = values.reduce((a,b)=>{
          return a + b;
        });

        console.log("다 더한 값 : ", addValues);
      }
    }
  } catch(error){
    console.error(error);
    console.error("하하하! 사람이 마치 개미같구나!");
    console.error("人がゴミに見える");
  }
};

// * 둘 모두 변수를 초기화 한 것이다. 


forObject(a,b);
 매개변수를 보다보니까 줄일 수 있을 것같다. → 줄여라
위 코드는 추상화 수준이 높아졌다고 하는데, objectLoop라는 함수를 알아야 해석을 할 수 있다.
ctrl + 마우스 오버를 하면 함수의 정보를 확인할 수 있다.
→ 쓰다보니까 반복이되네? 함수로 만들까? 같은 자세
1-1. 모듈화!
function을 너무 많이 남발하면 코드가 너무 길어진다. 이것을 줄이고 싶다면? CJS방식으로 모듈로 만들어서 함수를 내보내자.
function objectLoop(array,object) {
  for(let key in object){
    array.push(object[key]);
  };
};

module.exports = objectLoop;
모듈로 만들 함수를 새로운 js파일에 작성하고 코드를 한 줄 추가한다.
이제 모듈이 하나 만들어졌다 이것을 사용하려면? CJS에서는 require를 사용한다.
const objectLoop = require('./module.objectLoop.js');
모듈이란 말을 약간 바꿔서 이야기해보자면 framWork이라고 할 수 있겠다.
아직은 막막한 일이지만 매일 매순간 하게 될 일이기 때문에 결국은 익숙해져야 할 것이다.
2. 설계를 할땐 그림을 그리자
MVC pattern
혹은 시퀀스 다이어그램, 개발자 다이어그램 등등 그림을 그려서 설계를 하자.
설계를 할 때는 어떤 모듈이 필요할까? 헤아려보는 작업이 설계의 연습포인트이다.
내가 지금 만드는 것에 필요한 것이 무엇이 있을까? 
2-1. 설계란? 생각을 떠올리는 것 숨 쉬듯이 적어라!
설계는 품질을 필요로 한다. → 다양한 품질을 필요로 한다.
설계를 할 때는 생각을 계속해서 떠올려야 한다. → 이때 가치판단 ‘X’ 후에 걷어내기 작업을 한다고 해도 후보를 펼칠 때는 가치 판단이 관여하지 않는다.
2-2. 양이 중요하다. 가치 판단은 하지 않는다!
떠올리는 모든 것을 다 떠올려라! 어떻게? 엉뚱하게! 그냥 일단 다 해! 다 적어! 연관성이 없어도 되! 아니 사실은 연관성이 없을 수 없다! 왜? 내가 떠올렸으니까 내가 어떠한 연유로 갑자기 연결이 되었으니까 그 것을 적어야 한다. 그런것들을 모두 적는다.
양은 매우 많이. 적지 않게. 넘칠 정도로
2-3. 결론은 단정 짓지 말라! 결론은 정하지 않는다.
실현이 어려울 뿐 가능은 하다. 결론을 단정지으면 거기서 끝나버린다. 결론을 짓지 않는다면, 내가 만들다가 자연스럽게 결론이 나타나게 된다.
2-4. 무(無)조건으로 만들어보자.
설계는 즐겁게! 무(無)조건으로 계속해서 해보자! 상당히 어려울 것이다. 하지만 그 과정이 즐거워야 내가 끝까지 다를 수 있을 것이다! 늘 하던 거에서 추가로 더 하면 되는 것이야. 할 수 있지
drop도하고 select도하고 그런것들이 수업이 반복되서 하나의 결과물을 만들어 낸다.
→ 내가 편견덩어리임을 발견해내자! 편견덩어리를 만들어내면 바로 망치로 깨면서 계속해서 나아가는 거야! 할 수 없는 것은 없다!
순간적으로 떠오르는 상상들 별로 의미없이 전부 다 체크하는 것. 체크? 숨쉬듯이 적는 것.
모두 하면? 내가 스스로 순서를 짜고 있을 것이다.
주제 : 여행! 조건 없이 모두 적어보자.
친구, 밥, 음식, 돈까스, 차, 돈, 식비, 여행비, 학원, 머리아픔, 스트레스, 아버지, 가족, 도보, 도깨비도로, 한라감귤 초콜릿, 돌하르방, 현무암, 수영, 돔베기, 갸가갸가가, 감귤, 도깨비, 선산, 연기, 신선, 낙뢰, 용오름, 거인, 폭발, 배낭, 칫솔, 수영, 갈치, 호텔, 모텔, 해병대, 비행기, 쾌속선, 수학여행, 열기구, 바다, 파도, 모래, 할머니, 바위, 성산일출봉, 목검, 코코넛음료, 동굴, 해녀, 소라, 라면, 부르스타, 자살, 물귀신, 신토불이, 용암, 5월의 눈, 육개장, 반팔등산, 절벽, 넥슨, 네오플. 태풍, 서버, 불안정, 결항, 신혼여행, 스쿠버, 구명조끼, 팬션, 고기, 거 머더라 드라마, 우리들의 블루스? , 순대, 아바이순대, 각설이, 사투리, 서커스, 중국인, 오렌지색, 한라봉, 당근색, 스텐리퀜쳐H2.0, 불쇼, 사자, 돌담, 김치볶음밥, 치즈폭포, 연돈, 서귀포시, 백종원, 분묘뷰, 
※ 검색 키워드
visual thinking
→ 눈의 능력을 활용. 
소켓? 겟? 포스트? 
markDown 문법을 읽어보자.

URL: https://www.notion.so/5-5b11d6251c9a46d9a5f7ac67ebca40ec
24/05/20
24/05/21
24/05/22
24/05/23
24/05/24

URL: https://www.notion.so/24-05-17-4db10ef3d3954869915bb89143f68cd4
0. 수업 시작 전
경계해야할 것! 혹은 주의해야할 것!
media, 술, 수면 매우 중요!
media = 너무 자극적인 것은 피하도록 합시다! → 우리는 코딩이 제일 재밌어야해요!
→ 나같은 경우는 유튜브와 게임에 해당할 것이다. 혹은 음악까지도?
술 = 당신의 학습이 모두 날라가는 마법의 약입니다. → 애초에 안마시니까 문제 없음!
수면 = 당신의 집중력을 올려주는 것입니다. 수면은 나의 학습 태도에 매우 큰 영향!
→ 수면을 늘려야 할 것이다. 근데 시간이 너무 없어! 뭘 줄여야 할까? 휴식을 줄이는 수 밖에는 없구나!

URL: https://www.notion.so/24-05-16-7fc511f0ccf54e38bd2146ef165ae294
0. 수업을 시작하기 전.
0-1. 절차적 사고.
14일 테스트를 떠올려봅시다. 우리는 앱 서버를 만들었습니다. npc에 해당합니다. 
이 서버에는 한가지 기능을 합니다. createServer라는 한가지 기능만 하고, 요청이오면 응답을 처리합니다.
→ 이것은 host의 입장에서의 이야기이다.
그렇다면 client의 입장에서는 어떨까?
클라이언트는 브라우저를 통해서 host와 접선한다.
예를들어서 주소창에다가 적는다. 로컬호스트를 이용하니까 이야기하자면 포트넘버를 써서 들어온다.
접속창에 글씨를 입력했다 = 요청했다. 
클라이언트는 요청을 하고 호스트는 응답을 해준다.
중요한것은 요청을 감지할 수 있는가?이다. 요청을 감지해서 그것에 응답을 해줄 수 있는가
0-2. 가져가야할 것
나는 클라이언트 혹은 프로토콜 혹은 브라우저의 요청을 감지해서, 그에 알맞은 응답을 할 수 있는가?
전 테스트에서 내가 한 것은 정적인 페이지를 응답해주는 웹 앱 서버를 만들어 준 것이다.
정적인 웹 사이트, 웹 서비스를 만들었다.
→ 세련되게 만드려면 동적으로 페이지를 만들어야 겠지?
→ 강사님이 명명하기를 WEB ver 1.0에 해당한다.
짜장과 간짜장을 생각하자. 정적인 페이지는 짜장이다. 미리 만들어놓고 면만 익혀가지고 짜장만 올려주면 된다. 하지만 간짜장은? 주문과 동시에 춘장을 볶아서 만들어준다. 즉 커스텀이 가능해진다.
정적인 것은 이것만으로 처리를 할 수 있도록 구분하면 좋을 것 같다. 예를들어 회원가입같은 경우는 누가 올지 모르기 때문에 미리 제작해 둘 수가 없다. 클라이언트가 적는 정보를 받아서 새로운 페이지를 만들어내서 브라우저에 보내야 한다. 하지만 사이트 이동의 기능만 할 수 있는 메뉴바같은 것은? 굳이 동적으로 만들어질 이유가 없다. 정적으로 미리 페이지를 구성해두면 된다.
0-3. 오늘의 미션
파일을 넘겨주는 것은 이제 얼추하겠다. 그렇다면 사용자가 입력하는 데이터를 받는 것은 어떻게 할 수 있을까?
→ 고민해 보도록 하자.
→ todo-list를 사용하는 건 어떨까? 가능할 것 같은데? input태그를 활용하면 가능할 것 같다.
→ form태그도 사용해보도록 하자.
두번째로 넘어야할 목표 ‘로그인 처리’를 시도해 보자!
→ 일단 inputTag두개에 summit을 하면 그 두가지 정보를 받아내는 형태를 만들어보자.
→ id와 password가 될 것이다. 
→ html의 입력방식에 대한 마크업을 알아야 할 것.
→ 어떻게 받아낼지를 생각해야 할 것.
→ GET과 POST를 이해해보도록 하자.
로그인을 통해서 입력받는 것을 연습하겠다.
1. GET요청을 통해서 로그인 입력받기.
1-1. 쿼리스트링
GET요청이란? 
→ 주소 뒤에 무언가를 주렁주렁 달아서 요청하는 방식.
→ 주소창에 뒤에 뭐가 계속 붙는 것은 전부 GET요청 처리를 하고 있는 것이다.
→ 이 주소 뒤에 무언가가 주렁주렁 다는 것을 칭하는 용어가 queryString★이라고 한다.
→ 보안에 치명적인 단점이 있다. 주소창에 넘기기 때문에 모든 정보가 다 노출되버린다.
장점은 주소 뒤에 간단한 요청내용을 넣을 수 있다.
단점으로는 주소 뒤에 간단한 요청내용을 적기 때문에 데이터 제한이 있다.
→ 하지만 페이지 보여줘 또는 약간의 데이터를 받아내는 것 정도는 충분히 가능하다.
GET요청을 어디에 써요?
→ 정해지지 않았습니다. 간단한곳에 많이 씁니다.
이것을 마스터 하기 위해서는?
queryString을 검색해서 그 특징을 공부해보자. 이것을 공부한다면 나는 GET요청을 인지하게 된 것이다.
→ 키와 값을 식별하기 때문에 객체를 받는 방식 중 하나라고 추측할 수 있다!
http://localhost:포트번호?key=value&key=value&key=value&…
?를 분기점으로 키와 벨류로 나뉜다.
주소 문자열을 받으면?
성공 req.url.startsWith(”/test”) true false를 판단하는 method인 것 같다.
문자열이 특정 문자 즉 arugment로 시작할 때 true, false값을 반환한다.
/test로 시작하면 실행문을 시행해라! 라고 한 것. 
왜냐하면 GET요청으로 queryString을 받아오면 뒤에 붙는게 많아지기 때문에 앞 문자를 지정해 준 것.
?뒤에 있는 것을 자른다.
성공 split을 활용 ? 를 지정
“=”이퀄 표시 앞에 있는 데이터는 key, 뒤에 있는 데이터는 value
성공
&(엠퍼센드)가 구분하는 애(구분자)
성공 split을 활용 &를 지정
만들 파일 이름을 입력하세요 전송을 누르면 파일이 어디선가 만들어지게 할 수 있을까요?
    if(req.url.startsWith("/test")) {
      console.log(req.url.split("?"));
      const inputData = req.url.split("?")[1];
      // ! url에 queryString이라는 이름의 규칙이 보여서 적당히 잘라서
      // ! 사용하려고 해
      const data = queryString.decode(inputData);
      // ! 받아온 데이터 해석해줄래?
      console.log(data);
      // ! 해석한 것을 콘솔에 찍어줘
    }
가장 먼저 클라이언트에게 정보를 받아올 수 있어야 한다.
나는 인풋 태그를 활용했다.
※ 암묵지
ip 브라우저 주소창.
시퀀스 다이어그램
관용적으로 8080이란 포트번호는 메인 index를 많이 사용한다. DB의 경우 3306
url.parse의 사용법
req.on의 사용법
qs.parse의 사용법

URL: https://www.notion.so/24-05-14-4a655c2c5ee34ba4a6edc5f927f00967
0. 수업 전
0-1. 다음에 배울 것은?
‘백엔드’라고 말할 수 있는 이 분야를 배운다면? 그 다음은 무엇을 배울까? 무엇을 공부할까?
정답은 “설계”이다.
우리는 코드는 몰라도 된다. 왜냐면 GPT가 있으니까. 설계를 잘 할 줄 알아야 한다.
0-2. 이번 테스트는 무엇일까?
상당히 어려울 것이다. 하지만 배운 범주에서 벗어나지 않는다!
머리를 써야 할 것. 
서버를 만들 것이다. 서버!
0-3. 곧 프로젝트를 시작할 것이다.
7월 12일 혹은 15일경부터는 랜덤하게 팀을 구성하여 프로젝트를 시작한다.
6월부터 사전팀구성 연습을 할 것이다. 내가 나의 의사를 잔 전달시킬줄 알아야 할 것이고 사람의 말을 이해할 수 있어야 할 것이다.
ERP라는것을 만든다고 하는데,, 재고관리시스템이라고한다. 한 번 찾아보도록 하자. 
→ 비동기 만드는 작업이로서는 아주 훌륭한 훈련 = “힘듦”
→ 대신 역치는 올라가고 느끼는 것이 많을 것이다.
1. 오늘 것을 끝내면 얻게되는 것?
IP deploy가 가능해진다! 직접 서버를 만들었다는 경험!
잘하는거 하나정도는 생기는 것.
열심히 해보자.
PHP, JSP, ASP모두 같은 방식을 사용하고 있다. 웹서비스의 전반에 해당하는 것이다.
이해를 누락하는 일이 없도록 하자.

URL: https://www.notion.so/24-05-13-1876d759ffa748eca991c0ac34524b95
0. 금주의 목표
0-1. 서버 ( Server )
0-2. 프로젝트 단위 ( Dependency Injection )
0-3. 콜백함수 ( callback() )
1. 오전 수업
1-1. GUI SW
1-2. CLI SW
1-3. npm(node package manager)
ㄱ. 라이브러리
ㄴ. 프레임워크
2. 직접 실행해보자.
2-1. 서버를 만들자
※ 시도해볼 문제점
※ 훈련 하기 좋은 방법!
2-2. 요청 프로토콜 방식
ㄱ. GET(getting)방식 ★
ㄴ. POST(편지 방식) ★
ㄷ. CONNECTION (연결) : 통화
ㄹ. PUT
ㅁ. DELETE
※ 검색팁TIP
0. 금주의 목표
0-1. 서버 ( Server )
페이지가 여러개일 때 어떻게 응답을 처리하는가!
0-2. 프로젝트 단위 ( Dependency Injection )
프로젝트 단위라는게 대체 뭐냐!
0-3. 콜백함수 ( callback() )
콜백함수를 정복해야 JavaScript의 기초체력을 쌓아다고 할 수 있다!
1. 오전 수업
1-1. GUI SW 
웹서비스에서 잘 다운로드 받기 좋게 되어있다. 편리하게 설치가 가능!
→ 프로그래밍 레벨에서는 너~무 서비스화가 심하게 되어있다.
1-2. CLI SW
커맨드 환경에서도 다운로드 받을 수 있는 서비스가 존재한다.
이를 package manager라고한다. ★패키지 매니저 환경★ → JavaScript와 Python이 1등공신이 된 이유.
1-3. npm(node package manager)
언어의 커뮤니티 환경 → 스택결정에 지대한 영향을 끼친다 대표적으로 react 
이를 개발자들끼리는 오픈소스 문화라고 한다.
매우 거대한 커뮤니티이기 때문에 안 쓰면 ‘손해’다!
받은 패키지는 도저히 알 수 없다.
→ 그때그때 확인하는 수밖에 없다!
→ 패키지에서 Read.me파일을 확인하도록 하자.
<명령어>
npm init 
→ npm 패키지 관리를 초기화할꺼야.
→ 프로젝트의 시작이다.
<단어>
entry point → 이 프로젝트의 메인 파일은 뭐야????라고 묻는 것.
→ 진입점이라는 의미로 메인파일에 해당한다.
→ 프로젝트를 만났을 때 entry point를 먼저 보는 것으로 되어 있다.
MIT → 무료로 풀었다. 라는 의미
package.json 프로젝트 관리 명세서 → DI라고한다 (Dependency Injection) 직역하면 의존 주입
→ 이 규칙은 node를 사용하는 한 바뀌지 않는다.
→ 이것이 있어야 프로젝트이다! 이것이 없으면 프로젝트가 아니다.
→ 프로젝트(작업) 할 때 항상 node는 package.json 명세 파일을 확인해버릇한다.
→ 최신화 되어있는지만 확인하면 좋다.
→ node기반의 무엇을 하겠다면 항상 해야 한다! 잊지 말 것!
JSON확장자의 뜻 
→ JavaScript Object Notation 
→ ‘자바스크립트의 객체 표기법을 따른 저장방식’
→ 다른 언어도 JSON처리할 때가 너무 많다. 애초에 우리는 JavaScript를 사용하기 때문에 편하게 사용하면 된다. WA! JSON수저!
→ 쉽게 보자. 그냥 자바스크립트 형식의 객체로 저장했다는 뜻이다.
→ 요즘 데이터 교환방식 중 가장 메인에 해당된다.
→ 개발자들간의 교환방식 중의 이야기.
→ 다른 언어끼리도 데이터 교환이 가능하다.
라이브러리 / 프레임워크 → 모두 npm이라는 거대한 도서관에 모여있는 형태이다.
ㄱ. 라이브러리
→ 남이 만든 코드 중에 최종쓰임이 결정되지 않은 것
→ 가지고 뭘 할지 정해져 있지 않기 때문에 아무렇게나 가져다 쓰면 됨.
{
  all: [Function: getLocalizedList],
  random: [Function (anonymous)],
  getName: [Function (anonymous)],
  getId: [Function (anonymous)],
  languages: Set(10) {
    'de',
    'en',
    'fr',
    'es',
    'ja',
    'ko',
    'ru',
    'th',
    'zh-Hans',
    'zh-Hant'
  }
}
ㄴ. 프레임워크 
→  “특정일”을 하는 틀
→  이름만 들어도 아! 이건 어떤 목적이 있구나? 같은게 떠오름
→  남이 만든 코드 이긴 한데, 최종 쓰임이 정해져 있는 것
2. 직접 실행해보자.
2-1. 서버를 만들자
const http = require('http');

const server = http.createServer(function(request,response){
  console.log(request);
});

server.listen(3000);
해당 행위는 어떤포트에 접속요청을 하면 하라는 응답은 안하고 요청 내용을 콘솔로그가 하고 있는 상황이다.
request에 무엇이 담겨있는지를 볼 수 있다. 
결과 request에는 수많은 키와 value가 담겨있었고 이를 말미암아 우리는 request가 객체라는 것을 알 수 있다.
다르게 말하면 내가 request를 통해서 접근할 수 있는 요소들이 이렇게나 많다.
const http = require('http');

const server = http.createServer(function(request,response){
  console.log(request.method);
});

server.listen(3000);
이렇게 콘솔창에 request.method를 사용하면 내가 URL이라고 부르는 방식으로 요청할 때 어떤 프로토콜로 작동하는지 확인할 수 있다.
서버는 GET이라는 프로토콜로 작동하게끔 되어 있기 때문에 콘솔창에 GET이라는 글자가 적혀있는 것을 확인할 수 있다.
지금까지 내가 URL로 접속했던 방식이 GET요청이라는 것을 알게 되었다.
const http = require('http');

const server = http.createServer(function(request, response){
 console.log(request.method);
 console.log(request.url);
});

server.listen(3000);
GET방식은 항상 url을 주게 되어있다고 한다. 협약인가보다!
그렇다면 url을 찾을 수 있다는 뜻이다. 콘솔창에 request.url을 찍어 url을 확인해보았다.
 ‘/’가 출력이 된다.
요청할 때 주는 주소이다. 프로토콜 설립 표준으로 첫번째 GET요청의 주소로 /를 받는다는 약속을 한 것이다.
자 그럼 이제 서버에 내용(content)를 넣고, 그 사이에 console.log(request.url)을 넣어보자.
만약에 method가 GET방식이고 그 url이 /라면 서버를 제작해서 만들어라!
const http = require('http');

const server = http.createServer(function(request,response){
  if(request.method === "GET" ){
    if(request.url === "/"){
      response.statusCode = 200;
      response.setHeader("Content-Type", "text/html");
      response.write(`<html><head><meta charset="UTF-8"></head><body><h1>끼얏호우!</h1></body></html>`)
      console.log(request.url);
      response.end();
    }
  }
});

server.listen(3000);
잘 실행이 된다!
console.log에도 “/”가 잘 들어오는 것을 확인할 수 있다.
response.write가 마음에 들지 않는다! 나는 그냥 html문서를 그대로 들고와서 하고 싶다.
가장 먼저 폴더를 하나 생성해준다. 관습적으로 우리는 폴더를 만들 때 public이라는 이름을 사용해서 폴더를 생성한다.
그리고 관습적으로 html파일은 index.html로 제목을 짓는다.
이 html파일을 불러와서 서버에 나타내고 싶다!
readFileSync를 사용할 것이다.
먼저 fs를 호출해야한다.
const http = require('http');

const fs = require('fs');

const server = http.createServer(function(request,response){
  if(request.method === "GET" ){
    if(request.url === "/"){

      const first = fs.readFileSync("./public/index.html", "utf8");

      response.statusCode = 200;
      response.setHeader("Content-Type", "text/html");
      response.write(first);
      console.log(request.url);
      response.end();
    }
  }
});

server.listen(3000);
중요한 포인트는 내가 GET요청방식일때 url이 / 라면 index.html을 불러와라! 라는 의미이다.
나는 지금 풀스택의 첫 발걸음을 내딛었다고 할 수 있다.
서비스의 시작이다! 웹서비스의 가장 기초바닥을 만들었다.
자 그럼 html에 link와 src의 형식으로 CSS파일과 JavaScript파일을 넣으면 어떻게 되는지 확인해보자.
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>끼얏호우</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <h1>김인티저</h1>
  <script src="index.js"></script>
</body>
</html>
console.log(request.url)의 위치를 조정하고 콘솔창을 보면?
const http = require('http');

const fs = require('fs');

const server = http.createServer(function(request,response){
  if(request.method === "GET" ){
    if(request.url === "/"){
      
      const first = fs.readFileSync("./public/index.html", "utf8");
      
      response.statusCode = 200;
      response.setHeader("Content-Type", "text/html");
      response.write(first);
      response.end();
    }
    console.log(request.url);
  }
});
style.css와 index.js를 요청하고 있는 모습을 확인할 수 있다.
이게 뜻하는 바가 무엇일까?
첫번째는 사용자가 문서를 요청했고, 개발자가 응답을 했다.
그렇다면 두번째와 세번째는 무엇일까? 
→ 문서가 서버에게 style.css와 index.js를 요청한 것이다.
→ 하지만 내가 html파일에 연결하지 않았기 때문에 연결이 대기중으로 나온다.
→ 그리고 화면은 하얀채로 변하지 않는다.
어떻게 해결해야 할까?
다 지정해주면 된다!
const http = require('http');

const fs = require('fs');

const server = http.createServer(function(request,response){
  if(request.method === "GET" ){
    if(request.url === "/"){
      
      const first = fs.readFileSync("./public/index.html", "utf8");
      
      response.statusCode = 200;
      response.setHeader("Content-Type", "text/html; charset=utf-8");
      response.write(first);
      response.end();
    }
    if(request.url === "/style.css"){
      
      const second = fs.readFileSync("./public/style.css", "utf8");
      
      response.statusCode = 200;
      response.setHeader("Content-Type", "text/css; charset=utf-8");
      response.write(second);
      response.end();
    }
    if(request.url === "/index.js"){
      
      const third = fs.readFileSync("./public/index.js");
      
      response.statusCode = 200;
      response.setHeader('Content-Type', 'text/javascript; charset=utf-8');
      response.write(third);
      response.end();
    }
    console.log(request.url);
  }
});

server.listen(3000);
적을 때 주의사항 /하나도 잊지 말고 반드시 적어야 한다.
문서에서 무엇을 요청하는지 알면 다 할 수 있다
console.log(request.url)로 확인된 정보를 그대로 넣어야 한다.
자 여기서 페이지 이동의 원리를 알고싶으면 어떻게 해야할까?
간단하게 시도해보자 a태그를 만들고 거기에 연결을 해주면 된다.
  <a href="minam.html">링크가기</a>
index.html에 다음 태그를 추가하고 서버를 돌려보자.
링크 가기를 누르면? 콘솔창과 네트워크창에 나온다.
/minam.html을 요청하는 문서를 확인할 수 있다. 그러면 어떻게 해야할까?
→ 만들어주면 된다!
minam.html을 대충 약식으로 만들고 바로 적용해보자.
if(request.url === "/minam.html"){
      
      const forth = fs.readFileSync("./public/minam.html", "utf8");
      
      response.statusCode = 200;
      response.setHeader("Content-Type", "text/html; charset=utf-8");
      response.write(forth);
      response.end();
    }
이렇게 추가를 해서 시도해보자.
그러면?
짜잔! 링크가기를 클릭함으로써 이동이 되는 페이지를 나는 만들어 냈다!
‘정적’파일을 송출해내는 서버를 구축해냈다고 할 수 있다.
웹페이지에서 새로운 웹 페이지로 연결시키는 것을 만들어 냈기 때문에 이는 
→ 웹 ‘사이트’를 만들었다고 할 수 있다.
이것을 조금 더 발전시켜서 소프트웨어처럼 움직이게 만들어내면? 웹’앱’이 되는 것이다.
@May 13, 2024 8:00 PM
 ※ 시도해볼 문제점
if문 줄여보자! 랩핑합시다.
※ 훈련 하기 좋은 방법!
메뉴바 만들기!
2-2. 요청 프로토콜 방식
서버한테 데이터(웹사이트같은)를 요청하는 프로토콜 방식은 단 5개이다.
남에게 맡길 수 없는 우리가 메인으로 핸들링 해야 할 요소.
ㄱ. GET(getting)방식 ★
→ 가장 많이 쓰이는 방식
→ 가장 단출한 방식(짧은 데이터, 간단한 요청)
→ URL로 접속하는 방식
→ 약식이기 때문에 data에 제한이 걸려있다.
→ 완전하게 핸들링 해야 할 방식 두 가지 중 하나
→ 항상 URL을 주게 되어 있다.
ㄴ. POST(편지 방식) ★ 
→ 개발자가 가장 많이 하게 될 방식
→ GET도 마찬가지지만 내가 가장 먼저 정복해야하는 방식.
→ 쉽게 말하면 게시판에 글을 쓰는 행위가 POST방식이다.
→ 태초의 요청방식이었다. 근데 해보니 짧은것도 이렇게 보내려면 불편해서 GET방식을 추가한 것
→ heavy한 것들은 모두 POST로 처리한다.
→ 완전하게 핸들링 해야할 방식 두 가지 중 하나
ㄷ. CONNECTION (연결) : 통화
→ 웹서비스에는 적합하지 않음
→ 채팅과같은 상대방과 연결되어 있는 상황이 적합함.
→ 중요한 파일을 넘겨야 한다던가 하는 둘 모두가 입회하에 사용할 것들에 사용
ㄹ. PUT
ㅁ. DELETE
※ 검색팁TIP
우리는 App server다!
Web server가 아닙니다! 서버관련에서 검색을 할 때에는 App server를 참고하도록 합시다!
HTML serving을 검색하는 것이 훨씬 좋을 것입니다!
앞에 접두사는 vanilla node.js를 사용합시다!

URL: https://www.notion.so/5-0b129eea0d14464aad8af70c7e5b1589
24/05/13
24/05/14
24/05/16
24/05/17

URL: https://www.notion.so/24-05-10-7dc6005ba81f444eb0ca6997b476ab59
0. 수업시작 전
classroom을 확인. JavaScript의 미묘한 억양차이.
→ 호이스팅 현상에 주의하자
→ 선언형 함수는 같은 공간에 있으면 그것이 나중에 선언되었더라도, 호이스팅 현상이 일어나서 호출해서 불러온다.
console.log(first(1,2));
function first(a,b){
 return a + b;
}
// 실행이 된다. 3이란 값이 출력됨.
→ 함수 표현식은 호이스팅이 일어나지 않는다.
console.log(second(1,2)); // 실행되지 않는다.
const second = function(a,b){
 return a + b;
}
console.log(second(1,2)); // 실행이 된다.
처음 적은 first는 실행되지만 second는 되지 않는 모습.
1. 금일 수업 내용 대전제 
감당하지 못할 데이터를 다루어 보자.
첫 번째 미션.
각각의 배열원소가 HTML에 담겨서 h1태그의 textNode로 만들어 주세요.
title도 포켓몬 이름에 맞게 해주세요.
총 1025개의 html을 만들게 되는 것이다.
html을 배열의 원소 갯수만큼 만들어 주세요.
→ 성공! 했다 하지만 일단 오답노트?를 적어보자.
→ 내 생각에는 일단 createServer를 만들고 req는 빼고,
data라는게 있으니까 그대로 갖다 쓰면 되고,
writeFile을 쓰는데 반복문 안에 넣어서 쓰자.
조건문은 data.length보다 작게
자체적으로 폴더를 만들고 그 폴더안에 html을 들어가게 해볼까?
두 번째 미션.
만약에 된다면? 포켓몬 번호를 입력해 주세요 
혹은 세글자만 있는 애들만 만들어 주세요.
혹은 앞글자가 이인친구 리인친구 각각 카운팅을 해주세요.
이것으로 가공을 여러가지로 해보세요
배열을 쓰는 여러가지 방법을 생각해 보세요.
이렇게 해보자!
create서버안에 appendFile을 쓰되, for문을 사용해서 하나의 html에 모든 것을 넣어 보자.
만약에 이게되면 아마 writeFile로도 되겠지?
오후 작업을.
하나의 html에 모든 포켓몬 넣기.
생각 정리부터하자.
h1태그를 여러개를 넣으려면 어떻게 해야할까?
일단 반복이니까 반복문을 넣고 싶어.
무조건 반복이다. 그렇다면 +=을 사용하면 안되나?
근데 그걸 어떻게 하지?
배열을 갖다 때려박으면안되나?
해결했다! 어떻게 해결했나요?
let arrayA = [];
let arrayB = [];
for(let i = 0; i < data.length; i++){
  if(data[i].length ===3 ){
    const h1ContentA = `
    <h1>코드번호${i+1}</h1>
    <h1>: ${data[i]}</h1>
    `;
    arrayA += h1ContentA;
  } else {
    const h1ContentB = `
    <h1>코드번호${i+1}</h1>
    <h1>: ${data[i]}</h1>
    `;
    arrayB += h1ContentB;
  }
}
새로운 변수를 2개 선언하고 각각 배열을 할당해서 초기화했다.
이후 for반복문을 사용하여 내가 원하는 조건으로 각각의 배열로 할당했다.
저 배열은 할당된 태그가째로 들어있기 때문에 저것을 내부 콘텐츠로 넣으면 h1태그가 그대로 들어가게 된다.
const mainDoc = `
  <!DOCTYPE html>
  <html lang="ko">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width", "initial-scale=1.0">
      <title>포켓몬도감</title>
    </head>
    <body>
`;

let array = [];
for(let i = 0; i < data.length; i++){
  const h1Content = `
    <h1>코드번호${i}</h1>
    <h1>: ${data[i]}</h1>
  `
  array += h1Content;
}

const lastDoc = `
    </body>
  </html>
`

  fs.writeFile(`./포켓몬도감.html`, mainDoc + array + lastDoc,(err)=>{
    if(err){
      console.error("에러발생! : ", err);
    }
3글자만 뽑기
→ 클리어! 문자열도 
3글자 아닌 애들 번호까지 유지시켜서 한페이지에 뽑기
→ 클리어
const http = require('http');

const port = process.env.PORT || 3000;

const fs = require('fs');

function loadPokemonNames(path) {
  try {


    if (typeof(path) === "string") {
      const pokemonValue = fs.readFileSync(path, 'utf8');
      return JSON.parse(pokemonValue);
    } 
    // else 를 사용하는 대신 try catch 문법을 사용해서 에러를 잡아내는 것이
    // '에러 처리'라는 것을 명시적으로 이야기 하는 좋은 어휘


  } catch (error) {


    // 매개변수 error는 catch구문이 실행될 때 자동으로 전달되는 변수
    console.error("에러 내용:", error);


  }
}

const data = loadPokemonNames("./pokemonNames.json");

const mainDoc = `
  <!DOCTYPE html>
  <html lang="ko">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>포켓몬도감</title>
    </head>
    <body>
`;

let arrayA = [];
let arrayB = [];
for(let i = 0; i < data.length; i++){
  if(data[i].length ===3 ){
    const h1ContentA = `
    <h1>코드번호${i+1}</h1>
    <h1>: ${data[i]}</h1>
    `;
    arrayA += h1ContentA;
  } else {
    const h1ContentB = `
    <h1>코드번호${i+1}</h1>
    <h1>: ${data[i]}</h1>
    `;
    arrayB += h1ContentB;
  }
}

const lastDoc = `
    </body>
  </html>
`

  fs.writeFile(`./3글자포켓몬.html`, mainDoc + arrayA + lastDoc,(err)=>{
    if(err){
      console.error("에러발생! : ", err);
    }
  });

  fs.writeFile(`./3글자가아님.html`, mainDoc + arrayB + lastDoc,(err)=>{
    if(err){
      console.error("에러발생! : ", err);
    }
  });

  // ! 예상은 html파일이 2개가 생성이 될 것이다.
  // ! 하나는 3글자인 포켓몬
  // ! 다른 하나는 이외의 포켓몬.
  // ! 예상대로 실행이 되었다.


  const server = http.createServer((req,res)=>{
    fs.readFile("./3글자가아님.html", "utf8",(err,datacell)=>{
      if(err){
        console.error("에러가발생! : ", err);
        return;
      }
      res.writeHead(200, {"Content-Type":"text/html"});
      res.end(datacell);
    });
  })

  server.listen(port);

URL: https://www.notion.so/24-05-09-a62e7fe2354843f69ad30d6a9afce3ca
CJS방식으로 내보내기!
module.exports개념을 이해해보자. 
그대로 따라했는데 되지 않는다. 그렇다면 뭔가 다른게 있다는 뜻 
console.log(studentNamesArray)를 찍으니 빈 객체가 나온다.
그렇다면 데이터가 입력되지 않았다는 뜻이다. 배열도 가져오지 않았다.
names-data.js에 module.exports를 추가하니 실행이 된다!
module화 시켜주는 건가?
※ 콜백함수(callback function)
매개변수 → 실제값이라고 하기 어렵다!
datatype에 해당하는 것들은 모두 매개변수로 넣을 수 있다.
→ 데이터타입은 10개가 채 안된다.
num,object,func,null,undefined,boolean,string,char …
function a(a,b){
  console.log(arguments[0]);
  console.log(arguments[1]);
  return [a, b];
}

const busy = a("에이", "비");

console.log(busy);
여기서 a , b 를 적지 않았고 arguments를 사용하였다.
사실 a, b는 사람들이 알기 편하게 한것이고 arguments를 사용해도 매개변수를 가져올 수 있다.
쉼표가 들어갔다는 것은 배열이라는 것이다.
즉 매개변수를 넣는 것은 사실상 배열을 넣는 것이나 다름 없다.
데이터타입이 배열이란 것은 아니고, 배열식으로 처리한다.
arguments란 단어를 봐도 당황하지말고 아! 매개변수구나~ 라고 알아먹자!
function a(a,b){
  console.log(arguments[0]);
  console.log(arguments[1]);
  console.log(arguments);
  return [a, b];
}

a("에이", "비");
// 이를 실행하면
에이
비
[Arguments] { '0': '에이', '1': '비' }
// 가나온다.
ETC. 그간의 함수.
기능을 잘 만들거야 → 잘 쓸거야! ← 정적인 함수방식
function a(a, b){
 return a + b;
}
지금의 함수
기능을 내가 ‘호출’할 때 정해도 돼? ← 동적인 함수방식
function b(a, b, callback){
 callback(a, b);
}
매개변수는 정해져 있지 않다. 만약 내가 더하기를 사용하고 싶다면?
b(1, 2, function(a, b){
 console.log(a + b);
});
호출할 때 함수를 정의한다! 그래서 재활용 성은 꽝이다.
b라는 함수를 실행할 때 함수가 정해져있지 않기 때문에, 어떤 결과가 나올지는 모른다.
b는 그저 callback을 실행시키기 위한 함수로서 기능한다고 볼 수 있다.
개발자가 결정하기 편하기 위해서 내장함수들은 복잡한 로직은 콜백함수 방식으로 인계를 해놓았다.
콜백함수에 이름이 없다!
이름이 없는 함수 = 익명함수라고 한다.
이름이 있는 함수 = 기명함수라고 한다.
결과적으로 나중에는 익명함수를 ‘식별’하게 될 것이다.
콜백함수를 재사용할 것이 아니라면! ‘ 매개변수 자리’에서 함수를 만들어버리고 마는 패턴을 정말 많이 쓴다.
Keywords
기명 vs 익명
자스는 유독 종류가 많음 (함수 만들기)
함수 리터럴, 함수 표현식, 익명함수중 하나
→ 변수를 활용해서 이름이 있는 것 처럼 한다.
const a = function(){
 console.log('hello');
}
오전 정리
우리가 지금까지 쓰던 함수 방식은
→ 함수 선언 방식 function statement
→ 이름이 있다. (기명 함수이다)
→ 특급대우 first class citizen, 일급객체!
이제부터 배우고 사용하게 될 방식은
→ 함수 표현식 function expression
→ function literal이라고 하기도 한다.
→ 이름이 없다! (익명 함수)(★)
→ 변수 할당과 같은 변형작업으로 마치 이름이 있는 것처럼 쓸 수 있다.
→ 특별 대우는 받지 않음!(★)
→ ★표시는 보안에 좋다! 특별대우를 받지 않고 이름도 없기때문에 접근하기 어려울 것!
const a = function(first) {
  console.log(first);
}
a();
// 이름 없는 함수를 저장해서 나만아는 용도로 쓰기 때문에 보안에 좋다.
// 아 function쓰기도 귀찮은데 function도 안적으면 안됨?

const b = first => console.log(first);
b();
// 화살표 함수가 그렇게 나타났다. 극단적으로 축약하면 중괄호도 줄일 수 있다.
// 매개변수가 1개라면 소괄호까지 지워도 된다.
// 이것은 극단적으로 줄인 형태이다.

const c = (first) => {
  console.log(first);
}
// 보통의(?) 화살표 함수.

// >=이것은 조건연산 => 이것이 arrow function작성법이다.
만약에 극단적으로 줄인 화살표 함수를 보고 당신이 짜증이났나요?
축하드립니다! 당신은 개발자가 되었습니다.
코드가 짧은 것이 매번 좋은 것은 아니게 된다. 왜냐하면 파악하기 힘들다.
그리고 개발을 하는 것은 홀로 하기보단 협업이 많기 때문에 다른 사람의 코드 가독성을 위해서 너무 짧은 코드보단 차라리 길게 적어서 뜯어서 확인할 수 있게 해주자.
코드가 길다? → 뜯어서 확인이 가능함(수고를 들이면됨)
코드가 짧다? → 외우거나 특수한 경우를 확인해야 한다.
내가 현재 배우는 입장에서 코드가 짧은 것은 좋은 것은 아니다
너무 짧아져서 한눈에 보이기 시작하면 그것을 이해하는 것이 아닌
외워 버리게 된다. ← 위험도★★★★★★★★★★★
개발자들이 자꾸 엄격함을 요구함.
⇒ 자바스크립트는 너~~무 유연해서 단점으로 작용할 때가 많다.
→ error는 나도 버그는 감춰지는 치명적인 문제가 발생! 
→ 근데 그것을 모른다. 어디서 버그가 나는지 알 수가 없다!
→ error는 발생할수록 안전해진다.
→ 버그는 못찾을 수록 문제가 된다
그래서 엄격한 언어인 TypeScript를 배운다. 
엄격함의 예를 들어보자.
function work(string){
 console.log(string);
}

work("안녕");
work(1111);
work(true);
work({name : "김인티저"});
왜 문제일까? 모두가 출력이 되어서 문제이다.
매개변수는 매개변수일 뿐 이것을 문자열타입만 받아서 실행되어야 한다면? 코드를 추가해야 할 것이다.
function work(string){
 if(typeof(string) === 'string'){
  console.log(string);
 } else {
  console.log("이건 내가 원하는게 아니야!");
 }
}
이러면 함수는 “string”타입일 때만 출력을 하고 그렇지 않으면 다른 지정한 문구를 출력한다.
타입 안정성 type safety
→ 중구난방으로 데이터타입이 들어오기 시작하면 일이 불가능하므로,
→ 원하는 데이터 타입만 들어오게끔
→ 매개변수의 허용범위를 정해주는 개념.
function work(string){
 try{
  if(typeof(string) === "string"){
   console.log(string);
  }
 } catch(error){
  console.error(error,"이건 내가 원하는게 아니야!");
 }
}

work("안녕"); // 안녕
work(111); // 출력되지 않음
work(true); // 출력되지 않음
work({name : "김인티저"}); // 출력되지 않음
NodeJS팁! node명령어를 친 이후 내가 찾고싶은 파일 앞글자를 입력하고 tab을 누르면 자동으로 찾아준다!
배열 기본 함수 : 배열메서드
누군가가 겁나게 필요해서 요청하고 심의하고, 유효성, 실효성, 검증이 끝났다.
그냥 너~무 많이 써서 만든거다.
편리함을 추구하는 자스개발자들에게는 더할나위 없이 중요한 내장함수들이다! DOM API다!
선언형 함수를 절차형으로 바꾸는것좀 연습해볼까?
함수만 쓰면 → 함수, 펑션이라고 하는데?
객체 안에 함수가 있는 것을 → methods라고 부른다
객체가 만들어졌다는 뜻은 → 내장이라는 의미이다.
→ 내장 메서드를 의미한다.
누군가가 편의를 위해서 만들어 놓은 것.
메서드 === ‘누군가가 만들어놓은 함수’
오후 작업
html로 뽑아주는 걸만들어보자.
그냥 버튼하나 만들어서 클릭하면 텍스트가 짠! 하고 나오는거지.
암묵지 타임
화살표 함수 ( arrow function)
기명함수와 익명함수
메서드
→ 배열메서드부터 확인
callback()
arguments

URL: https://www.notion.so/24-05-08-fe6b43d602314de989b4236604fc0e54
1. Node.js를 공부할 때
명령어가 다르다. keyword가 다르다. 책을 읽기 전에 가져가자.
나에게 필요한 지식들을 가져와서 하는 것.
☆ 금일 배울 것
response와 request를 핸들링해보자.
response와 request는 우리가 주력이다. 
콜백(callback)함수 ← 굉장히 많이 쓴다. ★*1,000,000
→ ‘기저사항’ return을 이해하고 있어야 한다.
→ return이 있는 것과 없는 것을 구분해서 사용할 수 있어야 한다.
→ 콜백의 경우 대부분 return이 없는 것을 다루고 있다.
→ 모르면 개발 불가능.
☆ 금주 목표
1. serving하는 것을 계속해서 연습할 것이고
난 대체 뭘 서비스를 해줄까?
2. 외로? 패턴? 그것을 계속 연습할 것이다.
내가 만든 것들에 대한 추렴을 하고 있을까? 9월달의 나는?
애초에 만든 것은 있나? 만들어야지..
1. Node.js 익숙해지기
경로상에 - 한글이 섞여있으면 안된다.
“”:띄어쓰기도 불허
숫자로 시작하는 일 : 불허
특수기호로 시작되는 것 : x
파일끼리 모아놓는 것 x
디렉토리를 모아놓는 것 o
뭔진 모르지만 → 누가 미리 만들었단 이야기는 → 어딘가에 적혀있다는 뜻.
http가 객체라는 것을 알게됨.
Node.js 공식홈페이지의 Docs를 참고할 수 있는데 전혀 이해할 수 없을 것이다.
지금까지 연습했던 분야와 완전히 다른 이야기 → 모르는게 너무나도 당연하다! 
: 단어를 뽑아내보자! 이게 뭐지? 물음만 뽑아내는 작업을 하자.
마치 처음에 코드를 배웠던 것 처럼.
뜯어볼 키워드 : [ “http”, “Path(경로를 다루는 모듈)”, “URL”, “Permission( 권한 관리 모드 → 단어만 가져가자)”, “file system : fs ” ]
fs는 중요도 ★★★★★★★★
Node.js는 백엔드이기 때문에 OS를 감지할 수 있다.
2. 문서를 주는 방법.
htt’p’ protocol 규칙
규칙에는 항상 내부규칙이 있다.
statusCode라는 상태코드를 주게되어있다.
200 = OK, 404 = Not Found, 500 = Internet server error
브라우저한테 보내주는 명세표.
what is Header? 
→metadata에 넣는 양식 html에서 <head>태그에 해당하는 녀석
protocol 규칙 가장 먼저 header파일을 주게 되어 있다.
문서인지부터 검사하는 것. json이면 객체 text면 text등등, 먼저 검사하는 과정을 겪는다.
text/plain과 text/html은 서로 출력하는 값이 다르다.
html의 경우 html의 형식으로 plain의 경우 그냥 text로 나타난다.
res.end()는 왜 들어가있을까?
end()를 쓰지않으면, 완료가 되지 않는다. 
하나의 약속이다. end()를 반드시 적어주어야한다. 외워야 하는 부분. 동작방식을 외워야 한다.
통신방식과 관련이 있다. 패킷방식은 던지고 끝내버리기 때문에, 응답을 끊어줄 필요가있다.
응답을 끊어서 다음 사람이 사용할 수 있게 해주어야 한다. 즉, 비워주어야 한다.
★ 정리!
node
기능을 모두 외울 순 없다(바보)
‘익숙해질 때까지’는 찾는 것을 전제로 한다.
파일을 만들 수도 있다.
‘나’를 대신하여 파일을 전송해주는 NPC를 만들 수도 있다.
‘알기만 한다면’ 퍼포먼스는 무궁무진하다.
좋은 개발자가 되려면 함수를 ‘슬기롭게 쓸 줄”알아야 한다. → 그에 대해 생각해라
진짜진짜진짜 편하자고 만든 언어이다! 까고보면 C++
아직 체감은 안되겠지만 상대적인 마음으로 들어가보자!
헷갈릴 수 있는 point
Node.js(극단적인 편의성만 본 언어)
→ ‘궁여지책’으로 모듈을 구현하기 위해서
import(가져오기), export(내보내기)를 놓쳤다. 구현하지 못했다.
→”요청”이라는 함수를 만들어서 사용한다.
이것이 .require();함수 ← 궁여지책의 산물.
—CommonJS(공통JS) require방식을 부르는 말 CJS라고 부르기도 함
→ 반드시 없어져야 할 산물이다. 함수를 요청해서 모듈을 가져온다? 말도 안됨
궁여지책이라는 것을 자신들도 알아서 개선해 주었다.
ESM(제대로 된 방식) → cjs로 번역(스스로)
미션!
1. a.html을 하나 만든다.
2. app.js에서 시작해서 만들어보아라.
3. code로 html을 만들어라.
4. 만든놈을 serving해주어라! 어디 port에 물려서 보내줘!
5. server.js는 서빙만 해주는거임.
정리해보자
app.js로 a.html을 만들고 server.js로 서빙해라.
일단 필요한것은 file system fs를 찾아야 된다.
그리고 연동할 것도 찾아야된다.
js로 파일을 실행하는 법도 알아야 겠구나.
암묵지
http 의 Header
res.end()
if(err)와 throw는 무엇일까?
writeHead는 무엇일까 왜쓸까?
file system은 무엇일까?
path는 무엇일까? 경로란 뜻 아닌가?
Protocol! 알아놔야 하는 규약이다!
callback함수는 무엇일까? 책을 읽어보자!
☆ 인생조언(?)
3개월뒤의 자신을 생각하고, 그때의 자신은 포트폴리오를 만들었는지? 아니 사실 3개월밖에 남지 않았다. 3개월이나 남았다고 할 수도있겠다.
그때의 나는 내가 만든 것들을 되돌아보면서 고칠 수 있을까? 보수라고 할 수 있겠다. 보수하고 있을까? 
기복을 없애자. 늘 의연하게 하는거다.

URL: https://www.notion.so/e8e63b06f2d04051985ebeefae0804cd
직통으로연결한것
만약 바로옆집이라고한다면 그냥 벽에구멍뚫은거다
매우 극단적인 예이긴하지만
그렇게 뚫린 벽은 안쓰면 낭비가된다 그냥 뚫려있을뿐
그래서 낭비가 있다는 단점이있다.

URL: https://www.notion.so/7ba02b1e736447f1b868be5208e867f4
내가 주문을 한 물품이 너무많아서 택배차 한개로 오려면 오래걸리는데
다른택배차 여러대가 조금씩 갖다주는방식인것같은데 

URL: https://www.notion.so/24-05-07-64922c55903e417bbea9b7609400486f
Keyword.
브라우저 바깥!
Node.js ← ?  JavaScript의 하위가 아니다! 수단을 JavaScript를 쓰는 것일 뿐이다.
자바스크립트는 원래 브라우저 안에 갇혀있는 언어이다. 이것을 어거지로 끌어낸 것이 Node.js이다.
Node.js VS python 두가지를 파악하면서 어느것이 나에게 알맞은 언어인지 확인해보자!
JavaScript코어와 DOMAPI와 Node.js를 구분할 줄 알아야 한다.
화이팅!
강사님의 키워드 “혼자서”라는 키워드는 자유롭다는 의미이다. 다 나혼자 독불장군처럼 한다가 아니라~ 자유롭다!라고 생각해보자.
내가 얼마나 바뀌었는가?를 체크해보자. 현재 나는 훈련을 시작한지 5분의 1이 지났다고 한다. 안 바뀐게 뭐가 있을까?
게으름! 여전히 바뀌지 않았다. 좀 더 끓는 점이라고 해야할까? 낮아진 것 같다. 처음 3주는 바뀐 주말을 보냈는데, 바로 전 주 주말은 완전히 풀어진 주말을 보냈다. 확실히 좋긴한데, 마음속으로 해야되는데가 떠오르고 있었다. 아! 확실히 바뀌긴 했구나. 그럼 좀 더 나의 내면의 목소리에 귀를 기울여야하는데 아직 귀울이지 못하고 있구나. 화이팅!
가져가야 할 것 ★버전 개념★ ← 중요!
버전 표기명 ( 일반적인 형태 )
v 몇 . 몇 . 몇
v. majorVersion . minorVersion(높을수록 좋음) . fix(핫픽스)
둘째자리와 셋째자리는 숫자가 높을수록 완성도가 높아졌다는 의미
첫째 자리는 완성도보다는 새로운 컨셉이 추가되었다. 라고 보면 좋다.
때문에 때에 따라서는 메이저 버전을 낮추기도 한다.
→ 버전이 낮을수록 신기술은 못쓰지만 안전성을 챙길 수 있다.  
→ 사람의 손을 많이 탄 작품이 많기 때문에.
→ 버전이 높을수록 ‘신기술’이 많다.
→ ‘안전성’이 문제일 확률이 높다. 말 그대로 신기술이기 때문에 검증되어 있는 문제가 없다. 내가 검증하게 될 수도?
이 버전을 쓰겠다! → 그 버전의 ‘컨셉’을 사용하겠다와 다르지 않다. → 스택 결정이라 한다.
시간이 지남에 따라 사용하지 않게되는 것들, 권장되지 않는 것들이 있다.
JavaScript의 경우 변수 선언에 var보다는 let을 사용하라고 한다.
var : 재할당(이름포함)이 가능하다, 영역기준이 개발자한테 골탕을 먹이는 기준이다.
let : 재할당이 불가하다(안전성이 높다) → 개발자가 원하는 형태이다, {},블럭 스코프, 렉시컬 스코프 lexical scope
Node.js의 버전 패턴.
 홀수버전이 테스트 버전이다.
→ ex) 21버전은 사용해선 안된다. 테스트가 목적이 아니라면 사용해선 아니된다. 서비스 X
→ 안정성이 보장되어 있지 않음.
LTS 버전. 짝수 버전 Long Term Service.
일정 기간동안은 이 버전을 보증해주겠다.
chocolatey 설치를 함께 할 것
?? chocolatey란? GUI를 사용하지 않고, sw다운로드 받는 CLI 앱스토어 정석 이름은 패키지 매니저
남이 쓴 코드를 빨리 받기 위함이다.
node —version ← cmd 명령어 버전 확인 명령어
패키지 매니저 종류.
Homebrew(Mac) === chocolatey(window) === apt(Linux) === npm(Node.js)
패키지 매니저는 개발자 도구에 해당하는 것이기 때문에 일반인들이 다루기는 상당히 곤란하다.
다른점은 다운로드 속도나 software의 양이 다르다.
window의 경우 powershell 관리자 모드로 실행
→ 보안정책을 바꾸는 작업이 있다.
→ powerShell은 상당히 강력한 CLI중 하나로 보안을 풀어줘야한다.
→ 확인방법은 node —version을 입력해보면 된다.
node.js는 자바스크립트는 모두 브라우저에서 사용해야하잖아? 그냥 브라우저 안키고 하면안되나?에서 시작한것.
그래서 터미널에서 확인해서 할 수도 있다.
콘솔창에 찍는 로그를 터미널에서 확인해보았다.
주의점! 
node.js가 어디에서 시작되는지의 문제때문에 명령줄이 위치하고 있는 곳이 중요하다. 
명령줄이 위치하고 있는 곳 === ‘폴더열기 GUI’와 같아야 한다.
쉽게말해서 cd로 막 옮기고 해라.
→ 되도록이면 폴더는 하나씩 하자.
Node.js를 한다면!
ctrl + c 서버 종료
node 파일명 ← 터미널로 확인할 수 있음 브라우저가 아닌
ctrl을 누르고 마우스 좌클릭을 하면 localport에 들어갈 수 있다.
같은 JavaScript지만 영역이 다르다.
이게 사사하는바가 무엇인가? 나는 웹사이트를 만들어냈다!
serving을 성공했다!
localhost는 내가 보는 거일 뿐, 이것을 남에게 보이는 것으로만 바꾸면? 내가 웹사이트를 만들어냈다!
이제 여기에 도메인(?)을 입히고, 배포까지 하면 내가 서비스를 한 것이 된다.
// 문자열일 뿐인 것을 html로 변환시켰다.
// 프론트 엔드는 할 수 없다. 
// 프론트 엔드는 기본적으로 쓰기 권한이 불가능하다. 왜? 인터넷이 무법지대가 되버리니까
// 그렇기 때문에 인증된 사람만이 사용할 수 있다.
글쓰기는 사실상 쓰기’권한’을 판매하고 있는 것이다.
보안적인 측면을 고려하는 것이다.
localhost는 내가 연 서버를 내가 들어간다는 암묵적인 약속이다.
포트값 5000번대는 vscode의 live server에 뺏겼기때문에 5000번대는 안된다.
백엔드에서 Node.js를 사용하면?
CRUD(Create, Read, Update, Delete)
4가지의 권한 관리.
Create (write) 쓰다. // 코드로 파일 만들기가 가능해진다.
Read 읽어냈다. // RAM  RAM에 담기는 행위를 Read라고 한다.
(Load가 여기에 해당이 된다.) RAM메모리에 적재중(loading)
위 코드에서 변수를 위에 미리 적은 이유가 적재한 것에 해당한다.
Update 갱신하다. // 사실상 Create다. 옛날 것을 지우고 새로운 것을 끼운다. C와 R을 적절히 섞어서 무언가를 한다.
Delete 삭제하다. // 복구가 되지 않는다. 복원하는데 상당히 많은 노력이 필요하다. 매우 굉장한 권한이다.
Node.js의 4가지 권한은 무엇이면 어떻게 조합하면 무엇이 가능할까? 이는 브라우저와는 관련이 없는 이야기이다. 자바스크립트의 전유물은 아니고 프로그래밍 전체의 전유물이다. 그렇기 때문에 이해를 반드시 해두어야 할 듯싶다.
어떤 언어든지 CRUD만 알면 기본기는 할 수 있는 것이다.
그러면 Node와 Python의 CRUD부터 알아볼까?
서버(server)란?
서버는 요청(requset)을 받고 응답(response)을 하는 곳이다.
자판기를 생각해도 좋다. 하지만 이제 재화를 내지 않는.
간단한 예로 말하자면 패스트푸드점의 키오스크다.
우리는 키오스크에서 주문을 하고, 키오스크는 주방의 스크린에 주문내용과 그 key를 출력할 것이다. 음성으로 할 수도 있고, 문자로 표기할 수 도있다.
너무 어렵게 생각하지말자, 서버는 키오스크다.
사용자의 요구에 맞춰서 그 응답으로써 음식까지 뱉어낼 줄 아는 것일 뿐.
너무 어렵게 생각하지말자, 요청에 응답하는 개념이다.
개발자가 만드는 서버의 목적은? 서빙을 사람이 아니라 기계가하게 하는 것이 목적이다.
간단한 요청에는 기계가 알아서 자동으로 응답할 수 있게끔 하는게 궁극적인 목표가 될 것이다.
( 자동화 식당들을 생각하면 편하다. ) 커피원두를 볶아서 아메리카노를 내려서 손님에게 전달하는 기계같은 것.
사람을 대신할 반복적인 무언가. 쉽게말해서 사람의 일자리를 뺏는 것이구나! Wa!
일자리를 뺏는다고 하는건 좀 이상한데? 사람에게 시간을 벌어주는 것이 맞겠다. 다만 그것만으로 먹고 살던 사람들에게는 어떤의미론 재앙이 된다.
그러니까 사람들의 평균 수준이 상당히 높아지겠구나.
높아지지 않으면? 도태되고, 돈을 벌지 못하고, 상당히 슬픈 개념이었구나. 물론 아직 만들어지지 않았지만.
좋게 생각하자. 사람의 시간을 벌어주게 만드는 것.
늘 그렇듯이 어렵진 않다. 낯설었을 뿐이고, 어려운 것은 창의적인 것이다.
서버는 요청과 응답을 해주는 자동기계일 뿐이다.
요청을 걸러서 받을 수도 있다. 락을 걸을 수도있다는 것이다.
서버가 동작하는 기저는?
‘선’! 연결망, 다 물리적으로 연결이 되어 있다. 해저로.
1. 통신 방식이 다를뿐이다!!
송신자와 수신자가 있다는 것은 변하지 않는다.
이 두 가지가 성립이 되어야 통신이라고 한다.
둘중에 하나라도 통신상태가 아니면, 단절되는 구조이다.
그리고 서버는 이것이 성립이 된다.
전화기를 생각하면 편한다.
이것을 회선통신방식이라고 한다.
회선통신방식의 특징은 송신자와 수신자가 특정된다. 그리고 둘 다 온라인이여야 한다.
회선방식
2. packet통신방식. @May 7, 2024 8:00 PM
 웹서비스의 서비스의 근간. packet통신방식으로 이루어진다.
반드시 찾아보자.
송신자가 언제 들어올지도 모르고, 수신자가 언제 나갈지도 모른다 그렇기 때문에 분할해서 송수신을 한다. 
패킷
요청(request)과 응답(response), 회선과 packet(전단지, 도장쿠폰을 생각하면 편하다)
통신체제의 대체제가 필요하다.
이것은 웹 서비스 중 네트워크의 파트이다.
메일과 html은 뭐가 다를까?
메일은 송수신자가 확실하다. http는 송신자 혹은 수신자 둘중 한명이 없어도 중계자가 자리를 대신해도 된다.
메일은 사용하는 프로토콜이 다르다.
SMTP(Simple Mail Transfer Protocol)라는 프로토콜을 사용한다.
같이 가져가자. FTP(File Transfer Protocol) 이건 뭘까?
서버를 만드는 것은 온라인에서 이루어지기 때문에 네트워크를 배워야 한다.
네트워크는 어렵다. 왜 어려울까? 
보이지 않아서 그렇다. ip, web server안보인다! 모른다!
강사님의 추천을 받아보자.
IoT(Internet of Things)? 네트워크 기반 개발이다.
네트워크에는 식별이 필요하다.
→ server가 필요하다
웹 서비스 개발자라고 한다면, basic서버 하나정도는 만들 수 있어야 한다. ← 전제조건.
http의 전반적인 한 사이클을 정복해보자!
오후 연습.
CRUD를 가지고 문자열로된 무언가를 만들어보거나, 파일을 만들어보자.
Node로 CRUD 실험한번 해보기.
암묵지
회선통신방식 → network이야기이다 computer의 이야기가 아님.
packet통신방식
SMTP, FTP
네트워크는 기본소양으로 가져보도록 하자!

URL: https://www.notion.so/5-fbc8d862de874194b7d4f73649c20d50
24/05/07
24/05/08
24/05/09
24/05/10

URL: https://www.notion.so/24-05-03-4a11e2f5055d45939f556f52e8e0d621
참고하면 좋은 검색어 개발자의 다이어그램
상당히 긴 코드를 일목요연하게 뜯어보는 작업을 하였다.
여기에 그 내용을 다시한번 정리해보자.
정리 순서는 html태그에서 부터 그 태그의 역할.
그리고 함수의 역할을 적고
어째서 이런 API를 사용할 필요가 있었는지까지.
1. html태그
<div id="root"></div>
<input id="todo-input" type="text" placeholder="할 일을 입력하세요">
<select id="order-select" title="Order Select">
</select>
<button id="add-button">항목추가</button>
<button id="remove-button">항목 제거</button>
div#root의 역할은 하나의 컨테이너다.
출력이 될 이후 나중에 추가할 리스트들을 보관하기위한 창고의 역할을 한다.
input태그는 내가 무엇을 할지에 대한 내용을 적기 위한 공간이다. 사용자에게서 메세지를 받기 위한 공간이라고 할 수 있겠다.
select태그는 input태그의 입력으로 만들어진 리스트에 접근하기 위한 장치로 활용된다. select태그를 통해 리스트에 접근하고 button태그를 통해 동적으로 문서를 제어한다.
만약에 내용이 추가되면 전역 배열을 참고하여 항목의 순서대로 옵션을 만들어서 select에 추가된다.
btn태그는 항목을 추가하기 위한 버튼과 제거하기위한 버튼이 있다.
2. 각 함수의 역할.
2-1. updateSelectOptions() 
function updateSelectOptions() {
 let length = todoItems.length;
 orderSelect.innerHTML = '';
 
 for (let i = 0; i < length; i++) {
  let option = document.createElement('option');
  option.value = i;
  option.text = `항목${i+1}`;
  orderSelect.appendChild(option);
 }
 let lastOption = document.createElement('option');
 lastOption.value = "마지막";
 lastOption.text = "마지막";
 orderSelect.appendChild(lastOption);
}
!이 함수가 실행되면 어떤 순서로 진행이 될까?
가장 먼저 지역변수가 선언될 것이다. 
length에 전역변수인 todoItems를 참조하여 todoItems.length의 값이 할당된다.
그리고 orderSelect.innerHTML에 ‘’;을 할당하여 쉽게 말하면 칸을 비워준다.
그 이후에 for문이 실행이 된다.
for문의 목적은 무엇인가? 
1. option태그의 생성.
2. option태그의 value에 num datatype의 값을 할당
이것은 순서를 구별하기 위함이다. 마지막과 구분하기 위함이라고도 할 수 있다. 문서를 제어하는 수단이 된다.
3. option 태그의 text에 항목 i + 1을 함으로써 쉽게 말해서 보통 일반인이 시작하는 숫자라고 생각하는 1부터 시작하게 만드는 것이다.
4. 이후 select의 마지막자식으로 덧붙인다.
추가될 항목이 for문을 통해서 모두 추가가 되었다면 마지막으로 마지막을 표시하는 option을 추가하기 위해서 lastOption이라는 지역변수를 선언하고 value와 text를 할당한다.
그리고 select의 마지막자식으로 appendChild한다.
!이 함수의 목적은 무엇일까?
함수 자체의 목적은 select태그에 option태그를 추가하기 위함이다. 배열에 지정되 있는 순서대로 번호를 매겨서 사용자가 인식하기 편하게한다. 
사용자가 항목을 통해서 todoItems 배열의 키에 접근하게 만든 것이다.
orderSelect.innerHTML을 공백으로 초기화하는 이유는 호출 되었을 때마다 새롭게 갱신된 todoItems의 값을 받아오기 때문에 기존의 값을 지우기 위함이다. 비우지 않으면 중복된 value를 가진 option이 추가될 수 있다.
2-2. updateView()
function updatVie() {
 root.innerHTML = '';
 for (let i = 0; i < todoItems.length; i++) {
  let itemElement = document.createElement('p');
  itemElement.textContent = `${todoItems[i]}`;
  root.appendChild(itemElement);
 }
 updateSelectOptions();
}
!함수의 순서는 어떻게 될까?
1. 먼저 updateSelectOption처럼 root의 innerHTML을 칸을 비워버린다. todoItems에서 값을 할당받기 때문에 중복되는 요소가 생기기 때문이다.
2. for문을 실행한다.
2-1. itemElement라는 지역변수가 선언된다. 여기서 itemElement의 역할은 html문서에 p태그를 추가하는 것이다.
2-2. itemElement의 textContent의 값으로 todoItems[i]의 값을 받아온다. 
2-3. root의 마지막 자식으로 itemElement를 덧붙인다.
3. updateSelectOptions()를 실행하여 항목을 갱신한다.
!이 함수의 목적은 무엇일까?
사용자에게 내용을 보여주는 것이 목적이다. todoItems의 값을 그대로 받아와서 p태그로서 문서에 그 값이 직접적으로 나타난다.
사용자가 todoItems를 추가 혹은 제거했을 때의 화면 변화를 사용자에게 알기쉽게 보여주는 것이 목적이다.
2-3. getInputValue()
function getInputValue() {
 return todoInput.value.trim();
}
!바로 값을 반환하는 함수이다.
문자열의 공백을 없애는 trim이라는 DOMAPI를 사용했다.
사용자가 입력하다가 생기는 이유 없는 공백을 없애기 위해 사용하는 것으로 추정된다.
2-4. getOrder()
function getOrder() {
 let orderValue = orderSelect.value;
 if (orderValue === "마지막";) {
  return todoItems.lenght - 1;
 } else {
  return parseInt(orderValue);
 }
}
!이 함수는 순서가 어떻게 될까?
1. 가장 먼저 지역변수 orderValue가 선언되고 값을 할당받을 것이다.
orderSelect의 value의 값을 할당받는다. orderSelect는 무엇인가? select태그다
select태그의 현재 선택되어 있는 option의 value를 할당하게 된다.
2. if문이 실행된다.
2-1. 만약 할당된 value의 값이 “마지막”이라면?
todoItems.legnth의 -1을 반환해라!
todoItems에 아무것도 추가되어 있지않다면 배열의 length는 0이기 때문에 -1이 반환될 것이다.
2-2. 마지막이 아니라면?
orderValue의 값을 정수로 치환하여 할당해라.
이 코드의 경우 for반복문으로 orderSelect.value의 값을 할당을 받고, updateSelectOption에서도 option은 value의 값을 정수로 받기 때문에 그대로 사용이 되지만, 컴퓨터가 오류로 인하여 실수가 반환이 될 수 있을 확률이 없지 않기 때문에 반드시 정수로 치환하는 과정을 거친다.
!이 함수의 목적은 무엇일까?
정수의 형태로 값을 반환 하는것이 목적이다.
누구든지 이 함수를 호출하면 정수의 값을 반환 받을 것이다.
2-5. addItem()
function addItem() {
 let newItem = getInputValue();
 let order = getOrder();
 if (newItem !== "") {
  if (order === todoItems.length - 1) {
   todoItems.push(newItem);
  } else {
   todoItems.splice(order, 0, newItem);
  }
  updateView();
  todoInput.value = ''; 
 } else {
  console.error("할 일을 입력해야 합니다.");
 }
}
!이 함수의 순서는 어떻게 될까?
1. addItem이 호출되는 순간 getInputValue를 호출하여 input태그의 value값을 newItem에 할당한다.
2. getOrder()를 호출하여 order에 num datatype value를 할당한다.
3. if문이 실행된다.
3-1. newItem이 할당 받은 값이 공란인지 아닌지를 판단한다.
3-1-1. 공란이 아니라면? 이번엔 order가 할당받은 값이 todoItems.length - 1과 값과 타입이 같은지 판단한다.
3-1-2. 값이 같다면? 실행한다. todoItems.push(newItem);을
push는 DOM API로 배열의 마지막에 매개변수를 추가하고 늘어난 length의 값을 반환한다.
따라서 값이 같다면 비어있는 todoItems에 새로운 값이 추가될 것이다.
이 if문은 selsect에 마지막과 마지막 바로 직전이 선택되어 있을 때 작동한다.
3-1-3. 같지 않다면? else를 실행한다.
DOM API중 하나인 array.prototype.splice를 사용하는데
splice는 3개의 매개변수를 갖는다. (a, b, c)
a는 선택할 인덱스 위치, b는 그 위치부터 삭제할 요소의 수, c는 삭제된 위치에 들어갈 값이다.
즉 이 else문은 todoItems[order]번째 위치에 newItem의 값을 추가한다.
요소를 삭제하지않으면 지정한 위치에 값을 추가하고 기존에 있던 값은 뒤로 밀려난다.
즉 원하는 항목 위치에 추가하기 위해서 있는 조건이다.
3-2. updateView()를 실행한다. todoItems에 변경사항이 생겼기 때문에 이를 감지하고 사용자에게 보이는 환경을 바꾸기 위함이다.
3-3. todoInput.value의 값을 비운다.
값을 비우는 이유는 이 값을 저장했기 때문이다. 사용자에게 backspace를 사용해서 굳이 값을 삭제하게 만드는 수고를 덜어주는 것이라고 할 수 있다.
4. if문의 조건에 해당하지 않을 경우 else를 실행한다.
todoInput에 아무것도 입력되지 않았는데 addItems를 실행하는 경우에 사용자에게 알리기위해서 콘솔창에 에러를 띄우는 용도이다.
!이 함수의 목적은 무엇일까?
사용자가 작성한 할일 목록을 사용자가 직접 볼 화면에 추가하여 화면에 나타나게 하는 역할을 한다.
주요 역할은 목록의 추가이다. 후에 updateView가 실행하면서 참조할 todoItems의 배열에 값을 추가해주는 역할
2-6. removeItem()
function removeItem() {
 let order = getOrder();
 if (order >= 0 && order < todoItems.length) {
  todoItems.splice(order, 1);
  updateView();
 } else {
  console.error("유효하지 않은 순서입니다.");
 }
}
!이 함수는 어떤 순서로 작동하는가?
1. 먼저 order가 지역변수로 선언되고, getOrder()함수를 호출하여 반환된 값을 할당받아 초기화된다.
2. 조건문인 if의 조건을 확인한다.
2-1. order가 0보다 크거나 같고, order가 todoItems의 length의 값보다 작다면 (둘 모두를 충족한다면) 
todoItems[order]위치에있는 1개의 요소를 삭제한다.
이후 값이 변동되었으므로 updateView함수를 실행해서 반영한다.
2-2. 그렇지 않다면?
이 경우 제거할 항목이 없는 경우를 뜻한다. 제거할 항목이 없기 때문에 사용자에게 보내는 에러를 콘솔창에 기록한다.
!이 함수의 목적은 무엇일까?
더도덜도말고 항목의 삭제가 목적이다.
사용자가 실수로 추가한 항목 혹은 달성한 항목을 지우는 용도라고 할 수 있다.
3. 그렇다면 실제로 이 프로그램은 어떤식으로 동작할까?
1. 사용자가 todoInput에 값을 입력하면서 시작이된다.
2. 사용자가 todoInput에 값을 입력하고 addItem버튼을 누르면
3. 바로 addItem()함수가 호출되고 변수를 초기화하기 위하여 getInputValue()함수가 호출된다.  getInputValue()함수는 사용자가 입력한 todoInput.value의 필요없는 공백을 지운 값을 반환한다.
4. 그 이후 위치를 잡기위한 변수 order를 초기화하기 위해서 getOrder()함수가 호출이된다. 현시점 추가된 항목이 아무것도 없는 상태이기 때문에 orderSelect.value는 ‘마지막’일 것이고 getOrder()는 todoItems.length - 1 을 반환한다.
아직까지는 todoItems에 추가된 것이 아무것도 없으므로  0 - 1 즉 -1이 반환된다.
5. if문에서 조건을 판단한다. newItem이 공백이 아니라고 판단했을 때 order === todoItems.length - 1이 true값이므로 실행문을 실행한다.
이때 DOMAPI push()가 사용되어 전역변수 todoItems의 배열에 변화가 생긴다.
todoItems = [”사용자가 입력한 값”];
6. 성공적으로 조건문 안의 조건문을 처리했다면 남은 todoItems에 변화가 생겼으므로 updateView함수가 실행된다.
7. updateView함수는 시작과 동시에 혹시 있을지 모르는 root의 innerHTML을 비워버린다.
8. 그 다음 todoItems를 참조하여 반복제어문을 실행한다.
9. itemElement란 변수에 문서에서 생성한 p태그를 할당한다.
10. 생성된 p태그의 textContent에 todoItems[i]의 값을 할당한다.
11. 이후 생성된 p태그를 div#root의 마지막자식으로 덧붙인다.
12. 반복제어문을 탈출하고 마찬가지로 todoItems에 변동이생겼으므로 updateSelectOption 함수를 실행한다.
13. 먼저 todoItems.length값을 length라는 지역변수에 할당한다.
14. 그리고 혹시 있을지 모를 select의 innerHTML을 비워준다.
15. 조건에 따라 반복제어문을 실행한다.
16. 문서안에 새로운 option태그를 만들어 option에 할당한다.
17. option의 value에 i를 할당한다
18. option의 text에 항목 i를 할당한다. 
19. 만들어진 option을 orderSelect의 마지막자식으로 덧붙인다.
20. 이후 마지막을 표시하기 위하여 lastOption이라는 변수를 선언하고 문서에서 option을 만들어서 할당한다.
21. lastOption의 value와 text를 할당한다.
22. lastOption을 orderSelect의 마지막자식으로 덧붙인다.
23. 이제 addItem으로 다시 돌아와 사용자가 입력한 todoInput의 value를 지워버린다.
글씨 쓰는 연습을 좀 해야할것같다.
해볼것 updateSelectOptions addItem과 removeItem에 추가해보기 updateView를 updateSelectOptions에 넣고 addItem과 removeItem에 updateSelectOptions를 넣어보기.
생산성 때문이 맞는 것 같다.

URL: https://www.notion.so/24-05-02-5051400fa2784e36a0603e17310f7855
polyfill이 뭘까? 검색해볼 키워드~!
classroom에 for문과 if문이 직관적이지 않은 이유는 연습을 시키기 위함이다.
정렬 알고리즘 ?
오늘의 훈련 포인트 코드 리딩법
1. 당연히 암호이기 떄문에 직관적이지 않다.(받아들여야 하는 숙명) → ‘코드를 볼 때 짜증나는 현상’을 없애야함.
2. ★실제값(리터럴 : 직접 쓴 값)이 무엇인지 모르는데, ‘어떤 데이터 타입인지는 확실해 보인다.’ 
→ 추론에 해당한다. 내가 하면서 수없이 많이 해보아야 할 개념.
→ 시뮬레이션(simulation), 이미지 트레이닝(image training)
→ ☆ x 1,000,000
3. 어떤 코드가 막히면 / 일단 멈춘다. 그리고 그 다음에 원리를 찾아야 한다. 原理を探すべき。
강사님은 왜 갑자기 let을 쓸까? 
변수선언을 var, let, const를 사용하는데 그 차이가 무엇일까?
→  그런갑지 하면 안된다. 찾아보자! 주말에 할 일? 일인가? 할 것? 일이라고 생각되지는 않는데? 내 지식이 넓혀지는 소리가 들린다.
처음보는 코드를 만나고 그 코드를 파악하고 내것으로 만들 때의 행동 순서.
1. 예측을 먼저해라! ( 내가 아는 것 기준으로 )
2. 내가 알고 있는 ‘기본’형태의 ‘작성법’만 쓴다. → “여기까지는 이해했다.” 라는 보증이 된다. ‘원초적인 형태‘
이런 식으로 코드를 ‘분해 하기만 한다면’ 해석 못하는 코드는 없다.
 <script>
    // 따라해봅시다.
    // 첫 시작은 언제나 일부로라도 어렵게! 굉장히 비효율적이지만, 이해의 누락을 없앨 수 있다.
    // 이해에 누락이 생겼다면? 바로 확인 할 수 있는 방법을 알려주는 것.
    
    
    
    function addItem(array, item, index) {
      // 잠시 진실을 주석처리하고 새로 변수로 할당한 newArray를 return으로 넣어서 작동이 되나 확인을 해본다.
      // 확인이 되었다. 그럼 이제 다시 공란으로 만들어주자.
      let newArray = [];
      // teacher : newArray라는 변수를 배열로 할당했네? 아 그럼 문자열은 아닌가보다.
      
      // teacher : 함수가 선언되어있네? 몰라 일단 넘어가 얘는 나중에 필요하면 보면 되지.

      // 조건이 크거나 같을 때 까지, 반복해라 라는 말이 있다. 여기서 무엇을 추론할 수 있는가?
      // 무언가 추가가 되겠구나.
      for( let i = 0; i <= array.length; i++) {
        // teacher : 조건문 
        // teacher : array가 있네? array가 위에있네? 아 직관적으로 매개변수로 array를 받아온다는 의미구나 라고 캐치!
        // teacher : 반복문이 돌고, length, "array"라는 이름이 무엇인지 모르겠음. 찾아보니 매개변수에 있네?
        // teacher : 높은 확률로 array라는 놈은 배열일 것이다.

        function isIndexAfterInsertionPoint(currentIndex) {
          // else if에 함수를 실행하러 왔다.
          return currentIndex > index;
          // 매개변수로 할당된 것이 index보다 크다면! 여기서 index는 num타입이므로 currentIndex또한 숫자를 받아옴을 알 수 있다.
          // 그리고 else if의 조건을 보았을 때 true를 굳이 지정한 것으로 보아 이 함수가 불리언타입을 리턴함을 알 수 있다.
        }

        if( i === index ) {
          // teacher : 뭐야 index어디있어? 뭐야 index도 매개변수였네. 
          // teacher : 내가 생각하는게 index가 아니네 그럼 i랑 같아지려면 숫자를 비교하려는 if문 때문에 만들어 놓은거네?
          
          // 이것을 확인하기위해 index자리에 2를 주었다 그렇다면 키위가 로그 될 것이다.
          // 확인결과 공욱재 미남 키위 키위 인데, 키위가 순서대로 반복하다가 36줄이 먼저 실행됬음을 확인 할 수 있었다.
          // 이것으로 나는 이 index가 숫자를 받아옴을 알 수 있다.
          // console.log('나 키위 아니야');
          // teacher : 난 키위가 아니니까 내 생각과 맞다면 실행되도록 사용했다.

          // undefined가 나오는 이유? newArray의 다른 요소들은 지정된 것이 없으니까.
          // 그렇다면 다른 것도 채우겠지? 그리고 크거나 작은거니까 하나가 추가될 거야.
          // 원하는 자리에 추가하기 위해서 이것을 사용하는 거구나! 라고 추측할 수 있지 않을까?
          // 매개변수 index순번에 item의 프로퍼티를 넣기 위한거야.
          // 그러면서 기존의 배열의 값들은 유지하고 싶어서 length와 작거나 같다라고 지정한거고.
          newArray[i] = item;
          // teacher : 뭐야 newArray에 i번째에 할당은 알겠는데 item이 뭐지? 찾아보니까 매개변수에 있네?
          // teacher : 테스트를 위해 "나 키위 아니야!"를 매개변수로 넣었다.

          // 함수가 나왔으니까 함수를 확인해야 겠지?
        } else if (isIndexAfterInsertionPoint(i) === true) {
          
          // 이 함수를 하면 무엇인가 array.length보다 크다는 것이다 i가 즉 추가가 된 이후의 것들을 넣어야한다.
          newArray[i] = array[ i - 1 ];
          // else if로 실행되는 newArray[i]는 이미 array보다 값이 하나 추가된 상태이다.
          // 그리고 array[i]는 마지막에 uncaught를 띄울 것이다. 왜냐하면 그것이 배열의 특성이니까 
          // 그래서 array[ i - 1 ]을 할 필요가 있다.

        } else {
          // newArray[i]에 array[i]를 할당해줘.
          // 그러면 마지막 값은 undefined가 되버릴 것이다. 
          // 왜냐하면 이 반복문의 조건은 array.length니까 array의 배열보다 1개가 많다.
          // 1개를 추가하는 것이 if의 조건을 만족하는 것이었으니까 그럼 else if를 추가해야겠지?
          newArray[i] = array[i];
          // teacher : index 와 i가 같이 매칭이 되지 않으면 실행해줘.
        }
        
        // 왜 array의 length를 읽지 못할까?
        // 이유는 간단했다, 밑의 for문에 매개변수를 추가하지 않았기 때문이다.
        // 아까 원래대로 돌리지않고 addItem함수의 length를 조건문으로 넣었기 때문에 발생한 오류였다.
        // 그런데 이제 또 새로운 의문이 생겼다.
        // 어째서 이놈은 5번 실행이 되는가?
        // 이번에도 이유를 알았다. 밑에 addItem()을 조건으로 넣었는데 그래서 인지 이게 실행이 되버린다.
        // updatePlanet을 할당할 때 함수가 호출되서 호출되는 함수가 실행되는 곳은 여기여서 콘솔창에는
        // 여기서 실행이 된다고 나오는구나!
        // console.log(newArray);

        // 오류가 찍히는데 이유는 array는 array.length와 같은 값인 3에 해당하는 자리에 요소가 없기 때문이다.
        // console.log(array[i]);
        // teacher : 한번 확인할겸 돌려보자.
        // teacher : 테스트가 끝났으니까 일단 지워버리기. // 나는 주석처리.
      }

      // 문자열을 리턴했고 이것이 updatePlanet에 할당했으므로, 공 욱 재 미 남 이 한글자씩 콘솔창에 로그될 것이다.
      // 근거는 리턴이 있다는 것을 알고 있기 때문에, 리턴 값을매겨서 일단 확인을 한다. 내 생각이 맞는지.
      return newArray; //"공욱재미남";
      // teacher : 지금 본인이 아는 형태까지만 확인을 한다! 가장 기본형태로. 이 함수가 실행 하는지
      // teacher : 내가 아는만큼만 적어야 합니다.
      // teacher : 지금 이 return "공욱재미남"으로도 돌아가야한다.
      // teacher : 이것을 실행하면 스스로가 여기까지는 이해했다고 하는 보증이 생긴다.
      // teacher : 돌아가는 것을 확인 했기 때문에 밑의 for문과 updatePlanet은 신경 쓸 필요가 없다.
      
    }

    

    // 가장 먼저 읽는 1번 행동.
    // 전역변수로서 planets에 배열을 할당.
    let planets = ["공욱재", "미남", "키위"];
    // teacher : 배열 하나 만들어주자.

    // 전역변수로 addItem()함수로 값을 할당받는 updatePlanet을 선언.
    // 여기서 유추할 수 있는 것은 함수를 호출하여 값을 할당받는다는 것으로 return이 된다는 것을 알 수 있다.
    let updatePlanet = addItem(planets, "나 키위 아니야!", 2);
    // teacher : 함수를 호출하는데, 얘를 변수에 담네? 그럼 이건 값인가?
    
    // 반복제어문인 for문을 실행한다. 무언가가 반복될 것이다.
    // for문에 length가 붙었다? 그럼 배열이나 string일 확률이 높다. 무언가 살펴볼려고 하는 것 같다.
    // updatePlanet이 length를 담고 있으니까 문자열이거나 배열일 확률이 높다.
    for(let i = 0; i < updatePlanet.length ; i++){
      // 어차피 값을 할당받는 것이기 때문에 함수자체를 넣어도 상관은 없구나?
      // 왜냐하면 함수가 return하는게 배열이니까.
      // teacher : 문자열이거나, 배열일 확률이 높다. 숫자가 들어간다. 그럼 문자열이거나 배열이다. 판단 근거 포인트.
      console.log(updatePlanet[i]);
      // teacher : 콘솔로그를 반복해서 찍으려고 하는구나? 값이 뭔지는 모르겠어. 근데 length값이래 실제로 뭐가 찍힐지도 몰라.
      // teacher : 일단 로그가 찍히긴 해.
    }
    // teacher : 해결할 것을 모두 해결했다. 그럼 역순으로 돌아가자. addItem()은 뭐지?
  </script>

URL: https://www.notion.so/24-05-01-3cca7043fe9a418b84fc4e6b399ef076
Warming up!
classroom programming 5 - 1 의 코드를 읽어보자! 문해력 테스트!
먼저 이 코드를 읽고 어떻게 진행이 될지 글로 적어보고 이후 어떤 결과가 도출될지 예상까지 해보고 콘솔로그를 통해 그것을 출력하여 자신의 예상이 맞는지 확인하자!
<script>
    function whatWork(inputString){
      // 함수를 선언할게 이름은 whatWork야 매개변수를 받을꺼야.
      let result = "";
      // 지역변수로서 result를 선언하고 문자열 타입을 할당해서 초기화할게.
      let isWhatWorked = false;
      // 지역변수로서 isWhatWorked를 선언하고 값을 false로 할당함으로써 불리언타입으로 초기화할게 
      let space = " ";
      // 지역변수로 space를 문자열타입로 초기화할게 공백( )을 할당했어.

      for (let i = 0; i < inputString.length; i++){
        // 반복해줘 무엇을? 실행문을 i = 0이고, 실행문이 실행될때마다 i에 i+1을 할당할꺼야
        // 조건이 맞다면 계속해서 반복해줘.
        if(inputString[i] !== space){
          // 1. 만약 입력한 문자열의 인덱스서순 i번째가 지역변수 space와 같지 않다면? if의 실행문을 실행해줘
          if(isWhatWorked === true){
            // 1-1. 만약 1번을 통과했다면 한번 더 점검할게, 지금 isWhatWorked가 true라면 1-1 의 실행문을 실행해줘 아니라면 출력하지마!
            result = result + inputString[i];
            // 실행문 지역변수 result에 result + inputString[i]의 값을 할당해줘
            
            // 1-1 해당 되지 않는다면? 실행하지 않고 증감식으로 넘어가
            // 1-2 실행문이 모두 끝났으므로, i++
            // 1-3 다시 조건을 확인하고 만약 조건이 true라면 1로 돌아감
          } else {
            // 2. 만약 1을 만족하지 못했다면, 이것을 실행해줘!
            if(inputString[i] !== space){
              // 2-1. 만약 inputString[i]가 지역변수 space와 타입과 값이 같지 않다면? 실행문을 실행해줘
              isWhatWorked = true;
              // isWhatWorked의 값을 true로 할당해줘
              result = result + inputString[i];
              // 지역변수 result에 result + inputString[i]를 할당해줘.
              
              // 2-1 해당 되지 않는다면? 실행할 실행문이 없으므로 증감식으로 넘어가!
              // 2-2 실행문이 모두 끝났으므로, i++
              // 2-3 다시 조건을 확인하고 만약 조건이 true라면 1로 돌아감
            }
          }
        }
      }
      return result;
      // 3. whatWork함수를 호출하면 값으로 result를 반환해줘! 어떤 result? for반복문이 모두 끝나고 할당 된 지역변수 result의 값을 반환해줘!
    }
    /*
    이 함수를 실행하는 순간 어떻게 진행이 될까?
    먼저 지역변수들이 초기화된다. 이름과 값이 할당된다.
    이 후 for반복제어문이 실행이된다.
    이 때 반복제어문은 i=0부터 시작하여 조건식이 맞는 inputString.length 즉 입력된 매개변수의 마지막 문자열이 끝날 때 까지 진행된다.
    시작된 반복문은 조건문을 만나서 두가지로 갈라선다. 만약 조건이 true라면 첫번째 if문의 실행문을 실행할 것이고, 그렇지 않다면 else의 실행문을 실행한다.
    각각의 실행문에 돌입하면 그 안에 새로운 조건문이 있음을 확인할 수 있다. 다시한번 조건에 true라면 그 조건문을 실행할 것이고, 그렇지 않다면 따로 지정되어있지 않기 때문에 값은 출력되지 않는다.
    이렇게 반복을 계속한 후, 반복제어문이 끝나는 시점에서 result의 값이 새롭게 할당되어 있을것이다. 
    정확히는 실행문에서 계속해서 값을 새로 대입하므로 반복문이 끝난 시점에선 result의 값이 초기화때와는 다르다.
    이 result를 함수를 호출하면 출력되도록 return을 통해 반환해준다.
    그러면 결과물로써 space에 해당하는 공백이 모두 빠진 채로 inputString에 해당하는 객체의 문자열이 출력될 것이다.
    */
    const quotes = "성공은 결과이지 목적이 아니다. 목적은 당신이 무엇을 하느냐이다."; // 알버트 슈바이처
    // 변수를 선언할게 이름은 quotes고 값으로는 문자열을 할당할꺼야. 
    const trimmedQuotes = whatWork(quotes);
    // 변수를 선언할게 이름은 trimmedQuotes고 값은 whatWork함수에 매개변수로 quotes를 넣었을 때의 출력값이야.
    console.log(trimmedQuotes);
    // 브라우저야 콘솔창에 trimmedQuotes좀 기록해줘.
  </script>
강사님의 Comment!
지역변수! 하루살이같은 녀석들 선언한 스코프 안에서만 존재한다!
쓰이고는 사라져버리는 친구들.
함수가 있네? 그렇다면 먼저 확인해야할 것은 return!
그리고 이 함수를 어디서 호출하는지 확인.
→ 그 함수가 어떤 용도로 제작이 되었는지를 확인! 이후 호출되는 값을 확인!
→ 그 다음에 함수를 살펴본다.
→ 내가 봐야할 것은 최종 실행 하는 것이 무엇인지를 확인 하는 것.
→ 결국 위의 모든 코드가 마지막 한줄 코드를 실행하기 위함이다.
→ 마지막으론 의도를 찾아내라. 
→ 위 코드의 의도는 문자열내의 공백을 제외한 문자를 출력하는 것이다.
→ 빠르면은 리턴을 보자마자 뭐던간에 문자열을 반환하겠구나~ 라고 깨달을 것.
강사님의 깨알 Tip! ★ 
함수를 만났어? 그럼 일단 return부터 본다! return의 유무를 확인한다.
협업을 하는 동료의 함수를 만났다.
1차적으로 일단 return의 유무를 확인한다. 
→ return이 있다면? 그 return의 데이터 타입을 확인해라!
→ ‘실행문 (로직)’의 가장 부모격인 명령을 찾아내라!
1. 24/05/01 미션 자가 체크리스트
1. 디자이너가 만든 시안을 마크업(HTML,CSS)로 만들 수 있는지
2. 만들어진 정적페이지를 동적으로 변환작업 할 수 있는지
3. 간단한 클릭이벤트를 설치할 수 있는지
가져갈 단어
toggler 와 drawer를 찾아보자! 해당되는 함수이다.
문해력의 중요성을 계속해서 강조하고계신다.
사실 처음에 강사님이 programming5-1을 읽을 수 있는 사람을 찾았을 때 읽을 수 있었다. 하지만 내가 읽는 것이 맞나? 라는 생각을 했다.
아직 확신이 없는 것이다. 내가 예상을 했고, 그 예상한 대로 값이 출력되었음에도 불구하고 말이다.
혹은 나의 실력이 그만큼 올랐다고도 할 수 있다. 하지만 이건 좀 자만같다. 아직도 내가 하지 못하는 것이 너무나도 많기 때문이다. 하지만 찾는 법은 알아냈지.
이번 수업에서 내가 느낀 가장 중요한 점은 함수를 읽는 순서이다.
함수는 결국 무언가를 하기 위해서 만들어 졌다. 그 결과값을 먼저 보면 함수의 실행문을 이해하는데 도움이 된다.
이는 내가 글을 읽을 때와는 다른데, 글은 글을 읽고나서 작가의 의도를 파악한다고 하면, 함수는 먼저 result값을 보고 추측하여 해석할 수 있다.
강사님은 나에게 아니 우리에게 많은 자유시간을 주신다.
이 자유시간은 말미암아 미래를 위함이니라.
요새 나는 자유시간을 어떻게 쓰고있지?
체크해야 할 부분이긴 하다.
오늘의 나는 나의 자유시간에 무엇을 하였는가?
왜 남의 코드를 그렇게 궁금해 하는가?
오전시간에는 강사님이 던저주신 함수를 계속해서 읽었다.
도저히 이해가 가지 않았다. 
나중에 내 식으로 풀었을 때, 나는 나의 눈의 함정에 속았다는 것을 알 수 있었다.
물론 그것이 옳은지 틀린지는 미래의 나 혹은 강사님만이 알 것이다.
오후에는 무엇을 하였는가? 오전에 나는 상당히 머리에 부하가 왔었다. 머리가 아파왔다는 뜻이다.
점심시간은 밥을 먹고 충분한 휴식을 취했다.
오후시간에는 다시 함수를 보았다. 그때 내 나름의 정의를 내릴 수 있었다.
이후는 만들던 것을 다시 간략화하는 작업에 들어갔다.
DeepDive책을 참고하여 event.target을 중점으로 보았다.
GitHub의 선배님들의 코드가 나에게 도움이 되었다.
그것으로 내가 e.target을 찾아낼 수 있었으니까
e.target을 찾아내고 나서는 전날 challenge5를 수정했다.
아주 긴 코드를 18줄로 줄일 수 있었다.
이래서 사람은 배워야한다.
이후 과거 만든 빙고판을 건들다가 오류를 발견해 냈다.
오류의 원인은 바로 규명할 수 있었고 그것을 고쳤다.
중간중간에 휴식시간이 있었는데, 다른 사람의 작업물을 구경하거나 작업물에서 궁금한 점을 물어보았다.
타인에게 설명을 해보기도 했는데, 아직도 설명은 익숙치 않다.
이상으로 금일 수업시간에 있었던 내용을 모두 정리한다.

URL: https://www.notion.so/5-251ca0baee2444fd88decee944b63f35
24/05/01
24/05/02
24/05/03

URL: https://www.notion.so/5-3a4ed6a83d2b42b0959c4e18cd9eddbf
5월 첫째 주
5월 둘째 주
5월 셋째 주
5월 넷째 주
5월 마지막 주

URL: https://www.notion.so/4-6b67acea4e62488fa5086e730d0f958f
강의 첫 주
4월 둘째 주
4월 셋째 주
4월 넷째 주
4월 마지막 주

URL: https://www.notion.so/4-1202712098054ac7a2324df14f54cf3c
무엇을 적을까?
나는 이번 달을 어떻게 보냈는가?
나는 이번 달에 무엇을 할 수 있게 되었는가?
나는 이제 무엇을 만들고 싶은가?
나는 무엇을 배웠는가?
나의 목표는 무엇인가?
다음 달을 대비하는 나의 목표는 무엇인가?
결산 방법
1. 주차별 “대표 키워드” 선정
기억하기좋으라고
2. 스스로 잘해냈다고 판단되는 “기록” 목록화
불안없애기
3. 값(돈)으로 환산한다면, 총 얼마?
하루 인건비 7만원 예상
수치로 이야기 가능?
결산 이후 전략 수립
1. 주차별 목표 수립. 현실성 없어도 됨! 일단 목표는 높게!
주차별 “비현실적인 목표!”
1주차.
display : flex; 
생활패턴 개선의 시작
vscode로 만드는 문서 작업.
사람의 몸은 물에 뜰 수 있다.
//
내가 잘했다고 생각하는 것?
노션에 생각한 것들 적어둔것
생각 정리할 겸 문서화시킨 것
새벽반으로 수영반을 신청한 것
//
1주를 돈으로환산하면 과연 얼마나 할까? 얼마 만큼의 가치가 있었을까?
일단 나는 물에 뜰 수 있게되었다. 이것은 먼 훗날 어쩌면 내 목숨을 구할 수도 있는 능력이다.
자전거를 타고 다녔다. 타고다니면서 생각도 정리를 했다. 일석이조가 아닐까?
하루를 7만원이라고 생각했을 때, 내가 얻은 지식적가치를 생각하면 적어도 일주일 40만원은 넘게 벌은 것 같다.
//
1주차 전략?
비현실적 목표 : if와 for문을 수족처럼 다루기! 나 지금 너무 하고 싶음. 이거.
현실적 목표 : for문을 오버플로우가 뜰 것같은것은 알아채기.
2주차.
사전 드로잉? 사전 레이아웃의 중요성.
순서의 중요성
큰것에서 작은것으로
인지하는 것은 중요하다! 신경을 써서 고치면 고쳐진다!
//
게임만들고 싶은거 떠오를때마다 적었다.
비가 와도 걸어서 수영장에 갔다왔다. 나와의 약속을 지킨것!
//
난 진짜로 값어치로 따지면 내가 노가다 할때만큼의 값을 매겨도 된다고 생각하는걸? 52만원
//
비현실적인 목표 : 나의 식단 완벽하게 컨트롤 하기
현실적인 목표 : 음료수 안마시기. 안 사먹기.
3주차.
시작하는 자바스크립트
알고보니 모두 객체
7가지의 데이터타입
때로는 노가다도 도움이 된다.
//
상당히 많은 것들을 보면서 저것도 객체아닌가? 생각이 든다.
나 이제 물에 엎드릴 수 있다! 물에 엎드려서 발장구도 칠 수 있다!
//
중간에 막힘이 조금씩 있었다. 나의 고생을 생각하면 아무래도 동일하다. 52만원이야!
//
비현실적인 목표 : 게임 완성시키기!
현실적인 목표 : 게임 로그인화면 레이아웃 만들기!
4주차.
제어의 시작
이제 나도 컴퓨터한테 일을 시킨다.
컴퓨터는 생각보다 멍청하다.
나 이제 물에 엎드려서 팔을 뻗을 수 있다. 자유영에 익숙해지고있다.
그리고 눕기도 시작한다!
//
안 돌아가던 어깨가 돌아가기 시작한다! 삐걱대던 관절이 움직이기 시작해!
확인 하는 작업을 하니 내가 생각한게 되는 것이 확인이 된다! 거기에서 간략화를 시도할 수 있게되었다!
강사님이 주신 테스트에서 한발자국 더 나아가서 시도할 수 있게되었다! 
//
이번 주 급여? 하.. 이번 주 과거의 나와 싸웠다. 많이는 못주겠다! 30만원!
//
비현실적인 목표 : 몸무게 70kg!
현실적인 목표 : 몸무게 두자리수로!

URL: https://www.notion.so/24-04-30-1fc06e603c0d41c4ab61b335a0fbc51f
1. github : 깃허브 ‘서비스’
개발자의 SNS 
→ MicroSoft
→ 실력과 기울기를 설명할 수 있는 유일한 창구일수도 있다.
→ 실력 입증 보다는 기울기를 이야기할 수 있을 것
Git : 버전 관리 SoftWare
→ 오픈소스 SoftWare
GitHub : 소셜 앱(Social Service App)
→ ‘저장소’ 서비스
Git과 GitHub는 다르다! ← 인지할 것.
취업할 때 핵심포트폴리오로서 사용할 수 있다.
지표상으로 그 사람을 판단할 수 있는 기저가 된다.
누군가의 주관적인 관점이 투과된다. 때문에 필터링 할 방법이 없다. 보는 사람의 가치관, 경험, 관점 등등이 투과된다.
개발자들이 노는 플레이 그라운드!
일반인들의 소셜 네트워크 서비스와는 다르다. 나의 일 작업량 나의 실력을 입증하기 위하여 사용하는 것.
깃허브로 나의 성실성을 입증할 수 있다.
앞으로 모든 검색은 깃허브를 통해서 시도해보도록하자.
단점 : 쓸데없이 많은 지표를 함축해서 내가 판단을 받게된다.  
→ 오해를 받기 쉽다.
→ 그렇기 때문에 나는 따라줘야한다. 잔디심기(grass seed!)
→ 오히려 그렇기 때문에 성실성 진정성을 입증할 수단이 될 수 있다.
2. 앞으로의 작업!
모든 작업이 로그가 남아서 → 포트폴리오로 활용하자.
기록을 하자! 
내가 도저히 이해가 가지 않는다. 그럼 모두 기록을 해둔다. 기록에서 찾아낸다. 무엇을 이해하지 못했는지.
→ 이는 일일 업무 보고이기 때문에  업무 기본에 해당한다.
→ Tip★ 6시쯤 개인 알람 매일!
내가 생각하는 오전시간의 키워드는?
월간 결산.
DOM API를 사용한 제어
우리의 스트레스는 무엇이고, 나의 책임을 질 구석은 무엇이며, 내가 감당해야할 것은 무엇인가? 

